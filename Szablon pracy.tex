% 1. Należy w programie ustawić zgodne kodowanie, w tym przypadku jest UTF-8. 
% 2. Kompilować ten plik za pomocą pdfLatex.


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Ustawienia pracy.
%____________________________________________________________________________________________

% Obowiązkowo! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definiowanie stylu i formatu pracy.
\documentclass[a4paper,twoside,12pt]{book}	% twoside - dwustronnie		 
\usepackage{polski}		 		% ustawienie języka
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[utf8]{inputenc}	
\usepackage{latexsym}
\usepackage{indentfirst} 				% wcięcia akapitu
\linespread{1.5}					% odstęp między liniami
\usepackage{geometry}
\geometry{lmargin=3.5cm, rmargin=3cm}	% ustawienie marginesów, lewy większy na oprawę

\usepackage{url}
\usepackage{enumerate}				% numeracja
\usepackage{amsopn}
\usepackage{graphicx} 				% grafika
\usepackage{epstopdf}				% grafika formatu eps
\usepackage{tabularx} 				% tabele
\usepackage{hyperref} 				% łącza
\usepackage{picture} 				% rysunki
\usepackage{upgreek}				% greckie symbole

\usepackage{listings}				% listingi
\usepackage{color}					% kolory


 % Polecenie usunięcia paginy na pustej stronie.
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} 	


% Zmiana nazwy rozdziału z listingami, domyślnie jest Listings.
\renewcommand{\lstlistlistingname}{Spis listingów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec



% Dodatkowo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definicje własnych otoczeń.
\theoremstyle{definition}
\newtheorem{dfn}{Definicja}[chapter]
\newtheorem{prz}[dfn]{Przykład}

\theoremstyle{remark}
\newtheorem{wsk}[dfn]{Wniosek}
% koniec


% Definiowanie własnego stylu listingu.
\lstset{
  frame             	= lines,
  basicstyle        	= \linespread{1}\ttfamily,%\small\footnotesize,
  columns           	= fullflexible,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
  breaklines=true,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec	 



\begin{document}

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Strona tytułowa.
%____________________________________________________________________________________________

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother 
% Tutaj wszystko należny wypełnić w nawiasach {}, nic więcej nie zmieniać!

\author{\textbf{Piotr Jasina}}        	% Podaj imię i nazwisko.
\title{Identyfikacja inteligentnych kontraktów w sieci Ethereum}      % Podaj tytuł polski.
\date{{\textbf{Lublin rok \the\year}}}	% Nic nie zmieniaj, rok wygeneruje automatycznie.
\def\engtitle{Ethereum smart contracts identification} % Podaj tytuł angielski.

\def\kierunek{Informatyka}		% Podaj kierunek studiów.
\def\specjalnosc{.....}			% Podaj specjalność, jeśli istnieje.
\def\nralbumu{279183}			% Podaj nr albumu.

\def\rodzaj{licencjacka}			% Podaj rodzaj pracy.
\def\zaklad{Zakładzie Cyberbezpieczeństwa}	% Podaj nazwę zakładu Twojego promotora.
\def\promotor{dr. Damiana Rusinka}	% Podaj promotora.

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Poniżej w {titlepage} nic nie zmieniać.

\renewcommand{\maketitle}{
\begin{titlepage}
\begin{table}
\begin{tabular}{c@{\hspace{10mm}}|@{\hspace{3mm}}l}
\multicolumn{2}{@{\hspace{15mm}}l}{\vspace{-31mm}} \\
\multicolumn{2}{l}{\hspace{-20mm}\includegraphics[scale=0.4]{UMCS}} \\ 
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{7mm}} \\

\multicolumn{2}{@{\hspace{16mm}}l}{\Large UNIWERSYTET MARII CURIE-SKŁODOWSKIEJ} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large W LUBLINIE} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large Wydział Matematyki, Fizyki i Informatyki} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{16mm}} \\

& \multicolumn{1}{m{13cm}}{Kierunek: \kierunek} \\
% Jeśli nie ma specjalności, to należy zakomentować poniższą linijkę!
% & \multicolumn{1}{m{13cm}}{Specjalność: \specjalnosc} \\
& \\
& \multicolumn{1}{m{13cm}}{\@author} \\
& \multicolumn{1}{m{13cm}}{nr albumu: \nralbumu} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{\Large\textbf{\@title}} \\
& \\
& \multicolumn{1}{m{13cm}}{\engtitle} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{Praca \rodzaj} \\	
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{napisana w \zaklad} \\
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{pod kierunkiem \promotor} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\vspace{7mm}} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\@date}
\end{tabular}
\end{table}
\end{titlepage}
}
% koniec 

% Tworzenie strony tytułowej.
\maketitle
% Wyczyszczenie z numeracji strony za stroną tytułową. 
\clearemptydoublepage


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis treści. 
%____________________________________________________________________________________________
\tableofcontents 		
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 	
\clearemptydoublepage			


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Wstęp pracy.
%____________________________________________________________________________________________
\chapter*{Wstęp}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Wstęp} 	% bez numeru w spisie treści

...
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 1.
%____________________________________________________________________________________________
\chapter[Ethereum]{Ethereum}
% W nawiasach [] zapisujemy skróconą nazwę rozdziału, pojawiający się w paginie górnej oraz w spisie treści.
% W nawiasach {} zapisujemy pełną nazwę rozdziału.
% '\protect \\' służy do dzielenia długiej nazwy rozdziału.

\section{Historia}

Literatura: \cite{autor1, autor2}. TODO


\section{Opis platformy}

Literatura: \cite{autor1, autor2}. TODO

\section{Ethereum Virtual Machine}

Literatura: \cite{autor1, autor2}. TODO

\section{Inteligentne kontrakty}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 2.
%____________________________________________________________________________________________
\chapter[Solidity]{Solidity}

\section{Sygnatura funkcji}

Literatura: \cite{autor1, autor2}. TODO


\section{Selektor funkcji}

Literatura: \cite{autor1, autor2}. TODO

\section{Generowanie akcesorów podczas kompilacji}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 3.
%____________________________________________________________________________________________
\chapter[Projekt Aplikacji]{Projekt Aplikacji}
Celem mojej pracy licencjackiej było stworzenie umożliwiającej identyfikację  inteligentnych kontraktów wykorzystywanych w sieci Ethereum. Dzięki aplikacji użytkownik po wprowadzeniu na stronie kodu bajtowego kontraktu jest w stanie otrzymać najbardziej prawdopodobną implementacje kontraktu napisana w języku Solidity bazując na bazie danych aplikacji.

Aplikacja realizująca cel pracy została stworzona przy wykorzystaniu frameworka Spring Boot, jest to aplikacja internetowa, dzięki czemu można ja wykorzystać wielu urządzeniach bez konieczności instalacji. W celu przechowywania danych wykorzystano nierelacyjną bazę danych MongoDB.

Poniżej opisałem działanie aplikacji wraz ze szczegółowym opisem funkcjonalności, architektury oraz wykorzystanych technologi.
\section{Opis funkcjonalności}


Na stronie głównej znajduje się opis aplikacji wraz z aktualna liczba kodów źródłowych znajdujących się w bazie danych oraz podstawowe definicje związane z aplikacją. Cała aplikacji udostępnia trzy główne funkcjonalności: identyfikację inteligentnych kontraktu, wprowadzanie plików źródłowych kontraktów do aplikacji oraz interfejs programistyczny aplikacji. Wszystkie funkcjonalności zostały opisane poniżej

\subsection{Identyfikacja inteligentnych kontraktów}
Pierwsza opcją dostępną w  aplikacji jest identyfikacja inteligentnych kontraktów. Identyfikacje kontraktu można rozpocząć będąc na stronie główniej lub na podstronie dedykowanej specjalnie identyfikacji kontraktów. Zarówno na stronie głównej, jak i na podstronie znajduje się pole w którym można wprowadzić kod bajtowy. Po wprowadzeniu danych użytkownik zatwierdza je w obu przypadkach klikając przycisk \textbf{Identify}. Natomiast, jeśli użytkownik chce udać się na podstronę, należy wybrać przycisk w menu o nazwie \textbf{Identify bytecode}, następnie użytkownik zostanie przekierowany na podstronę dedykowaną identyfikacji kontraktów. W przypadku wprowadzenia kodu bajtowego na stronie głównej zostaniemy również przekierowani na podstronę z taka różnica, ze pojawią się od razu wyniki identyfikacji kontraktu. Zarówno na stronie głównej, jak i podstronie dedykowanej identyfikacji, użytkownik jest zobowiązany wprowadzać kod bajtowy w szesnastkowym systemie liczbowym, w innym wypadku identyfikacja nie przejdzie prawidłowo.


Po wprowadzeniu danych i zatwierdzeniu ich przyciskiem \textbf{Identify}, aplikacja rozpoczyna proces analizy wprowadzonego kodu bajtowego oraz wyszukiwane są najbardziej prawdopodobne implementacje posortowane malejąco według współczynnika dopasowania. W rezultacie jak możemy zobaczyć na rysunku \ref{rys:wynik_identyfikacji} użytkownik otrzymuje listę dziesięciu najbardziej prawdopodobnych implementacji.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.55]{wynik_identyfikacji.png}
\caption{Wynik identyfikacji inteligentnego kontraktu}
\label{rys:wynik_identyfikacji}
\end{figure}

Mimo że domyślnie jest wyświetlanych tylko dziesięć najbardziej prawdopodobnych implementacji, istnieje też możliwość pobrania wszystkich wyników identyfikacji kontraktu używając przycisku \textbf{Get all}. Jak widać na rysunku \ref{rys:wynik_identyfikacji}, przycisk \textbf{Get all} znajduje się pod pierwszą dziesiątka wyników. Po naciśnięciu przycisku strona zostanie załadowana ponownie wraz z pełną listą haszy plików i ich współczynnikami dopasowania.


Po naciśnięciu w jedną z wyświetlanych implementacji, użytkownikowi pojawi się w nowej karcie przeglądarki podstrona umożliwiająca podgląd implementacji.


Jak widać na rysunku \ref{rys:podglad_impelementacji} kod źródłowy kontraktu jest wyświetlany ze specjalnie przygotowanym dla języka Solidity podświetleniem składni przygotowanym, natomiast po lewej stronie można zobaczyć przygotowaną numeracje wierszy, która ma za zadanie ułatwić nawigację po kodzie źródłowym na stronie internetowej. Rozwiązanie z numerowaniem linii zostało zaimplementowane w taki sposób, aby podczas kopiowania kodu źródłowego ze strony, nie były kopiowane z nim liczby identyfikujące konkretną linie w kodzie.



\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{podglad_impelementacji.png}
\caption{Podgląd implementacji}
\label{rys:podglad_impelementacji}
\end{figure}

\subsection{Dodanie kodu źródłowego kontraktu do aplikacji}
Kolejna funkcjonalnością dostępną dla użytkownika jest możliwość dodania własnego kodu źródłowego kontraktu napisanego w języku Solidity. Opcja ta umożliwia użytkownikowi uzupełnienie aktualnej bazy danych o kolejne kody źródłowe inteligentnych kontraktów. W rezultacie zgromadzenia dużej ilości implementacji w bazie danych, wszyscy pozostali użytkownicy maja większą szansę na precyzyjną identyfikacje kontraktu. W celu wykorzystania tej funkcjonalności użytkownik musi zalogować się za pomocą panelu logowania. Zakładając, że osoba korzystająca z tej części aplikacji posiada już odpowiednie uprawnienia to po naciśnięciu przycisku \textbf{Upload solidity}, zostanie przekierowana na podstronę, na której ma możliwość wprowadzenia kodu źródłowego. Zostały utworzone dwie możliwości wprowadzania kodów źródłowych, które opiszę poniżej. 


Pierwszą sposobem jest przesłanie do aplikacji pliku zawierającego implementacje kontraktu napisana w języku Solidity. W tym przypadku użytkownik powinien kliknąć przycisk \textbf{Browse}, który umożliwi mu wybranie za pomocą przeglądarki internetowej konkretnego pliku znajdującego się na dysku lokalnym, a następnie zatwierdzić go przyciskiem \textbf{Upload} znajdującym się obok wcześniej wspomnianego przycisku. 


Innym sposobem na przesłanie kodu źródłowego do aplikacji jest wklejenie kodu źródłowego bezpośrednio do formularza znajdującego się po prawej części strony internetowej. Ta opcja została utworzona w celu zapewnienia użytkownikowi większej elastyczności i komfortu w korzystaniu z aplikacji. Przykładowo podczas korzystania z aplikacji, użytkownik może bezpośrednio skopiować kod źródłowy, który jest w dowolnym innym źródle tekstowym np. innej stronie internetowej i wkleić go bezpośrednio do aplikacji bez konieczności tworzenia pliku tymczasowego.


Po prawidłowym dodaniu kodu źródłowego do aplikacji, użytkownik powinien zobaczyć podobny rezultat do tego na rysunku \ref{rys:ekran_pozuploadowaniu}. W momencie dodania nowej implementacji, na stronie pojawia się hasz dodanego pliku oraz lista sygnatur funkcji wraz z ich selektorami. 

Użytkownik ma możliwość przeglądania kodu źródłowego, który wysłał na serwer. W tym celu należy nacisnąć na hasz pliku wyświetlany poniżej formularza dodawania,  następnie użytkownik zostanie przeniesiony na stronę na której może zobaczyć dodany przez siebie kod źródłowy z numeracją linii oraz podświetleniem składni.

Na dolnej części rysunku \ref{rys:ekran_pozuploadowaniu} znajduje się tabela z funkcjami wyszukanymi w implementacji. W kolumnie \textbf{Signature} znajdują się wszystkie sygnatury funkcji, natomiast w kolumnie \textbf{Selector} odpowiadajace im selektory funkcji.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{ekran_pozuploadowaniu.png}
\caption{Rezultat przesłania inteligentnego kontraktu do aplikacji}
\label{rys:ekran_pozuploadowaniu}
\end{figure}


\subsection{Interfejs programistyczny aplikacji}
Trzecia funkcjonalnością aplikacji jest interfejs programistyczny. Umożliwia on tworzenie przez innych użytkowników własnego oprogramowania bazując na istniejącej aplikacji. Dzięki temu można wykorzystać mechanizmy zaimplementowane w aplikacji w celu rozszerzenia ich w innej aplikacji lub w celu zautomatyzowania niektórych procesów bez wykorzystania GUI (ang. graphical user interface) aplikacji.


W celu skorzystania z interfejsu programistycznego należy utworzyć żądanie HTTP. Za pomocą żądania użytkownik aplikacji ma możliwość dostarczenia na serwer nowego kodu źródłowego, pobrania istniejącego kodu źródłowego z bazy danych aplikacji oraz identyfikację kontraktu. Zarówno zadania jak i odpowiedzi są charakterystyczne dla protokołu HTTP.


Przykładowym zastosowaniem API (ang. Application programming interface) jest utworzenie skryptu umożliwiającego zautomatyzowane wysyłanie kodów źródłowych do aplikacji, bez konieczności korzystania z interfejsu graficznego aplikacji. W tym przypadku użytkownik, który chce przesłać nowy plik do aplikacji musi najpierw przejść proces autoryzacji, a następnie wykonać wybrane żądanie HTTP.


\subsubsection{Pobieranie informacji o kodzie źródłowym z API}

Aplikacja umożliwia pobranie kodu źródłowego wykorzystując interfejs programistyczny. Użytkownik API musi posiadać hasz pliku, który jest umieszczany w adresie żądania HTTP. Hasz pliku może otrzymać w odpowiedzi na identyfikacje kodu bajtowego lub po przesłaniu nowej implementacji na serwer. Przykładowe żądanie pobierające plik z API można zobaczyć na listingu \ref{lst:zadanieokodzrodlowy}. W odpowiedzi użytkownik dostaje zwykły tekst zawierający implementację kontraktu oraz status HTTP 200, 404 lub 500. Status 200 oznacza, że wszystko poszło pomyślnie. W sytuacji gdy, użytkownik otrzyma status 404, oznacza to, że nie udało się znaleźć implementacji o podanym haszu. Odpowiedz zawierajaca status 500 oznacza ze wystąpił błąd na serwerze i nie udało się zwrócić kodu źródłowego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Żądanie wysyłane w celu pobrania kodu źródłowego, label=lst:zadanieokodzrodlowy]
GET /api/sourceCode/0x06c61b8e505d7a407af9a91bdff8085560e90a133c77ab32bde32e686f6a8d52.sol HTTP/1.1
Host: localhost:8080
Accept: text/plain;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
\end{lstlisting}
\end{center}



\subsubsection{Identyfikacja inteligentnego kontraktu za pomocą API}

W celu identyfikacji kontraktu należy wyslać żadanie pod adres \mbox{/api/bytecode}. W ciele żądanie jest wymagane od użytkownika podanie dwóch atrybutów o nazwach: \textbf{bytecode} oraz \textbf{allFiles}. Wartości są zakodowane poprzez przypisanie do nazwy atrybutu wartość oraz połączenie wszystkich atrybutów za pomocą ampersandu. Poprawny przykład żądania można zobaczyć na listingu \ref{lst:identyfikacjaapi}.




\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Żądanie wysylane w celu identyfikacji kontraktu za pomocą API, label=lst:identyfikacjaapi]
POST /api/bytecode HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

bytecode=60803350200fe56abcede00229&allFiles=false

\end{lstlisting}
\end{center}

Na listingu \ref{lst:identyfikacjaapi} do atrybutu \textbf{bytecode} został wprowadzony kod bajtowy kontraktu. Do zmiennej \textbf{allFiles} została wprowadzona wartość \textbf{false}, wiec w rezultacie zostanie zwrócone dziesięć najbardziej prawdopodobnych implementacji, natomiast jeśli użytkownik chce zobaczyć jak wyglądają pozostałe dopasowania należy ustawić tą zmienną na \textbf{true}. W żądaniu został wprowadzony nagłówek \textbf{Content-Length}, określający długość przesyłanych danych, natomiast \textbf{Content-Type} oznacza rodzaj przesyłanych danych. 


Jeśli wszystko pójdzie pomyślnie użytkownik otrzyma status HTTP 200 oraz listę składająca się z haszu pliku oraz współczynnika dopasowania danego pliku w formacie JSON. W przypadku gdy nie zostanie dopasowana żadna implementacja to aplikacja zwróci status 404, natomiast jeśli w aplikacji wystąpi błąd to zostanie zwrócony status 500.


\subsubsection{Przesyłanie nowego kodu źródłowego za pomocą API}

Gdy użytkownik chce przesłać nowy kontrakt do aplikacji, musi przejść proces uwierzytelniania. W tym celu nalezy do żądania dodać nagłówek \textbf{Authorization}. Składnia nagłówka wygląda następująco:
\mbox{\textbf{Authorization: <type> <credentials>}}. W miejscu \textbf{type} należy podać Basic, a w miejscu \textbf{credentials} zakodowane za pomocą Base64 według schematu \textbf{login:haslo} dane do autoryzacji. Na przykładzie z listingu \ref{lst:dodaniedoapi} został przesłany kod źródłowy wykorzystując login: 123 oraz hasło: 123.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przesyłanie kodu źródłowego za pomocą API, label=lst:dodaniedoapi]
POST /api/solidityFiles HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Accept: application/json
Authorization: Basic MTIzOjEyMw==
Content-Length: 221
Accept: application/json

pragma solidity ^0.4.21;
contract Hello {
    string public message;
    function setMessage(string newMessage) public {
        message = newMessage;
    }
}

\end{lstlisting}
\end{center}



Po pomyślnym przesłaniu kontraktu, w odpowiedzi od serwera użytkownik powinien otrzymac status HTTP 200. Poza statusem, zostaje przesłany przez niego przesłany kod źródłowy, hasz stworzony na podstawie kodu źródłowego oraz listę znalezionych sygnatur funkcji wraz z ich selektorami. W przypadku wystąpienia błędu na serwerze zostaje zwrócony status 500. Na listingu \ref{lst:przykladodpowiedzijson} można zaobserwować przykładowe dane zawarte w odpowiedzi od serwera.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przykładowa odpowiedz w formacie JSON, label=lst:przykladodpowiedzijson]
{
    "sourceCodeHash": "0x8dea780e1286d12a957d40597b9171a5187f87f6e3f8303505bc53a4453ad5b6",
    "sourceCode": "pragma solidity ^0.4.21;\r\ncontract Hello {\r\n    string public message;\r\n    function setMessage(string newMessage) public {\r\n        message = newMessage;\r\n    }\r\n}",
    "solidityFunctions": [
        {
            "selector": "e21f37ce",
            "signature": "message()"
        },
        {
            "selector": "368b8772",
            "signature": "setMessage(string)"
        }
    ]
}
\end{lstlisting}
\end{center}


\section{Przedstawienie architektury}

W tym podrozdziale omówię architekturę aplikacji która realizuje opisane w sekcji 3.1 funkcjonalności. Na wstępie pokrótce opisze elementy systemu, a te bardziej złożone w swoim działaniu opiszę w podrozdziałach.


Jak widać na rysunku \ref{rys:architektura} pierwsza warstwa aplikacji składa się z kontrolerów, które obsługują połączenie, miedzy serwerem, a przeglądarką internetowa. Celem kontrolerów jest obsługa żądań HTTP i wywoływanie określonych akcji na pozostałej części systemu oraz wyświetlanie użytkownikowi wyników w postaci kodu HTML. Do tworzenia strony internetowej został wykorzystany moduł Spring Thymeleaf oraz Bootstrap 

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.8]{architektura.png}
\caption{Architektura aplikacji}
\label{rys:architektura}
\end{figure}

\textbf{Disassembler} - Jest to klasa odpowiedzialna analizę przekazanego kodu bajtowego. W rezultacie zwraca listę instrukcji zawartych w kodzie. Szczegółowe działanie tej klasy zostało opisane w dalszej części pracy, w sekcji 3.4 dotyczącej wyszukiwania selektorów funkcji w kodzie bajtowym. 


\textbf{Solidity Parser} - Odpowiada wyciągniecie z kodu źródłowego listy funkcji składających się z sygnatury oraz selektora. Sposób tworzenie selektorów funkcji oraz wyciągania z kodu źródłowego sygnatur funkcji został przedstawiony w sekcji 3.5


\textbf{Solidity Service} - jest to klasa odpowiedzialna za odczytywanie danych z bazy danych oraz za przygotowanie przesłanych danych przez użytkownika przed zapisem w bazie danych.


\textbf{Bytecode Service} - odpowiada za dopasowywanie kodu bajtowego do kontraktu. W tym celu wykorzystuje opisane wyżej klasy Disassembler oraz Solidity, które w połączeniu umożliwiają wyznaczenie współczynnika dopasowania pomiędzy konkretnym plikiem, a kodem bajtowym. Sposób dopasowywania oraz wyznaczania współczynnika dopasowania został opisany w sekcji 3.5 która znajduje się w dalszej części pracy.

\textbf{Database} - jest to cześć aplikacji odpowiedzialna za komunikację z bazą danych oraz mapowanie danych przechowywanych w bazie danych na obiekty Javowe. W tym fragmencie aplikacji interfejs role pośrednika miedzy serwisem, a realną bazą danych, pełni interfejs \mbox{SolidityFileRepository}, który wykorzystuje moduł \mbox{Spring Data MongoDB}. Rola implementacji tego interfejsu spoczywa na frameworku Spring. Sczegoly lączenia z bazą danych zostały opisane w sekcji 3.2.1



\section{Połączenie z bazą danych}
W celu integracji aplikacji z baza danych MongoDB został wykorzystany framework Spring oraz moduł Spring Data MongoDB. W związku z tym, że projekt aplikacji jest budowany za pomocż narzędzia Apache Maven, należy dodać do pliku \textbf{pom.xml} wykorzystywany moduł w projekcie. 

Na listingu \ref{lst:dodaniezaleznosci} został przedstawiony fragment pliku \textbf{pom.xml} odpowiedzialny za dodawanie modułu \mbox{\textbf{spring-boot-start-data-mongodb}} do projektu z wykorzystaniem Mavena. Dodawanie innych modułów jest analogiczne do przykładu z listingu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad dodania zależności w pliku pom.xml, label=lst:dodaniezaleznosci]
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>
\end{lstlisting}
\end{center}

W pliku konfiguracyjnym \mbox{\textbf{application.properties}}, który jest wykorzystywany przez framework \mbox{Spring}, należy skonfigurować dane do połączenia z bazą danych. Przykładowa zawartość pliku konfiguracyjnego została przedstawiona na listingu \ref{lst:applicationproperties}.
 
\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Kofiguracja bazy danych, label=lst:applicationproperties]
spring.data.mongodb.uri=mongodb://${ADMIN_DB_LOGIN}:${ADMIN_DB_PASSWORD}@ds129904.mlab.com:29904/${DATABASE_NAME_CONTRACT}
admin.login=${ADMIN_LOGIN}
admin.password=${ADMIN_PASSWORD}
\end{lstlisting}
\end{center}

Spring umożliwia wykorzystanie zmiennych środowiskowych w pliku konfiguracyjnym. Przykładem takiego zastosowania jest linia przedstawiona poniżej:
\begin{verbatim}
admin.login=${ADMIN_LOGIN}
\end{verbatim}
Dzięki temu można zabezpieczyć aplikacje przed wyciekiem wrażliwych danych takich jak loginy i hasła do bazy danych, podczas upubliczniania kodu źródłowego na przykład w repozytorium na GitHub.

Po skonfigurowaniu pliku \mbox{\textbf{pom.xml}} oraz \mbox{\textbf{application.properties}}, został utworzony interfejs \mbox{\textbf{SolidityFileRepository}}, który umożliwia serwisom aplikacji wykonywanie operacji na bazie danych oraz ustala mapowanie obiektów z bazy danych na obiekty klasy \mbox{\textbf{SolidityFile}}. Utworzone w aplikacji repozytorium można zobaczyć na listingu \ref{lst:repozytoriummongo}.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Stworzenie repozytorium za pomocą Spring Data MongoDB, label=lst:repozytoriummongo]
@Repository
interface SolidityFileRepository extends MongoRepository<SolidityFile, String> {

    @Query("{\"solidityFunctions\": {$elemMatch: {\"selector\": {$in: ?0}}}}")
    List<SolidityFile> findSolidityFilesBySelectorContainsAll(List<String> functionSelector);

    Optional<SolidityFile> findBySourceCodeHash(String sourceCodeHash);
}
\end{lstlisting}
\end{center}

W pierwszej linii listingu \ref{lst:repozytoriummongo} znajduje się adnotacja \mbox{\textbf{@Repository}} pełniąca role stereotypu oraz informująca Springa, że ten interfejs jest wykorzystywany, w celu wykonywania operacji z bazą danych.

Kolejna adnotacja jest \mbox{\textbf{@Query}}. Jej parametrem jest wykorzystywane zapytanie do bazy danych MongoDB, pytające o listę plików, w których znajdują się przekazane przez użytkownika selektory funkcji. W ten sposób można przypisać konkretnej metodzie z \mbox{\textbf{SolidityFileRepository}}, konkretne zapytanie, które ma wykonać.

Jeśli metoda w interfejsie nie posiada wspomnianej adnotacji, wtedy framework wygeneruje zapytanie do bazy danych, bazując na nazwie metody oraz przyjmowanych i zwracanych danych przez metodę.

W celu wykorzystania tego interfejsu konieczne było utworzenie klasy reprezentującej encję bazodanowa w aplikacji. Na listingu \ref{lst:przykladencji} została przedstawiona taka klasa \mbox{\textbf{SolidityFile}}. Składa się ona z trzech atrybutów, z haszu kodu źródłowego, kodu źródłowego, oraz listy funkcji znalezionych w tym kodzie źródłowym. Atrybut sourceCodeHash został utworzony ze względu na brak możliwości zapewnienia unikalności samego kodu źródłowego, którego rozmiar jest zbyt duży by przetwarzać w bazie danych. Tworzeniem haszu zajmuje się klasa \mbox{\textbf{SolidityService}} będąca na rysunku \ref{rys:architektura} w wyższej warstwie. Dodatkowo poza zapewnieniem unikalności, hasz jest identyfikatorem kodu źródłowego w bazie danych, w związku z tym posiada on adnotacje \mbox{\textbf{@Id}}, która informuje że atrybut ten jest identyfikatorem w bazie danych. W związku z tym ze hasz jest identyfikatorem, jest on też unikalny, a unikalny hasz daje unikalny kod źródłowy. Jeśli wartość pod adnotacja nie została wcześniej przypisana to moduł \mbox{\textbf{Spring Data MongoDB}} automatycznie wygeneruje identyfikator dla nowego obiektu i przypisze go do wskazanego przez adnotacje atrybutu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad klasy wykorzystywanej przez Spring Data MongoDb, label=lst:przykladencji]
public class SolidityFile {

    @Id
    private final String sourceCodeHash;
    private final String sourceCode;
    private final Set<SolidityFunction> solidityFunctions;

    SolidityFile(String sourceCodeHash, String sourceCode, Set<SolidityFunction> solidityFunctions) {
        requireNonNull(sourceCodeHash, "Expected not-null sourceCodeHash");
        requireNonNull(sourceCode, "Expected not-null sourceCode");
        requireNonNull(solidityFunctions, "Expected not-null solidityFunctions");
        this.sourceCodeHash = sourceCodeHash;
        this.sourceCode = sourceCode;
        this.solidityFunctions = solidityFunctions;
    }

    public String getSourceCodeHash() { return sourceCodeHash; }
    public String getSourceCode() { return sourceCode; }
    public Set<SolidityFunction> getSolidityFunctions() { return solidityFunctions; }

    @Override
    public String toString() {
        return "SolidityFile{" + "sourceCodeHash='" 
                 + sourceCodeHash
        	 + '\'' + ", sourceCode='" + sourceCode + '\'' 
        	 + ", solidityFunctions=" + solidityFunctions + '}';}

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SolidityFile)) return false;
        SolidityFile that = (SolidityFile) o;
        return Objects.equals(sourceCodeHash, that.sourceCodeHash) &&
                Objects.equals(sourceCode, that.sourceCode) &&
                Objects.equals(solidityFunctions, that.solidityFunctions);}

    @Override
    public int hashCode() {
        return Objects.hash(sourceCodeHash, sourceCode, solidityFunctions);}
}
\end{lstlisting}
\end{center}

Klasa ta została stworzona tak, aby uniknąć niechcianych modyfikacji pól obiektów tej klasy przez aplikację. Pola zostały ustawione na \textbf{final}, a wartości obiektu można przypisać tylko podczas jego inicjalizacji. W związku z tym, że plik solidity zawsze ma hasz, kod źródłowy oraz listę funkcji w momencie zapisywania do bazy danych, zostały w konstruktorze wykorzystane metody sprawdzające, czy przypadkiem użytkownik nie wprowadził wartości \textbf{null}. Jeśli zostanie wprowadzona w konstruktorze taka wartość, wtedy aplikacja zgłasza wyjątek i informuje, że dzieje się coś niedobrego. Dzięki temu aplikacja została zabezpieczona przed niechcianym i niekontrolowanym przekazywaniem \textbf{null}i w inne części systemu.

Kolejnym elementem tej klasy są akcesory, nadpisana metoda \textbf{toString} w taki sposób, który będzie zrozumiale przedstawiać stan obiektu oraz nadpisane metody \textbf{equals} i \textbf{hashCode}, które są wykorzystywane przez kolekcje, wykorzystywane w Javie, oraz inne klasy z nimi związane.

Ponieważ klasa \textbf{SolidityFunction} jest wykorzystywana w klasie \textbf{SolidityFile}, została ona zaimplementowana w analogiczny sposób z taką różnicą, że posiada ona atrybuty: \textbf{selector} oraz \textbf{signature} typu \textbf{String}. W dodatku w tej klasie nie została użyta adnotacja \mbox{\textbf{@Id}}, ponieważ nie jest ona używana jako niezależny obiekt w bazie danych, tylko jest zawsze częścią obiektu klasy \textbf{SolidityFile}.


\section{Identyfikacja sygnatur funkcji w kodzie źródłowym}


Wyszukiwanie sygnatur funkcji jest rozpoczynane w momencie przesłania nowego kodu źródłowego przez uzytkownika do aplikacji. Podczas wyszukiwania sygnatur funkcji są też generowane selektory funkcji, które są wykorzystywane podczas identyfikacji kodu bajtowego, który również posiada w sobie selektory funkcji. Dzięki temu cała aplikacja jest w stanie dopasować kod bajtowy do konkretnej implementacji. Problemem podczas wyszukiwania sygnatur w kodzie źródłowym jest to, że część sygnatur jest niejawna tzn. są one dodatkowo generowane przez kompilator \textbf{Ethereum Virtual Machine} dla publicznych atrybutów kontraktów. 


W przypadku API wykorzystywana jest klasa \textbf{SolidityApiController}, którą widać na rysunku \ref{rys:szukanie_funkcji}. Zadaniem tej klasy jest nasłuchiwanie adresów związanych z API, zwracanie danych w formacie JSON lub zwykłego tekstu oraz komunikowanie się z obiektem klasy \textbf{SolidityService}. 

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.9]{szukanie_funkcji.png}
\caption{Schemat zależności miedzy klasami podczas identyfikacji sygnatur funkcji}
\label{rys:szukanie_funkcji}
\end{figure}

Jeśli użytkownik korzysta ze zwykłej strony internetowej, wtedy przetwarzaniem żądań HTTP zajmuje się \textbf{SolidityController}. Klasa ta działa podobnie do poprzedniej, z taka różnica, że ten kontroler nasłuchuje inne adresy oraz zamiast zwracać dane w formacie JSON lub zwykłego tekstu, zajmuje się generowaniem kodu HTML, który jest wyświetlany u użytkownika.


\subsection{Kontroler interfejsu programistycznego}

Na listingu \ref{lst:kontrolerapiupload} została przedstawiona metoda kontrolera \textbf{SolidityApiController}. Adnotacje, które wykorzystuje ta metoda są częścią modułu \textbf{Spring MVC}. Pierwszą adnotacją wykorzystaną w metodzie jest \textbf{@PostMapping}, która zajmuje się mapowaniem żądań HTTP przesyłanych do API. W parametrze tej adnotacji podany został adres pod którym aplikacja oczekuje żądania. 

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda kontrolera mapująca żądania POST, label=lst:kontrolerapiupload]
@PostMapping("/api/solidityFiles")
public ResponseEntity<SolidityFile> uploadFile(@RequestBody String sourceCode) throws IOException {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    return ResponseEntity.ok(solidityService.save(sourceCode));
}
\end{lstlisting}
\end{center}

Kolejną wykorzystaną adnotacją jest \mbox{\textbf{@RequestBody}}. Adnotacja ta informuje framework, o tym żeby ciało żądania HTTP było umieszczona pod zmienną przy której jest adnotacja. 

Ostatnia rzeczą, która pochodzi z modułu \textbf{Spring MVC} jest klasa \textbf{ResponseEntity}. Umożliwia ona zwrócenie statusu HTTP z danymi zwracanymi przez metodę. Dzięki temu framework wie jaki status ma zwrócić użytkownikowi.

Głównym celem tej metody jest zapisanie za pomocą serwisu nowego kodu źródłowego do aplikacji, w związku z tym na listingu \ref{lst:kontrolerapiupload} widać wywołanie metody \textbf{save} na atrybucie \mbox{\textbf{solidityService}}. Implementacja wywoływanej metody została opisana w dalszej części podrozdziału.

Nad cała klasą \mbox{\textbf{SolidityApiController}} znajduje się adnotacja \textbf{@RestController}, ktora informuje Springa, że jest to kontroler wykorzystywany do tworzenia API Restowego. Dzięki tej adnotacji domyślnie kontroler będzie na przykład starał się zwrócić dane w formacie JSON.

\subsection{Kontroler strony internetowej}

\textbf{SolidityControler}, jest to kontroler odpowiedzialny za tworzenie strony internetowej  w postaci kodu HTML jest oznaczony adnotacja \textbf{@Controller}. Działa on podobnie jak wcześniej opisany kontroler. Główną różnica jest to ze w odpowiedzi zwraca kod HTML, który jest wyświetlany jako strona internetowa u użytkownika. Do generowania kodu HTML zostal wykorzystany moduł \textbf{Thymeleaf}. To w jaki sposób dodaje się nowe moduły do projektu zostało przedstawione na przykład na listingu \ref{lst:dodaniezaleznosci}

Listing \ref{lst:uploadowanie} przedstawia metodę przyjmująca w żądaniu HTTP kod źródłowy. Metoda ta działa podobnie jak w przypadki API, tylko w tym przypadku za pomocą \textbf{return} zwracana jest nazwa pliku zawierającego szablon HTML. Spring widząc, ze zwrócono taką nazwę przeszukuje katalog \textbf{resources}, znajdujący się w projekcie, w celu odnalezienia pasującego szablonu HTML. Istnieje możliwość przekazania danych do szablonu. W tym celu wykorzystywany jest parametr model, na którym wywoływana jest metoda \textbf{addAttribute}. Dane które są przekazywane za pomocą metody \textbf{addAtribute} pochodzą z obiektu klasy \textbf{SolidityFile}.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przechwytywanie żądania o dodanie nowego kodu źródłowego, label=lst:uploadowanie]
@PostMapping("/solidity/text")
public String handleSourceCodeUpload(@RequestParam("sourceCode") String sourceCode, Model model) throws Exception {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    requireNonNull(model, "Expected not-null model");

    SolidityFile savedSolidityFile = solidityService.save(sourceCode);

    model.addAttribute("solidityFileFunctions", savedSolidityFile.getSolidityFunctions());
    model.addAttribute("solidityFileHash", savedSolidityFile.getSourceCodeHash());
    return "solidity-page";
}
\end{lstlisting}
\end{center}

\subsection{Przetwarzanie kodu źródłowego}

Oba kontrolery korzystają z obiektu klasy \textbf{SolidityService}. Jak widać na rysunku \ref{rys:szukanie_funkcji}, klasa ta wykorzystuje: \textbf{SolidityParser} oraz opisaną już wcześniej, w sekcji 3.3, klasę \textbf{SolidityFileRepository}. 

Serwis po otrzymaniu kodu źródłowego od kontrolerów, przekazuje po jednej linii do parsera, który definiuje czy w danej linii jest sygnatura funkcji. Następnie jeśli znaleziono sygnaturę to zostaje ona zwracana wraz z jej selektorem. Po sparsowaniu w serwisie wszystkich linii kodu źródłowego, jest do bazy danych zapisywany obiekt klasy \textbf{SolidityFile}, który składa się z hasza, kod źródłowego oraz listy funkcji znajdujących się w kodzie źródłowym kontraktu.

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} można zaobserwować główną metodę wyszukującą funkcję. Metoda przyjmuje pojedyncza linie kodu źródłowego, a zwraca w rezultacie obiekt klasy generycznej \textbf{Optional<SolidityFunction>}. Metoda ta sprawdza cztery możliwe przypadku kiedy powinna wykryć funkcje w kodzie źródłowym.

W celu wykrywania błędów w wyrażeniach regularych lub metodach wyszukujących funkcji, sprawdzane jest czy w danej linii została wykryta tylko jedna funkcja. Jeśli okaże się, ze wykryto więcej niż jedna funkcje, oznacza to że któraś z tych metod fałszywie wykrywa. Co prawda obniża to wydajność aplikacji, ale w przypadku fałszywych wyników zastanie zwrócony wyjątek. Wszystkie cztery przypadki zostały opisane w dalszej części pracy.

\textbf{Optional} jest to klasa, która zabezpieczenia przed przekazywaniem referencji na wartość \textbf{null}. Dzięki temu że wartość \textbf{null} nie będzie przekazywana dalej, łatwiej jest zlokalizować miejsce usterki, ponieważ podczas pobierania obiektu z klasy \textbf{Optional}, jeśli jest ona pusta, zostaje wyrzucony wyjątek \textbf{NoSuchElementException}. Klasa \textbf{Optional} została wprowadzona w ósmej wersji Javy \cite{java8doc}.


\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnatury funkcji, label=lst:wyszukiwaniesygnaturyfunkcji]
    Optional<SolidityFunction> findFunctionInLine(String line) {
        List<Optional<SolidityFunction>> functions =
                Stream.of(
                        findFunctionSignature(line),
                        findMappingGetter(line),
                        findArrayGetter(line),
                        findNormalVariableGetter(line)
                ).filter(Optional::isPresent).collect(toList());

        if (functions.size() > 1) {
            throw new IllegalStateException("Expected only one function, but found :" + functions.size());
        } else if (functions.size() == 1) {
            return functions.listIterator().next();
        }
        return Optional.empty();
    }
\end{lstlisting}
\end{center}

\subsubsection{Wykrywanie sygnatury zadeklarowanej funkcji}

Pierwszym przypadkiem, są funkcje jawnie zadeklarowane w kodzie źródłowym nie posiadające modyfikatora \textbf{internal} lub \textbf{private}. W celu wykrycia takich funkcji wykorzystane zostało wyrażenie regularne zaprezentowane poniżej:
\begin{verbatim}
^\s*function\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*([^(){}]*)\s*\)\s*(?!.*(internal|private)).*$
\end{verbatim}

W wyrażeniu tym zostały wykorzystane dwie grupy. Pierwsza grupa wyciąga z linii kodu źródłowego nazwę funkcji, natomiast drugą sygnaturę funkcji. Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcjizfunkjci} widać metodę wyszukującą sygnaturę funkcji za pomocą przygotowanego wyrażenia regularnego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda odbierająca żądanie o zapisanie kodu źródłowego na serwerze, label=lst:wyszukiwaniesygnaturyfunkcjizfunkjci]
    private Optional<SolidityFunction> findFunctionSignature(String line) {
        Matcher matcher = FUNCTION_PATTERN.matcher(line);
        if (matcher.find()) {
            String functionName = matcher.group(FUNCTION_NAME_GROUP_ID);
            String functionArguments = matcher.group(FUNCTION_ARGUMENTS_GROUP_ID);
            String functionSignature = normalizeFunctionSignature(functionName, functionArguments);
            String functionSelector = getFunctionSelector(functionSignature);
            return Optional.of(new SolidityFunction(functionSelector, functionSignature));
        }
        return Optional.empty();
    }
\end{lstlisting}
\end{center}

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutów typu mapa}

TODO

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutu tablicowych}

TODO

\subsubsection{Wykrywanie sygnatury funkcji dla pozostałych publicznych atrybutów}
    
    TODO

\section{Wyszukiwanie selektorów funkcji w kodzie bajtowym}

Literatura: \cite{autor1, autor2}. TODO

\section{Dopasowywanie implementacji na podstawie kodu bajtowego}

Literatura: \cite{autor1, autor2}. TODO

\section{Wykorzystane technologie}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 




%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Bibliografia.
%____________________________________________________________________________________________
\phantomsection
\begin{thebibliography}{99}
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\addcontentsline{toc}{chapter}{Bibliografia}		% Dodanie do spisu treści.

\bibitem{rfc2616} Network Working Group \url{https://www.ietf.org/rfc/rfc2616.txt}.
\bibitem{java8doc} Oracle \url{https://docs.oracle.com/javase/8/docs/}.
\bibitem{autor1} Bibliografia 2. \emph{Nazwa}. 

\end{thebibliography}

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage					
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis tabel.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.	
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}		% Dodanie do spisu treści.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis rysunków.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________%____________________________________________________________________________________________
% Spis listingów. 
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\lstlistoflistings
\addcontentsline{toc}{chapter}{Spis listingów} 
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

\end{document}
