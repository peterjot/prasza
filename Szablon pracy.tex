% 1. Należy w programie ustawić zgodne kodowanie, w tym przypadku jest UTF-8. 
% 2. Kompilować ten plik za pomocą pdfLatex.


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Ustawienia pracy.
%____________________________________________________________________________________________

% Obowiązkowo! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definiowanie stylu i formatu pracy.
\documentclass[a4paper,twoside,12pt]{book}	% twoside - dwustronnie		 
\usepackage{polski}		 		% ustawienie języka
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[utf8]{inputenc}	
\usepackage{latexsym}
\usepackage{indentfirst} 				% wcięcia akapitu
\linespread{1.5}					% odstęp między liniami
\usepackage{geometry}
\geometry{lmargin=3.5cm, rmargin=3cm}	% ustawienie marginesów, lewy większy na oprawę

\usepackage{url}
\usepackage{enumerate}				% numeracja
\usepackage{amsopn}
\usepackage{graphicx} 				% grafika
\usepackage{epstopdf}				% grafika formatu eps
\usepackage{tabularx} 				% tabele
\usepackage{hyperref} 				% łącza
\usepackage{picture} 				% rysunki
\usepackage{upgreek}				% greckie symbole

\usepackage{listings}				% listingi
\usepackage{color}					% kolory


 % Polecenie usunięcia paginy na pustej stronie.
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} 	


% Zmiana nazwy rozdziału z listingami, domyślnie jest Listings.
\renewcommand{\lstlistlistingname}{Spis listingów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec



% Dodatkowo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definicje własnych otoczeń.
\theoremstyle{definition}
\newtheorem{dfn}{Definicja}[chapter]
\newtheorem{prz}[dfn]{Przykład}

\theoremstyle{remark}
\newtheorem{wsk}[dfn]{Wniosek}
% koniec


% Definiowanie własnego stylu listingu.
\lstset{
  frame             	= lines,
  basicstyle        	= \linespread{1}\ttfamily,%\small\footnotesize,
  columns           	= fullflexible,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
  breaklines=true,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec	 



\begin{document}

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Strona tytułowa.
%____________________________________________________________________________________________

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother 
% Tutaj wszystko należny wypełnić w nawiasach {}, nic więcej nie zmieniać!

\author{\textbf{Piotr Jasina}}        	% Podaj imię i nazwisko.
\title{Identyfikacja inteligentnych kontraktów w sieci Ethereum}      % Podaj tytuł polski.
\date{{\textbf{Lublin rok \the\year}}}	% Nic nie zmieniaj, rok wygeneruje automatycznie.
\def\engtitle{Ethereum smart contracts identification} % Podaj tytuł angielski.

\def\kierunek{Informatyka}		% Podaj kierunek studiów.
\def\specjalnosc{.....}			% Podaj specjalność, jeśli istnieje.
\def\nralbumu{279183}			% Podaj nr albumu.

\def\rodzaj{licencjacka}			% Podaj rodzaj pracy.
\def\zaklad{Zakładzie Cyberbezpieczeństwa}	% Podaj nazwę zakładu Twojego promotora.
\def\promotor{dr. Damiana Rusinka}	% Podaj promotora.

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Poniżej w {titlepage} nic nie zmieniać.

\renewcommand{\maketitle}{
\begin{titlepage}
\begin{table}
\begin{tabular}{c@{\hspace{10mm}}|@{\hspace{3mm}}l}
\multicolumn{2}{@{\hspace{15mm}}l}{\vspace{-31mm}} \\
\multicolumn{2}{l}{\hspace{-20mm}\includegraphics[scale=0.4]{UMCS}} \\ 
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{7mm}} \\

\multicolumn{2}{@{\hspace{16mm}}l}{\Large UNIWERSYTET MARII CURIE-SKŁODOWSKIEJ} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large W LUBLINIE} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large Wydział Matematyki, Fizyki i Informatyki} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{16mm}} \\

& \multicolumn{1}{m{13cm}}{Kierunek: \kierunek} \\
% Jeśli nie ma specjalności, to należy zakomentować poniższą linijkę!
% & \multicolumn{1}{m{13cm}}{Specjalność: \specjalnosc} \\
& \\
& \multicolumn{1}{m{13cm}}{\@author} \\
& \multicolumn{1}{m{13cm}}{nr albumu: \nralbumu} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{\Large\textbf{\@title}} \\
& \\
& \multicolumn{1}{m{13cm}}{\engtitle} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{Praca \rodzaj} \\	
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{napisana w \zaklad} \\
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{pod kierunkiem \promotor} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\vspace{7mm}} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\@date}
\end{tabular}
\end{table}
\end{titlepage}
}
% koniec 

% Tworzenie strony tytułowej.
\maketitle
% Wyczyszczenie z numeracji strony za stroną tytułową. 
\clearemptydoublepage


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis treści. 
%____________________________________________________________________________________________
\tableofcontents 		
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 	
\clearemptydoublepage			


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Wstęp pracy.
%____________________________________________________________________________________________
\chapter*{Wstęp}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Wstęp} 	% bez numeru w spisie treści

...
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 1.
%____________________________________________________________________________________________
\chapter[Ethereum]{Ethereum}
% W nawiasach [] zapisujemy skróconą nazwę rozdziału, pojawiający się w paginie górnej oraz w spisie treści.
% W nawiasach {} zapisujemy pełną nazwę rozdziału.
% '\protect \\' służy do dzielenia długiej nazwy rozdziału.

\section{Historia}

Literatura: \cite{autor1, autor2}. TODO


\section{Opis platformy}

Literatura: \cite{autor1, autor2}. TODO

\section{Ethereum Virtual Machine}

Literatura: \cite{autor1, autor2}. TODO

\section{Inteligentne kontrakty}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 2.
%____________________________________________________________________________________________
\chapter[Solidity]{Solidity}

\section{Sygnatura funkcji}

Literatura: \cite{autor1, autor2}. TODO


\section{Selektor funkcji}

Literatura: \cite{autor1, autor2}. TODO

\section{Generowanie akcesorów podczas kompilacji}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 3.
%____________________________________________________________________________________________
\chapter[Projekt Aplikacji]{Projekt Aplikacji}
Celem mojej pracy licencjackiej było stworzenie aplikacji internetowej umożliwiającej identyfikację  inteligentnych kontraktów w sieci \textbf{Ethereum}. Dzięki aplikacji użytkownik po wprowadzeniu na stronie kodu bajtowego kontraktu jest w stanie otrzymać najbardziej prawdopodobną implementacje kontraktu napisana w języku \textbf{Solidity}.

Aplikacja została stworzona przy wykorzystaniu frameworka \textbf{Spring Boot}, modułu \textbf{Spring Data MongoDB} oraz \textbf{Spring MVC}. Natomiast w celu przechowywania danych wykorzystano nierelacyjną bazę danych \textbf{MongoDB}.

W tym rozdziale znajduje się opis funkcjonalności, architektury, implementacji oraz wykorzystanych technologi.
\section{Opis funkcjonalności}


Na stronie głównej aplikacji znajduje się opis wraz z aktualna liczba kodów źródłowych znajdujących się w bazie danych oraz podstawowe definicje związane z aplikacją. Cała aplikacji udostępnia trzy główne funkcjonalności: identyfikację inteligentnych kontraktu, wprowadzanie plików źródłowych kontraktów do aplikacji oraz interfejs programistyczny aplikacji. Wszystkie funkcjonalności zostały opisane poniżej.

\subsection{Identyfikacja inteligentnych kontraktów}
Pierwszą opcją dostępną w  aplikacji jest identyfikacja inteligentnych kontraktów. Zarówno na stronie głównej jak i podstronie znajduje się pole, w którym można wprowadzić kod bajtowy. Po wprowadzeniu danych użytkownik zatwierdza je w obu przypadkach klikając przycisk \textbf{Identify}. Przycisk \textbf{Identify bytecode}, służy do przejścia na podstronę związaną z identyfikacją kontraktu.

Po wprowadzeniu danych i zatwierdzeniu ich przyciskiem \textbf{Identify}, aplikacja rozpoczyna proces analizy wprowadzonego kodu bajtowego oraz wyszukiwane są najbardziej prawdopodobne implementacje kontraktu, posortowane malejąco według współczynnika dopasowania. Na rysunku \ref{rys:wynik_identyfikacji} został przedstawiony przykładowy wynik identyfikacji.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.55]{wynik_identyfikacji.png}
\caption{Wynik identyfikacji inteligentnego kontraktu}
\label{rys:wynik_identyfikacji}
\end{figure}

Domyślnie jest wyświetlanych dziesięć najbardziej prawdopodobnych implementacji, po naciśnięciu przycisku \textbf{Get all}, znajdującego się pod lista kontraktów, zostaną wyświetlone wszystkie dopasowania.


Po naciśnięciu w jedną z wyświetlanych implementacji, użytkownik zostanie przeniesiony na podstronę umożliwiającą podgląd implementacji. Na rysunku \ref{rys:podglad_impelementacji} znajduje się przykład przeglądania kodu źródłowego na stronie. Rozwiązanie z numerowaniem linii zostało zaimplementowane w taki sposób, aby podczas kopiowania kodu źródłowego ze strony, nie były kopiowane z nim liczby identyfikujące konkretną linie w kodzie. Istnieje tez możliwość pobrania kodu źródłowego ze strony z rozszerzeniem \textbf{.sol}


\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{podglad_impelementacji.png}
\caption{Podgląd implementacji}
\label{rys:podglad_impelementacji}
\end{figure}

\subsection{Dodanie kodu źródłowego kontraktu do aplikacji}
Strona umożliwia dodanie własnego kodu źródłowego kontraktu napisanego w języku \textbf{Solidity}. W tym celu należy zalogować się za pomocą panelu logowania, który zostaje wyświetlony automatycznie przy probie korzystania z autoryzowanych funkcjonalności aplikacji. Po kliknięciu w \textbf{Identify Solidity} oraz zalogowaniu się na stronie, pojawiają się dwie możliwości wprowadzania kodów źródłowych.


Pierwszą sposobem jest przesłanie do aplikacji pliku zawierającego implementacje kontraktu. W tym celu użytkownik powinien nacisnąć przycisk \textbf{Browse} i wybrać konkretny plik, a następnie zatwierdzić go przyciskiem \textbf{Upload} widocznym na rysunku \ref{rys:ekran_pozuploadowaniu}. 


Innym sposobem na przesłania kodu źródłowego do aplikacji jest wklejenie kodu źródłowego bezpośrednio do formularza znajdującego się po prawej części strony internetowej.


Po prawidłowym dodaniu kodu źródłowego do aplikacji, użytkownik powinien zobaczyć podobny rezultat do tego na rysunku \ref{rys:ekran_pozuploadowaniu}. W momencie dodania nowej implementacji, na stronie pojawia się hasz dodanego pliku oraz lista sygnatur funkcji wraz z ich selektorami. Po naciśnięciu na wyświetlany na rysunku \ref{rys:ekran_pozuploadowaniu} hasz pliku, użytkownikowi wyświetli się przesłany kod źródłowy.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{ekran_pozuploadowaniu.png}
\caption{Rezultat przesłania inteligentnego kontraktu do aplikacji}
\label{rys:ekran_pozuploadowaniu}
\end{figure}


\subsection{Interfejs programistyczny aplikacji}
Trzecia funkcjonalnością aplikacji jest interfejs programistyczny. Dzięki niemu można wykorzystać mechanizmy zaimplementowane w aplikacji w innej aplikacji. Przykładowym zastosowaniem API (ang. Application programming interface) jest utworzenie skryptu umożliwiającego zautomatyzowane wysyłanie kodów źródłowych do aplikacji, bez konieczności korzystania z interfejsu graficznego aplikacji.

Użytkownik za pomocą API ma możliwość pobrania informacji o kodzie źródłowym, identyfikacji kontraktu oraz przesłania nowego kontraktu do aplikacji.


\subsubsection{Pobieranie informacji o kodzie źródłowym z API}

Podczas pobierania informacji o kodzie źródłowym, użytkownik musi posiadać identyfikator pliku, który chce pobrać. Żądanie pobierające plik z API można zobaczyć na listingu \ref{lst:zadanieokodzrodlowy}. W odpowiedzi użytkownik dostaje zwykły tekst zawierający implementację kontraktu oraz status HTTP 200, 404 lub 500. Status 200 oznacza, że wszystko poszło pomyślnie. W sytuacji gdy, użytkownik otrzyma status 404, oznacza to, że nie udało się znaleźć implementacji o podanym haszu. Odpowiedz zawierająca status 500 oznacza, że wystąpił błąd na serwerze i nie udało się zwrócić kodu źródłowego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Żądanie wysyłane w celu pobrania kodu źródłowego, label=lst:zadanieokodzrodlowy]
GET /api/sourceCode/0x06c61b8e505d7a407af9a91bdff8085560e90a133c77ab32bde32e686f6a8d52.sol HTTP/1.1
Host: localhost:8080
Accept: text/plain;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
\end{lstlisting}
\end{center}



\subsubsection{Identyfikacja inteligentnego kontraktu za pomocą API}
W celu identyfikacji kontraktu należy wysłać żądanie pod adres \mbox{/api/bytecode}. W ciele żądania jest wymagane od użytkownika podanie dwóch atrybutów o nazwach: \textbf{bytecode} oraz \textbf{allFiles}. Atrybuty przesyłane do API powinny być zakodowane według schematu \mbox{\textbf{nazwa\_atrybutu=wartosc}}, a wszystkie tak przygotowane atrybuty należy połączyć ze sobą pomocą ampersandu. Poprawny przykład żądania można zobaczyć na listingu \ref{lst:identyfikacjaapi}.




\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Żądanie wysylane w celu identyfikacji kontraktu za pomocą API, label=lst:identyfikacjaapi]
POST /api/bytecode HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

bytecode=60803350200fe56abcede00229&allFiles=false

\end{lstlisting}
\end{center}

Na listingu \ref{lst:identyfikacjaapi} do atrybutu \textbf{bytecode} został wprowadzony kod bajtowy kontraktu. Do zmiennej \textbf{allFiles} została wprowadzona wartość \textbf{false}, wiec w rezultacie zostanie zwrócone przez aplikację dziesięć najbardziej prawdopodobnych implementacji. Jeśli użytkownik chce pobrać wszystkie możliwe dopasowania, należy ustawić tą zmienną na \textbf{true}. W żądaniu został wprowadzony nagłówek \textbf{Content-Length} określający długość przesyłanych danych oraz \textbf{Content-Type} oznaczający rodzaj przesyłanych danych. 


Jeśli wszystko poszło pomyślnie użytkownik otrzyma status HTTP 200 oraz listę składającą się z haszu pliku oraz współczynnika dopasowania danego pliku w formacie \textbf{JSON}. W przypadku gdy nie zostanie dopasowana żadna implementacja, to aplikacja zwróci status 404, natomiast jeśli w aplikacji wystąpi błąd to zostanie zwrócony status 500.


\subsubsection{Przesyłanie nowego kodu źródłowego za pomocą API}

Gdy użytkownik chce przesłać nowy kontrakt do aplikacji, musi przejść proces uwierzytelniania. W tym celu należy do żądania dodać nagłówek \textbf{Authorization}. W nagłówku należy podać typ autoryzacji oraz zakodowane dane logowania za pomocą \textbf{Base64} według schematu \textbf{login:haslo}. Na przykładzie z listingu \ref{lst:dodaniedoapi} został przesłany kod źródłowy, a do autoryzacji wykorzystano login: 123 oraz hasło: 123.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przesyłanie kodu źródłowego za pomocą API, label=lst:dodaniedoapi]
POST /api/solidityFiles HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Accept: application/json
Authorization: Basic MTIzOjEyMw==
Content-Length: 221
Accept: application/json

pragma solidity ^0.4.21;
contract Hello {
    string public message;
    function setMessage(string newMessage) public {
        message = newMessage;
    }
}

\end{lstlisting}
\end{center}



Po pomyślnym przesłaniu kontraktu w odpowiedzi od serwera użytkownik otrzymuje status HTTP 200. W odpowiedzi zostaje również przesłany kod źródłowy, hasz stworzony na podstawie kodu źródłowego oraz listę znalezionych sygnatur funkcji wraz z ich selektorami. W przypadku wystąpienia błędu na serwerze zostaje zwrócony status 500. Na listingu \ref{lst:przykladodpowiedzijson} można zaobserwować przykładowe dane zawarte w odpowiedzi od serwera.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przykładowa odpowiedz w formacie JSON, label=lst:przykladodpowiedzijson]
{
    "sourceCodeHash": "0x8dea780e1286d12a957d40597b9171a5187f87f6e3f8303505bc53a4453ad5b6",
    "sourceCode": "pragma solidity ^0.4.21;\r\ncontract Hello {\r\n    string public message;\r\n    function setMessage(string newMessage) public {\r\n        message = newMessage;\r\n    }\r\n}",
    "solidityFunctions": [
        {
            "selector": "e21f37ce",
            "signature": "message()"
        },
        {
            "selector": "368b8772",
            "signature": "setMessage(string)"
        }
    ]
}
\end{lstlisting}
\end{center}


\section{Przedstawienie architektury}

W tym podrozdziale omówię architekturę aplikacji, która realizuje funkcjonalności opisane w sekcji 3.1. Poniżej zostały krótko opisane główne klasy będące częścią aplikacji, widoczne na rysunku \ref{rys:architektura}.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.7]{architektura.png}
\caption{Architektura aplikacji}
\label{rys:architektura}
\end{figure}

\begin{description}
\item[LoginController] jest to klasa wyświetlająca ekran logowania

\item[ErrorController] jej zadaniem jest przechwytywane wszystkich błędy w aplikacji. Po złapaniu błędu, użytkownikowi zostaje wyświetlona strona informująca, że pojawił się błąd w aplikacji, dodatkowo wszystkie błędy zostają logowane.

\item[BytecodeController] służy do wyświetlania użytkownikowi strony związanej z identyfikacją kodu bajtowego oraz do mapowania żądań HTTP służących do identyfikacji. 

\item[SolidityController] mapuje żądania HTTP związane z przetwarzaniem plików Solidity.

\item[Disassembler] odpowiada za analizę przekazanego kodu bajtowego. W rezultacie zwraca listę instrukcji zawartych w kodzie. Szczegółowe działanie tej klasy zostało opisane w dalszej części pracy, w sekcji 3.5 dotyczącej wyszukiwania selektorów funkcji w kodzie bajtowym. 

\item[SolidityParser] wyciąga z kodu źródłowego listy funkcji, składających się z sygnatury oraz selektora. Sposób tworzenie selektorów funkcji oraz wyciągania z kodu źródłowego sygnatur funkcji został przedstawiony w sekcji 3.4

\item[SolidityService] jest to klasa odpowiedzialna za odczytywanie danych z bazy danych oraz za przygotowanie przesłanych danych przed zapisem w bazie danych.

\item[BytecodeService] odpowiada za dopasowywanie kodu bajtowego do kontraktu. W tym celu serwis wykorzystuje opisane wyżej klasy \textbf{Disassembler} oraz \textbf{Solidity}, które w połączeniu umożliwiają wyznaczenie współczynnika dopasowania pomiędzy konkretnym plikiem, a kodem bajtowym. Szczegółowo zostało to opisane w sekcji 3.5, która znajduje się w dalszej części pracy.

\item[SolidityFileRepository] jest to część aplikacji odpowiedzialna za komunikację z bazą danych oraz mapowanie danych przechowywanych w bazie danych na obiekty. Repozytorium jest interfejsem, który wykorzystuje moduł \mbox{\textbf{Spring Data MongoDB}}. Implementacja tego interfejsu spoczywa na frameworku Spring. Sczegóły łączenia z bazą danych zostały opisane w sekcji 3.3

\end{description}


\section{Połączenie z bazą danych}
W celu integracji aplikacji z baza danych \textbf{MongoDB} został wykorzystany framework \textbf{Spring} oraz moduł \textbf{Spring Data MongoDB}. W związku z tym, że projekt aplikacji jest budowany za pomocą narzędzia \textbf{Apache Maven}, należy dodać do pliku \textbf{pom.xml} wykorzystywane moduły. 

Na listingu \ref{lst:dodaniezaleznosci} został przedstawiony fragment pliku \textbf{pom.xml} odpowiedzialny za dodawanie modułu \mbox{\textbf{spring-boot-start-data-mongodb}} do projektu. Dodawanie innych modułów jest analogiczne do przykładu z listingu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad dodania zależności w pliku pom.xml, label=lst:dodaniezaleznosci]
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>
\end{lstlisting}
\end{center}

W pliku konfiguracyjnym \mbox{\textbf{application.properties}}, który jest wykorzystywany przez framework, należy skonfigurować dane do połączenia z bazą danych. Przykładowa zawartość pliku konfiguracyjnego została przedstawiona na listingu \ref{lst:applicationproperties}.
 
\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Kofiguracja bazy danych, label=lst:applicationproperties]
spring.data.mongodb.uri=mongodb://${ADMIN_DB_LOGIN}:${ADMIN_DB_PASSWORD}@ds129904.mlab.com:29904/${DATABASE_NAME_CONTRACT}
admin.login=${ADMIN_LOGIN}
admin.password=${ADMIN_PASSWORD}
\end{lstlisting}
\end{center}

Spring umożliwia wykorzystanie zmiennych środowiskowych w pliku konfiguracyjnym. Przykładem takiego zastosowania jest linia przedstawiona poniżej:
\begin{verbatim}
admin.login=${ADMIN_LOGIN}
\end{verbatim}
Zmienna środowiskowa została podana w nawiasach klamrowych. Dzięki temu można zabezpieczyć aplikację przed wyciekiem wrażliwych danych, takich jak loginy i hasła do bazy danych, podczas upubliczniania kodu źródłowego na przykład w repozytorium na \textbf{GitHub}.

Po skonfigurowaniu pliku \mbox{\textbf{pom.xml}} oraz \mbox{\textbf{application.properties}}, został utworzony interfejs \mbox{\textbf{SolidityFileRepository}}, który umożliwia serwisom aplikacji wykonywanie operacji na bazie danych oraz ustala mapowanie obiektów z bazy danych na obiekty klasy \mbox{\textbf{SolidityFile}}. Utworzone w aplikacji repozytorium można zobaczyć na listingu \ref{lst:repozytoriummongo}.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Stworzenie repozytorium za pomocą Spring Data MongoDB, label=lst:repozytoriummongo]
@Repository
interface SolidityFileRepository extends MongoRepository<SolidityFile, String> {

    @Query("{\"solidityFunctions\": {$elemMatch: {\"selector\": {$in: ?0}}}}")
    List<SolidityFile> findSolidityFilesBySelectorContainsAll(List<String> functionSelector);

    Optional<SolidityFile> findBySourceCodeHash(String sourceCodeHash);
}
\end{lstlisting}
\end{center}

W pierwszej linii listingu \ref{lst:repozytoriummongo} znajduje się adnotacja \mbox{\textbf{@Repository}} pełniąca role stereotypu oraz informująca Springa, że ten interfejs jest wykorzystywany, w celu wykonywania operacji z bazą danych.

Kolejna adnotacja jest \mbox{\textbf{@Query}}. Jej parametrem jest zapytanie do bazy danych \textbf{MongoDB}, pytające o listę plików, które posiadają w sobie część przekazanych przez użytkownika selektorów funkcji. Za pomocą tej adnotacji można przypisać konkretnej metodzie z \mbox{\textbf{SolidityFileRepository}} konkretne zapytanie, które ma wykonać.

Jeśli metoda w interfejsie nie posiada wspomnianej adnotacji, wtedy framework wygeneruje zapytanie do bazy danych, bazując na nazwie metody oraz przyjmowanych i zwracanych przez metodę typach danych.

W celu wykorzystania tego interfejsu konieczne było utworzenie klasy reprezentującej encję bazodanową w aplikacji. Na listingu \ref{lst:przykladencji} została przedstawiona taka klasa \mbox{\textbf{SolidityFile}}. Składa się ona z trzech atrybutów: haszu kodu źródłowego, kodu źródłowego, oraz listy funkcji znalezionych w tym kodzie źródłowym. Atrybut \textbf{sourceCodeHash} został utworzony w celu zapewnienia unikalności samego źródłowego, którego rozmiar jest zbyt duży, by nadać mu indeks bazodanowy. Tworzeniem haszu zajmuje się klasa \mbox{\textbf{SolidityService}} znajdująca się na rysunku \ref{rys:architektura} w wyższej warstwie. Dodatkowo poza zapewnieniem unikalności, hasz jest identyfikatorem kodu źródłowego w bazie danych, w związku z tym posiada on adnotację \mbox{\textbf{@Id}}. Atrybut ten jest odpowiednikiem identyfikatora w bazie danych. W związku z tym, że hasz jest identyfikatorem, gwarantuje on unikalność kodu źródłowego w bazie danych. Jeśli wartość pod adnotacją nie została wcześniej przypisana to moduł \mbox{\textbf{Spring Data MongoDB}} automatycznie wygeneruje identyfikator dla nowego obiektu i przypisze go do wskazanego przez adnotacje atrybutu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad klasy wykorzystywanej przez Spring Data MongoDb, label=lst:przykladencji]
public class SolidityFile {

    @Id
    private final String sourceCodeHash;
    private final String sourceCode;
    private final Set<SolidityFunction> solidityFunctions;

    SolidityFile(String sourceCodeHash, String sourceCode, Set<SolidityFunction> solidityFunctions) {
        requireNonNull(sourceCodeHash, "Expected not-null sourceCodeHash");
        requireNonNull(sourceCode, "Expected not-null sourceCode");
        requireNonNull(solidityFunctions, "Expected not-null solidityFunctions");
        this.sourceCodeHash = sourceCodeHash;
        this.sourceCode = sourceCode;
        this.solidityFunctions = solidityFunctions;
    }

    public String getSourceCodeHash() { return sourceCodeHash; }
    public String getSourceCode() { return sourceCode; }
    public Set<SolidityFunction> getSolidityFunctions() { return solidityFunctions; }

    @Override
    public String toString() {
        return "SolidityFile{" + "sourceCodeHash='" 
                 + sourceCodeHash
        	 + '\'' + ", sourceCode='" + sourceCode + '\'' 
        	 + ", solidityFunctions=" + solidityFunctions + '}';}

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SolidityFile)) return false;
        SolidityFile that = (SolidityFile) o;
        return Objects.equals(sourceCodeHash, that.sourceCodeHash) &&
                Objects.equals(sourceCode, that.sourceCode) &&
                Objects.equals(solidityFunctions, that.solidityFunctions);}

    @Override
    public int hashCode() {
        return Objects.hash(sourceCodeHash, sourceCode, solidityFunctions);}
}
\end{lstlisting}
\end{center}

Klasa ta została stworzona tak, aby uniknąć niechcianych modyfikacji pól obiektów tej klasy przez aplikację. Pola zostały ustawione na \textbf{final}, a wartości obiektu można przypisać tylko podczas jego inicjalizacji. W momencie tworzenia obiektu klasy \textbf{SolidityFile}, zostają wywoływane w konstruktorze metody sprawdzające, czy użytkownik nie wprowadził wartości \textbf{null}. Jeśli zostanie wprowadzona w konstruktorze taka wartość, wtedy aplikacja zgłasza wyjątek i informuje, że dzieje się coś niedobrego. Dzięki temu aplikacja została zabezpieczona przed niechcianym i niekontrolowanym przekazywaniem \textbf{null}i do innych części systemu.

Kolejnym elementem tej klasy są akcesory, nadpisana metoda \textbf{toString} w taki sposób, który będzie przedstawiać stan obiektu oraz nadpisane metody \textbf{equals} i \textbf{hashCode}, które są wykorzystywane przez kolekcje używane w Javie, oraz inne klasy z nimi związane.

Ponieważ klasa \textbf{SolidityFunction} jest wykorzystywana w klasie \textbf{SolidityFile}, została ona zaimplementowana w analogiczny sposób z taką różnicą, że posiada atrybuty: \textbf{selector} oraz \textbf{signature} typu \textbf{String}. W dodatku w tej klasie nie została użyta adnotacja \mbox{\textbf{@Id}}, ponieważ klasa nie jest wykorzystywana niezależnie w bazie danych.


\section{Identyfikacja sygnatur funkcji w kodzie źródłowym}


Wyszukiwanie sygnatur funkcji jest rozpoczynane w momencie przesłania nowego kodu źródłowego przez użytkownika do aplikacji. Podczas wyszukiwania sygnatur funkcji są też generowane selektory funkcji, które są wykorzystywane podczas identyfikacji kodu bajtowego. Problemem podczas wyszukiwania sygnatur w kodzie źródłowym jest to, że część sygnatur jest niejawna tzn. są one dodatkowo generowane przez kompilator \textbf{Ethereum Virtual Machine} dla publicznych atrybutów kontraktów. 


W przypadku API wykorzystywana jest klasa \textbf{SolidityApiController}, którą widać na rysunku \ref{rys:szukanie_funkcji}. Zadaniem tej klasy jest nasłuchiwanie adresów związanych z API, zwracanie danych w formacie \textbf{JSON} lub zwykłego tekstu oraz komunikowanie się z obiektem klasy \textbf{SolidityService}. 

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.9]{szukanie_funkcji.png}
\caption{Schemat zależności miedzy klasami podczas identyfikacji sygnatur funkcji}
\label{rys:szukanie_funkcji}
\end{figure}

Jeśli użytkownik korzysta ze zwykłej strony internetowej, wtedy przetwarzaniem żądań HTTP zajmuje się \textbf{SolidityController}. Klasa ta działa podobnie do poprzedniej, z taka różnica, że ten kontroler nasłuchuje inne adresy oraz zwraca dane w postaci kodu \textbf{HTML}, zamiast w formacie \textbf{JSON} lub zwykłego tekstu.


\subsection{Kontroler interfejsu programistycznego}

Na listingu \ref{lst:kontrolerapiupload} została przedstawiona metoda kontrolera \textbf{SolidityApiController} umożliwiająca przesyłanie kodu źródłowego. Adnotacje, które wykorzystuje ta metoda są częścią modułu \textbf{Spring MVC}. Pierwszą adnotacją wykorzystaną w metodzie jest \textbf{@PostMapping}, która zajmuje się mapowaniem żądań HTTP przesyłanych do API. W parametrze tej adnotacji podany został adres pod którym aplikacja oczekuje żądania. 

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda kontrolera mapująca żądania POST, label=lst:kontrolerapiupload]
@PostMapping("/api/solidityFiles")
public ResponseEntity<SolidityFile> uploadFile(@RequestBody String sourceCode) throws IOException {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    return ResponseEntity.ok(solidityService.save(sourceCode));
}
\end{lstlisting}
\end{center}

Kolejną adnotacją jest \mbox{\textbf{@RequestBody}}. Adnotacja ta informuje framework o tym, żeby ciało żądania HTTP było umieszczone pod zmienną, przy której jest adnotacja. 

Ostatnia rzeczą, która pochodzi z modułu \textbf{Spring MVC} jest klasa \textbf{ResponseEntity}. Umożliwia ona zwrócenie statusu HTTP z danymi zwracanymi przez metodę. Dzięki temu framework wie jaki status ma zwrócić użytkownikowi.

Głównym celem tej metody jest zapisanie za pomocą serwisu nowego kodu źródłowego do aplikacji, w związku z tym na listingu \ref{lst:kontrolerapiupload} widać wywołanie metody \textbf{save} na atrybucie \mbox{\textbf{solidityService}}. Implementacja wywoływanej metody została opisana w dalszej części pracy.

Nad cała klasą \mbox{\textbf{SolidityApiController}} znajduje się adnotacja \textbf{@RestController}, która informuje Springa, że jest to kontroler wykorzystywany do tworzenia API Restowego.

\subsection{Kontroler strony internetowej}

\textbf{SolidityControler}, jest to kontroler odpowiedzialny za tworzenie strony internetowej  w postaci kodu HTML jest oznaczony adnotacja \textbf{@Controller}. Działa on podobnie jak wcześniej opisany kontroler. Główną różnica jest to ze w odpowiedzi zwraca kod HTML, który jest wyświetlany jako strona internetowa u użytkownika. Do generowania kodu HTML zostal wykorzystany moduł \textbf{Thymeleaf}. To w jaki sposób dodaje się nowe moduły do projektu zostało przedstawione na przykład na listingu \ref{lst:dodaniezaleznosci}

Listing \ref{lst:uploadowanie} przedstawia metodę przyjmująca w żądaniu HTTP kod źródłowy. Metoda ta działa podobnie jak w przypadki API, tylko w tym przypadku za pomocą \textbf{return} zwracana jest nazwa pliku zawierającego szablon HTML. Spring widząc, ze zwrócono taką nazwę przeszukuje katalog \textbf{resources}, znajdujący się w projekcie, w celu odnalezienia pasującego szablonu HTML. Istnieje możliwość przekazania danych do szablonu. W tym celu wykorzystywany jest parametr model, na którym wywoływana jest metoda \textbf{addAttribute}. Dane które są przekazywane za pomocą metody \textbf{addAtribute} pochodzą z obiektu klasy \textbf{SolidityFile}.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przechwytywanie żądania o dodanie nowego kodu źródłowego, label=lst:uploadowanie]
@PostMapping("/solidity/text")
public String handleSourceCodeUpload(@RequestParam("sourceCode") String sourceCode, Model model) throws Exception {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    requireNonNull(model, "Expected not-null model");

    SolidityFile savedSolidityFile = solidityService.save(sourceCode);

    model.addAttribute("solidityFileFunctions", savedSolidityFile.getSolidityFunctions());
    model.addAttribute("solidityFileHash", savedSolidityFile.getSourceCodeHash());
    return "solidity-page";
}
\end{lstlisting}
\end{center}

\subsection{Przetwarzanie kodu źródłowego}

Oba kontrolery korzystają z obiektu klasy \textbf{SolidityService}. Jak widać na rysunku \ref{rys:szukanie_funkcji}, klasa ta wykorzystuje: \textbf{SolidityParser} oraz opisaną już wcześniej, w sekcji 3.3, klasę \textbf{SolidityFileRepository}. 

Serwis po otrzymaniu kodu źródłowego od kontrolerów, przekazuje po jednej linii do parsera, który definiuje czy w danej linii jest sygnatura funkcji. Następnie jeśli znaleziono sygnaturę to zostaje ona zwracana wraz z jej selektorem. Po sparsowaniu w serwisie wszystkich linii kodu źródłowego, jest do bazy danych zapisywany obiekt klasy \textbf{SolidityFile}, który składa się z hasza, kod źródłowego oraz listy funkcji znajdujących się w kodzie źródłowym kontraktu.

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} można zaobserwować główną metodę wyszukującą funkcję. Metoda przyjmuje pojedyncza linie kodu źródłowego, a zwraca w rezultacie obiekt klasy generycznej \textbf{Optional<SolidityFunction>}. Metoda ta sprawdza cztery możliwe przypadku kiedy powinna wykryć funkcje w kodzie źródłowym.

W celu wykrywania błędów w wyrażeniach regularnych lub metodach wyszukujących funkcji, sprawdzane jest czy w danej linii została wykryta tylko jedna funkcja. Jeśli okaże się, ze wykryto więcej niż jedna funkcje, oznacza to że któraś z tych metod fałszywie wykrywa. Co prawda obniża to wydajność aplikacji, ale w przypadku fałszywych wyników zastanie zwrócony wyjątek. Wszystkie cztery przypadki zostały opisane w dalszej części pracy.

\textbf{Optional} jest to klasa, która zabezpieczenia przed przekazywaniem referencji na wartość \textbf{null}. Dzięki temu że wartość \textbf{null} nie będzie przekazywana dalej, łatwiej jest zlokalizować miejsce usterki, ponieważ podczas pobierania obiektu z klasy \textbf{Optional}, jeśli jest ona pusta, zostaje wyrzucony wyjątek \textbf{NoSuchElementException}. Klasa \textbf{Optional} została wprowadzona w ósmej wersji Javy \cite{java8doc}.


\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnatury funkcji, label=lst:wyszukiwaniesygnaturyfunkcji]
    Optional<SolidityFunction> findFunctionInLine(String line) {
        List<Optional<SolidityFunction>> functions =
                Stream.of(
                        findFunctionSignature(line),
                        findMappingGetter(line),
                        findArrayGetter(line),
                        findNormalVariableGetter(line)
                ).filter(Optional::isPresent).collect(toList());

        if (functions.size() > 1) {
            throw new IllegalStateException("Expected only one function, but found :" + functions.size());
        } else if (functions.size() == 1) {
            return functions.listIterator().next();
        }
        return Optional.empty();
    }
\end{lstlisting}
\end{center}

\subsubsection{Wykrywanie sygnatury zadeklarowanej funkcji}

Pierwszym przypadkiem, są funkcje jawnie zadeklarowane w kodzie źródłowym nie posiadające modyfikatora \textbf{internal} lub \textbf{private}. W celu wykrycia takich funkcji wykorzystane zostało wyrażenie regularne zaprezentowane poniżej:
\begin{verbatim}
^\s*function\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*([^(){}]*)\s*\)\s*(?!.*(internal|private)).*$
\end{verbatim}

W wyrażeniu tym zostały wykorzystane dwie grupy. Pierwsza grupa wyciąga z linii kodu źródłowego nazwę funkcji, natomiast drugą sygnaturę funkcji. Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcjizfunkjci} widać metodę wyszukującą sygnaturę funkcji za pomocą przygotowanego wyrażenia regularnego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda odbierająca żądanie o zapisanie kodu źródłowego na serwerze, label=lst:wyszukiwaniesygnaturyfunkcjizfunkjci]
    private Optional<SolidityFunction> findFunctionSignature(String line) {
        Matcher matcher = FUNCTION_PATTERN.matcher(line);
        if (matcher.find()) {
            String functionName = matcher.group(FUNCTION_NAME_GROUP_ID);
            String functionArguments = matcher.group(FUNCTION_ARGUMENTS_GROUP_ID);
            String functionSignature = normalizeFunctionSignature(functionName, functionArguments);
            String functionSelector = getFunctionSelector(functionSignature);
            return Optional.of(new SolidityFunction(functionSelector, functionSignature));
        }
        return Optional.empty();
    }
\end{lstlisting}
\end{center}

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutów typu mapa}

TODO

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutu tablicowych}

TODO

\subsubsection{Wykrywanie sygnatury funkcji dla pozostałych publicznych atrybutów}
    
    TODO

\section{Wyszukiwanie selektorów funkcji w kodzie bajtowym}

Literatura: \cite{autor1, autor2}. TODO

\section{Dopasowywanie implementacji na podstawie kodu bajtowego}

Literatura: \cite{autor1, autor2}. TODO

\section{Wykorzystane technologie}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 




%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Bibliografia.
%____________________________________________________________________________________________
\phantomsection
\begin{thebibliography}{99}
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\addcontentsline{toc}{chapter}{Bibliografia}		% Dodanie do spisu treści.

\bibitem{rfc2616} Network Working Group \url{https://www.ietf.org/rfc/rfc2616.txt}.
\bibitem{java8doc} Oracle \url{https://docs.oracle.com/javase/8/docs/}.
\bibitem{autor1} Bibliografia 2. \emph{Nazwa}. 

\end{thebibliography}

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage					
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis tabel.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.	
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}		% Dodanie do spisu treści.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis rysunków.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________%____________________________________________________________________________________________
% Spis listingów. 
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\lstlistoflistings
\addcontentsline{toc}{chapter}{Spis listingów} 
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

\end{document}
