
% 1. Należy w programie ustawić zgodne kodowanie, w tym przypadku jest UTF-8. 
% 2. Kompilować ten plik za pomocą pdfLatex.


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Ustawienia pracy.
%____________________________________________________________________________________________

% Obowiązkowo! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definiowanie stylu i formatu pracy.
\documentclass[a4paper,twoside,12pt]{book}	% twoside - dwustronnie		 
\usepackage{polski}		 		% ustawienie języka
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[utf8]{inputenc}	
\usepackage{latexsym}
\usepackage{indentfirst} 				% wcięcia akapitu
\linespread{1.5}					% odstęp między liniami
\usepackage{geometry}
\geometry{lmargin=3.5cm, rmargin=3cm}	% ustawienie marginesów, lewy większy na oprawę

\usepackage{url}
\usepackage{enumerate}				% numeracja
\usepackage{amsopn}
\usepackage{graphicx} 				% grafika
\usepackage{epstopdf}				% grafika formatu eps
\usepackage{tabularx} 				% tabele
\usepackage{hyperref} 				% łącza
\usepackage{picture} 				% rysunki
\usepackage{upgreek}				% greckie symbole

\usepackage{listings}				% listingi
\usepackage{color}					% kolory


 % Polecenie usunięcia paginy na pustej stronie.
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} 	


% Zmiana nazwy rozdziału z listingami, domyślnie jest Listings.
\renewcommand{\lstlistlistingname}{Spis listingów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec



% Dodatkowo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definicje własnych otoczeń.
\theoremstyle{definition}
\newtheorem{dfn}{Definicja}[chapter]
\newtheorem{prz}[dfn]{Przykład}

\theoremstyle{remark}
\newtheorem{wsk}[dfn]{Wniosek}
% koniec


% Definiowanie własnego stylu listingu.
\lstset{
  frame             	= lines,
  basicstyle        	= \linespread{1}\ttfamily,%\small\footnotesize,
  columns           	= fullflexible,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
  breaklines=true,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec	 



\begin{document}

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Strona tytułowa.
%____________________________________________________________________________________________

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother 
% Tutaj wszystko należny wypełnić w nawiasach {}, nic więcej nie zmieniać!

\author{\textbf{Piotr Jasina}}        	% Podaj imię i nazwisko.
\title{Identyfikacja inteligentnych kontraktów w sieci Ethereum}      % Podaj tytuł polski.
\date{{\textbf{Lublin rok \the\year}}}	% Nic nie zmieniaj, rok wygeneruje automatycznie.
\def\engtitle{Ethereum smart contracts identification} % Podaj tytuł angielski.

\def\kierunek{Informatyka}		% Podaj kierunek studiów.
\def\specjalnosc{.....}			% Podaj specjalność, jeśli istnieje.
\def\nralbumu{279183}			% Podaj nr albumu.

\def\rodzaj{licencjacka}			% Podaj rodzaj pracy.
\def\zaklad{Zakładzie Cyberbezpieczeństwa}	% Podaj nazwę zakładu Twojego promotora.
\def\promotor{dr. Damiana Rusinka}	% Podaj promotora.

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Poniżej w {titlepage} nic nie zmieniać.

\renewcommand{\maketitle}{
\begin{titlepage}
\begin{table}
\begin{tabular}{c@{\hspace{10mm}}|@{\hspace{3mm}}l}
\multicolumn{2}{@{\hspace{15mm}}l}{\vspace{-31mm}} \\
\multicolumn{2}{l}{\hspace{-20mm}\includegraphics[scale=0.4]{UMCS}} \\ 
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{7mm}} \\

\multicolumn{2}{@{\hspace{16mm}}l}{\Large UNIWERSYTET MARII CURIE-SKŁODOWSKIEJ} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large W LUBLINIE} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large Wydział Matematyki, Fizyki i Informatyki} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{16mm}} \\

& \multicolumn{1}{m{13cm}}{Kierunek: \kierunek} \\
% Jeśli nie ma specjalności, to należy zakomentować poniższą linijkę!
% & \multicolumn{1}{m{13cm}}{Specjalność: \specjalnosc} \\
& \\
& \multicolumn{1}{m{13cm}}{\@author} \\
& \multicolumn{1}{m{13cm}}{nr albumu: \nralbumu} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{\Large\textbf{\@title}} \\
& \\
& \multicolumn{1}{m{13cm}}{\engtitle} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{Praca \rodzaj} \\	
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{napisana w \zaklad} \\
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{pod kierunkiem \promotor} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\vspace{7mm}} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\@date}
\end{tabular}
\end{table}
\end{titlepage}
}
% koniec 

% Tworzenie strony tytułowej.
\maketitle
% Wyczyszczenie z numeracji strony za stroną tytułową. 
\clearemptydoublepage


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis treści. 
%____________________________________________________________________________________________
\tableofcontents 		
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 	
\clearemptydoublepage			


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Wstęp pracy.
%____________________________________________________________________________________________
\chapter*{Wstęp}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Wstęp} 	% bez numeru w spisie treści

...
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 1.
%____________________________________________________________________________________________
\chapter[Ethereum]{Ethereum}
% W nawiasach [] zapisujemy skróconą nazwę rozdziału, pojawiający się w paginie górnej oraz w spisie treści.
% W nawiasach {} zapisujemy pełną nazwę rozdziału.
% '\protect \\' służy do dzielenia długiej nazwy rozdziału.

\section{Historia}

TODO

\section{Opis platformy}

TODO

\section{Ethereum Virtual Machine}

TODO

\section{Inteligentne kontrakty}

TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 2.
%____________________________________________________________________________________________
\chapter[Solidity]{Solidity}

\section{Sygnatura funkcji}

TODO


\section{Selektor funkcji}

TODO

\section{Generowanie akcesorów podczas kompilacji}

TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 3.
%____________________________________________________________________________________________
\chapter[Projekt Aplikacji]{Projekt Aplikacji}
Celem mojej pracy licencjackiej było stworzenie aplikacji internetowej umożliwiającej identyfikację  inteligentnych kontraktów w sieci \textbf{Ethereum}. Dzięki aplikacji użytkownik po wprowadzeniu na stronie kodu bajtowego kontraktu jest w stanie otrzymać najbardziej prawdopodobną implementacje kontraktu napisana w języku \textbf{Solidity}.

Aplikacja została stworzona przy wykorzystaniu frameworka \textbf{Spring Boot}, modułu \textbf{Spring Data MongoDB} oraz \textbf{Spring MVC}. Natomiast w celu przechowywania danych wykorzystano nierelacyjną bazę danych \textbf{MongoDB}.

W tym rozdziale znajduje się opis funkcjonalności, architektury, implementacji oraz wykorzystanych technologi.
\section{Opis funkcjonalności}


Na stronie głównej aplikacji znajduje się opis wraz z aktualna liczba kodów źródłowych znajdujących się w bazie danych oraz podstawowe definicje związane z aplikacją. Cała aplikacji udostępnia trzy główne funkcjonalności: identyfikację inteligentnych kontraktu, wprowadzanie plików źródłowych kontraktów do aplikacji oraz interfejs programistyczny aplikacji. Wszystkie funkcjonalności zostały opisane poniżej.

\subsection{Identyfikacja inteligentnych kontraktów}
Pierwszą opcją dostępną w  aplikacji jest identyfikacja inteligentnych kontraktów. Zarówno na stronie głównej, jak i podstronie znajduje się pole, w którym można wprowadzić kod bajtowy. Po wprowadzeniu danych użytkownik zatwierdza je, w obu przypadkach klikając przycisk \textbf{Identify}. Przycisk \textbf{Identify bytecode}, służy do przejścia na podstronę związaną z identyfikacją kontraktu.

Po wprowadzeniu danych i zatwierdzeniu ich przyciskiem \textbf{Identify}, aplikacja rozpoczyna proces analizy wprowadzonego kodu bajtowego oraz wyszukiwane są najbardziej prawdopodobne implementacje kontraktu, posortowane malejąco według współczynnika dopasowania. Na rysunku \ref{rys:wynik_identyfikacji} został przedstawiony przykładowy wynik identyfikacji.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.55]{wynik_identyfikacji.png}
\caption{Wynik identyfikacji inteligentnego kontraktu}
\label{rys:wynik_identyfikacji}
\end{figure}

Domyślnie jest wyświetlanych dziesięć najbardziej prawdopodobnych implementacji, po naciśnięciu przycisku \textbf{Get all}, znajdującego się pod listą kontraktów, zostaną wyświetlone wszystkie dopasowania.


Po naciśnięciu w jedną z wyświetlanych implementacji użytkownik zostanie przeniesiony na podstronę umożliwiającą podgląd implementacji. Na rysunku \ref{rys:podglad_impelementacji} znajduje się przykład przeglądania kodu źródłowego na stronie. Rozwiązanie z numerowaniem linii zostało zaimplementowane w taki sposób, aby podczas kopiowania kodu źródłowego ze strony, nie były kopiowane z nim liczby identyfikujące konkretną linię w kodzie. Istnieje też możliwość pobrania kodu źródłowego ze strony z rozszerzeniem \textbf{.sol}


\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{podglad_impelementacji.png}
\caption{Podgląd implementacji}
\label{rys:podglad_impelementacji}
\end{figure}

\subsection{Dodanie kodu źródłowego kontraktu do aplikacji}
Strona umożliwia dodanie własnego kodu źródłowego kontraktu napisanego w języku \textbf{Solidity}. W tym celu należy zalogować się za pomocą panelu logowania, który zostaje wyświetlony automatycznie przy próbie korzystania z autoryzowanych funkcjonalności aplikacji. Po kliknięciu w \textbf{Identify Solidity} oraz zalogowaniu się na stronie, pojawiają się dwie możliwości wprowadzania kodów źródłowych.


Pierwszym sposobem jest przesłanie do aplikacji pliku zawierającego implementacje kontraktu. W tym celu użytkownik powinien nacisnąć przycisk \textbf{Browse} i wybrać konkretny plik, a następnie zatwierdzić go przyciskiem \textbf{Upload} widocznym na rysunku \ref{rys:ekran_pozuploadowaniu}. 


Innym sposobem na przesłania kodu źródłowego do aplikacji jest wklejenie kodu źródłowego bezpośrednio do formularza znajdującego się po prawej części strony internetowej.


Po prawidłowym dodaniu kodu źródłowego do aplikacji użytkownik powinien zobaczyć podobny rezultat do tego na rysunku \ref{rys:ekran_pozuploadowaniu}. W momencie dodania nowej implementacji, na stronie pojawia się hasz dodanego pliku oraz lista sygnatur funkcji wraz z ich selektorami. Po naciśnięciu na wyświetlany na rysunku \ref{rys:ekran_pozuploadowaniu} hasz pliku, użytkownikowi wyświetli się przesłany kod źródłowy.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{ekran_pozuploadowaniu.png}
\caption{Rezultat przesłania inteligentnego kontraktu do aplikacji}
\label{rys:ekran_pozuploadowaniu}
\end{figure}


\subsection{Interfejs programistyczny aplikacji}
Trzecią funkcjonalnością aplikacji jest interfejs programistyczny. Dzięki niemu można wykorzystać mechanizmy zaimplementowane w aplikacji w innej aplikacji. Przykładowym zastosowaniem API jest utworzenie skryptu umożliwiającego zautomatyzowane wysyłanie kodów źródłowych do aplikacji, bez konieczności korzystania z interfejsu graficznego aplikacji.

Użytkownik za pomocą API ma możliwość pobrania informacji o kodzie źródłowym, identyfikacji kontraktu oraz przesłania nowego kontraktu do aplikacji.


\subsubsection{Pobieranie informacji o kodzie źródłowym z API}

Podczas pobierania informacji o kodzie źródłowym, użytkownik musi posiadać identyfikator pliku, który chce pobrać. Żądanie pobierające plik z API można zobaczyć na listingu \ref{lst:zadanieokodzrodlowy}. W odpowiedzi użytkownik dostaje zwykły tekst zawierający implementację kontraktu oraz status HTTP 200, 404 lub 500. Status 200 oznacza, że wszystko poszło pomyślnie. W sytuacji, gdy użytkownik otrzyma status 404, oznacza to, że nie udało się znaleźć implementacji o podanym haszu. Odpowiedz zawierająca status 500 oznacza, że wystąpił błąd na serwerze i nie udało się zwrócić kodu źródłowego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Żądanie wysyłane w celu pobrania kodu źródłowego, label=lst:zadanieokodzrodlowy]
GET /api/sourceCode/0x06c61b8e505d7a407af9a91bdff8085560e90a133c77ab32bde32e686f6a8d52.sol HTTP/1.1
Host: localhost:8080
Accept: text/plain;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
\end{lstlisting}
\end{center}



\subsubsection{Identyfikacja inteligentnego kontraktu za pomocą API}
W celu identyfikacji kontraktu należy wysłać żądanie pod adres \mbox{/api/bytecode}. W ciele żądania jest wymagane od użytkownika podanie dwóch atrybutów o nazwach: \textbf{bytecode} oraz \textbf{allFiles}. Atrybuty przesyłane do API powinny być zakodowane według schematu \mbox{\textbf{nazwa\_atrybutu=wartosc}}, a wszystkie tak przygotowane atrybuty należy połączyć ze sobą pomocą ampersandu. Poprawny przykład żądania można zobaczyć na listingu \ref{lst:identyfikacjaapi}.




\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Żądanie wysylane w celu identyfikacji kontraktu za pomocą API, label=lst:identyfikacjaapi]
POST /api/bytecode HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

bytecode=60803350200fe56abcede00229&allFiles=false

\end{lstlisting}
\end{center}

Na listingu \ref{lst:identyfikacjaapi} do atrybutu \textbf{bytecode} został wprowadzony kod bajtowy kontraktu. Do zmiennej \textbf{allFiles} została wprowadzona wartość \textbf{false}, wiec w rezultacie zostanie zwrócone przez aplikację dziesięć najbardziej prawdopodobnych implementacji. Jeśli użytkownik chce pobrać wszystkie możliwe dopasowania, należy ustawić tą zmienną na \textbf{true}. W żądaniu został wprowadzony nagłówek \textbf{Content-Length} określający długość przesyłanych danych oraz \textbf{Content-Type} oznaczający rodzaj przesyłanych danych. 


Jeśli wszystko poszło pomyślnie, użytkownik otrzyma status HTTP 200 wraz z listą składającą się z haszu pliku i współczynnika dopasowania danego pliku w formacie \textbf{JSON}. W przypadku gdy nie zostanie dopasowana żadna implementacja, to aplikacja zwróci status 404, natomiast jeśli w aplikacji wystąpi błąd, to zostanie zwrócony status 500.


\subsubsection{Przesyłanie nowego kodu źródłowego za pomocą API}

Gdy użytkownik chce przesłać nowy kontrakt do aplikacji, musi przejść proces uwierzytelniania. W tym celu należy do żądania dodać nagłówek \textbf{Authorization}. W nagłówku należy podać typ autoryzacji oraz zakodowane dane logowania za pomocą \textbf{Base64} według schematu \textbf{login:haslo}. Na przykładzie z listingu \ref{lst:dodaniedoapi} został przesłany kod źródłowy, a do autoryzacji wykorzystano login: 123 oraz hasło: 123.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przesyłanie kodu źródłowego za pomocą API, label=lst:dodaniedoapi]
POST /api/solidityFiles HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Accept: application/json
Authorization: Basic MTIzOjEyMw==
Content-Length: 221
Accept: application/json

pragma solidity ^0.4.21;
contract Hello {
    string public message;
    function setMessage(string newMessage) public {
        message = newMessage;
    }
}

\end{lstlisting}
\end{center}



Po pomyślnym przesłaniu kontraktu w odpowiedzi od serwera użytkownik otrzymuje status HTTP 200. W odpowiedzi zostaje również przesłany kod źródłowy, hasz stworzony na podstawie kodu źródłowego oraz listę znalezionych sygnatur funkcji wraz z ich selektorami. W przypadku wystąpienia błędu na serwerze zostaje zwrócony status 500. Na listingu \ref{lst:przykladodpowiedzijson} można zaobserwować przykładowe dane zawarte w odpowiedzi od serwera.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przykładowa odpowiedz w formacie JSON, label=lst:przykladodpowiedzijson]
{
    "sourceCodeHash": "0x8dea780e1286d12a957d40597b9171a5187f87f6e3f8303505bc53a4453ad5b6",
    "sourceCode": "pragma solidity ^0.4.21;\r\ncontract Hello {\r\n    string public message;\r\n    function setMessage(string newMessage) public {\r\n        message = newMessage;\r\n    }\r\n}",
    "solidityFunctions": [
        {
            "selector": "e21f37ce",
            "signature": "message()"
        },
        {
            "selector": "368b8772",
            "signature": "setMessage(string)"
        }
    ]
}
\end{lstlisting}
\end{center}


\section{Przedstawienie architektury}

W tym podrozdziale omówię architekturę aplikacji, która realizuje funkcjonalności opisane w sekcji 3.1. Poniżej zostały krótko opisane główne klasy będące częścią aplikacji, widoczne na rysunku \ref{rys:architektura}.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.5]{architektura.png}
\caption{Architektura aplikacji}
\label{rys:architektura}
\end{figure}

\begin{description}
\item[LoginController] jest to klasa wyświetlająca ekran logowania

\item[ErrorController] jej zadaniem jest przechwytywane wszystkich błędy w aplikacji. Po złapaniu błędu użytkownikowi zostaje wyświetlona strona informująca, że pojawił się błąd w aplikacji, dodatkowo wszystkie błędy zostają logowane.

\item[BytecodeController] służy do wyświetlania użytkownikowi strony związanej z identyfikacją kodu bajtowego oraz do mapowania żądań HTTP służących do identyfikacji. 

\item[SolidityController] mapuje żądania HTTP związane z przetwarzaniem plików Solidity.

\item[Disassembler] odpowiada za analizę przekazanego kodu bajtowego. W rezultacie zwraca listę instrukcji zawartych w kodzie. Szczegółowe działanie tej klasy zostało opisane w dalszej części pracy, w sekcji 3.5 dotyczącej wyszukiwania selektorów funkcji w kodzie bajtowym. 

\item[SolidityParser] wyciąga z kodu źródłowego listy funkcji, składających się z sygnatury oraz selektora. Sposób tworzenie selektorów funkcji oraz wyciągania z kodu źródłowego sygnatur funkcji został przedstawiony w sekcji 3.4

\item[SolidityService] jest to klasa odpowiedzialna za odczytywanie danych z bazy danych oraz za przygotowanie przesłanych danych przed zapisem w bazie danych.

\item[BytecodeService] odpowiada za dopasowywanie kodu bajtowego do kontraktu. W tym celu serwis wykorzystuje opisane wyżej klasy \textbf{Disassembler} oraz \textbf{Solidity}, które w połączeniu umożliwiają wyznaczenie współczynnika dopasowania pomiędzy konkretnym plikiem a kodem bajtowym. Szczegółowo zostało to opisane w sekcji 3.5, która znajduje się w dalszej części pracy.

\item[SolidityFileRepository] jest to część aplikacji odpowiedzialna za komunikację z bazą danych oraz mapowanie danych przechowywanych w bazie danych na obiekty. Repozytorium jest interfejsem, który wykorzystuje moduł \mbox{\textbf{Spring Data MongoDB}}. Implementacja tego interfejsu spoczywa na frameworku Spring. Szczegóły łączenia z bazą danych zostały opisane w sekcji 3.3

\end{description}


\section{Połączenie z bazą danych}
W celu integracji aplikacji z bazą danych \textbf{MongoDB} został wykorzystany framework \textbf{Spring} oraz moduł \textbf{Spring Data MongoDB}. W związku z tym, że projekt aplikacji jest budowany za pomocą narzędzia \textbf{Apache Maven}, należy dodać do pliku \textbf{pom.xml} wykorzystywane moduły. 

Na listingu \ref{lst:dodaniezaleznosci} został przedstawiony fragment pliku \textbf{pom.xml} odpowiedzialny za dodawanie modułu \mbox{\textbf{spring-boot-start-data-mongodb}} do projektu. Dodawanie innych modułów jest analogiczne do przykładu z listingu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad dodania zależności w pliku pom.xml, label=lst:dodaniezaleznosci]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
\end{lstlisting}
\end{center}

W pliku konfiguracyjnym \mbox{\textbf{application.properties}}, który jest wykorzystywany przez framework, należy skonfigurować dane do połączenia z bazą danych. Przykładowa zawartość pliku konfiguracyjnego została przedstawiona na listingu \ref{lst:applicationproperties}.
 
\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Kofiguracja bazy danych, label=lst:applicationproperties]
spring.data.mongodb.uri=mongodb://${ADMIN_DB_LOGIN}:${ADMIN_DB_PASSWORD}@ds129904.mlab.com:29904/${DATABASE_NAME_CONTRACT}
admin.login=${ADMIN_LOGIN}
admin.password=${ADMIN_PASSWORD}
\end{lstlisting}
\end{center}

Spring umożliwia wykorzystanie zmiennych środowiskowych w pliku konfiguracyjnym. Przykładem takiego zastosowania jest linia przedstawiona poniżej:
\begin{verbatim}
admin.login=${ADMIN_LOGIN}
\end{verbatim}
Zmienna środowiskowa została podana w nawiasach klamrowych. Dzięki temu można zabezpieczyć aplikację przed wyciekiem wrażliwych danych, takich jak loginy i hasła do bazy danych, podczas upubliczniania kodu źródłowego na przykład w repozytorium na \textbf{GitHub}.

Po skonfigurowaniu pliku \mbox{\textbf{pom.xml}} oraz \mbox{\textbf{application.properties}}, został utworzony interfejs \mbox{\textbf{SolidityFileRepository}}, który umożliwia serwisom aplikacji wykonywanie operacji na bazie danych oraz ustala mapowanie obiektów z bazy danych na obiekty klasy \mbox{\textbf{SolidityFile}}. Utworzone w aplikacji repozytorium można zobaczyć na listingu \ref{lst:repozytoriummongo}.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Stworzenie repozytorium za pomocą Spring Data MongoDB, label=lst:repozytoriummongo]
@Repository
interface SolidityFileRepository extends MongoRepository<SolidityFile, String> {

    @Query("{\"solidityFunctions\": {$elemMatch: {\"selector\": {$in: ?0}}}}")
    List<SolidityFile> findSolidityFilesBySelectorContainsAll(List<String> functionSelector);

    Optional<SolidityFile> findBySourceCodeHash(String sourceCodeHash);
}
\end{lstlisting}
\end{center}

W pierwszej linii listingu \ref{lst:repozytoriummongo} znajduje się adnotacja \mbox{\textbf{@Repository}} pełniąca role stereotypu oraz informująca Springa, że ten interfejs jest wykorzystywany, w celu wykonywania operacji z bazą danych.

Kolejna adnotacja jest \mbox{\textbf{@Query}}. Jej parametrem jest zapytanie do bazy danych \textbf{MongoDB}, pytające o listę plików, które posiadają w sobie część przekazanych przez użytkownika selektorów funkcji. Za pomocą tej adnotacji można przypisać konkretnej metodzie z \mbox{\textbf{SolidityFileRepository}} konkretne zapytanie, które ma wykonać.

Jeśli metoda w interfejsie nie posiada wspomnianej adnotacji, wtedy framework wygeneruje zapytanie do bazy danych, bazując na nazwie metody oraz przyjmowanych i zwracanych przez metodę typach danych.

W celu wykorzystania tego interfejsu konieczne było utworzenie klasy reprezentującej encję bazodanową w aplikacji. Na listingu \ref{lst:przykladencji} została przedstawiona taka klasa \mbox{\textbf{SolidityFile}}. Składa się ona z trzech atrybutów: haszu kodu źródłowego, kodu źródłowego, oraz listy funkcji znalezionych w tym kodzie źródłowym. Atrybut \textbf{sourceCodeHash} został utworzony w celu zapewnienia unikalności samego źródłowego, którego rozmiar jest zbyt duży, by nadać mu indeks bazodanowy. Tworzeniem haszu zajmuje się klasa \mbox{\textbf{SolidityService}} znajdująca się na rysunku \ref{rys:architektura} w wyższej warstwie. Dodatkowo poza zapewnieniem unikalności, hasz jest identyfikatorem kodu źródłowego w bazie danych, w związku z tym posiada on adnotację \mbox{\textbf{@Id}}. Atrybut ten jest odpowiednikiem identyfikatora w bazie danych. W związku z tym, że hasz jest identyfikatorem, gwarantuje on unikalność kodu źródłowego w bazie danych. Jeśli wartość pod adnotacją nie została wcześniej przypisana to moduł \mbox{\textbf{Spring Data MongoDB}} automatycznie wygeneruje identyfikator dla nowego obiektu i przypisze go do wskazanego przez adnotacje atrybutu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad klasy wykorzystywanej przez Spring Data MongoDb, label=lst:przykladencji]
public class SolidityFile {
    @Id
    private final String sourceCodeHash;
    private final String sourceCode;
    private final Set<SolidityFunction> solidityFunctions;

    SolidityFile(String sourceCodeHash, String sourceCode, Set<SolidityFunction> solidityFunctions) {
        requireNonNull(sourceCodeHash, "Expected not-null sourceCodeHash");
        requireNonNull(sourceCode, "Expected not-null sourceCode");
        requireNonNull(solidityFunctions, "Expected not-null solidityFunctions");
        this.sourceCodeHash = sourceCodeHash;
        this.sourceCode = sourceCode;
        this.solidityFunctions = solidityFunctions;
    }

    public String getSourceCodeHash() { return sourceCodeHash; }
    public String getSourceCode() { return sourceCode; }
    public Set<SolidityFunction> getSolidityFunctions() { return solidityFunctions; }

    @Override
    public String toString() {
        return "SolidityFile{" + "sourceCodeHash='" 
                 + sourceCodeHash
        	 + '\'' + ", sourceCode='" + sourceCode + '\'' 
        	 + ", solidityFunctions=" + solidityFunctions + '}';}

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SolidityFile)) return false;
        SolidityFile that = (SolidityFile) o;
        return Objects.equals(sourceCodeHash, that.sourceCodeHash) &&
                Objects.equals(sourceCode, that.sourceCode) &&
                Objects.equals(solidityFunctions, that.solidityFunctions);}

    @Override
    public int hashCode() {
        return Objects.hash(sourceCodeHash, sourceCode, solidityFunctions);}
}
\end{lstlisting}
\end{center}

Klasa ta została stworzona tak, aby uniknąć niechcianych modyfikacji pól obiektów tej klasy przez aplikację. Pola zostały ustawione na \textbf{final}, a wartości obiektu można przypisać tylko podczas jego inicjalizacji. W momencie tworzenia obiektu klasy \textbf{SolidityFile}, zostają wywoływane w konstruktorze metody sprawdzające, czy użytkownik nie wprowadził wartości \textbf{null}. Jeśli zostanie wprowadzona w konstruktorze taka wartość, wtedy aplikacja zgłasza wyjątek i informuje, że dzieje się coś niedobrego. Dzięki temu aplikacja została zabezpieczona przed niechcianym i niekontrolowanym przekazywaniem \textbf{null}i do innych części systemu.

Kolejnym elementem tej klasy są akcesory, nadpisana metoda \textbf{toString} w taki sposób, który będzie przedstawiać stan obiektu oraz nadpisane metody \textbf{equals} i \textbf{hashCode}, które są wykorzystywane przez kolekcje używane w Javie, oraz inne klasy z nimi związane.

Ponieważ klasa \textbf{SolidityFunction} jest wykorzystywana w klasie \textbf{SolidityFile}, została ona zaimplementowana w analogiczny sposób z taką różnicą, że posiada atrybuty: \textbf{selector} oraz \textbf{signature} typu \textbf{String}. W dodatku w tej klasie nie została użyta adnotacja \mbox{\textbf{@Id}}, ponieważ klasa nie jest wykorzystywana niezależnie w bazie danych.


\section{Identyfikacja sygnatur funkcji w kodzie źródłowym}


Wyszukiwanie sygnatur funkcji jest rozpoczynane w momencie przesłania nowego kodu źródłowego przez użytkownika do aplikacji. Podczas wyszukiwania sygnatur funkcji są generowane selektory funkcji, które są wykorzystywane podczas identyfikacji kodu bajtowego. Problemem podczas wyszukiwania sygnatur w kodzie źródłowym jest to, że część sygnatur jest niejawna, ponieważ są one dodatkowo generowane przez kompilator \textbf{Ethereum Virtual Machine} dla publicznych atrybutów kontraktów \cite{soliditydoc}. 


W przypadku API wykorzystywana jest klasa \textbf{SolidityApiController}, którą widać na rysunku \ref{rys:architektura}. Zadaniem tej klasy jest nasłuchiwanie adresów związanych z API, zwracanie danych do użytkownika w formacie \textbf{JSON} lub zwykłego tekstu oraz komunikowanie się z obiektem klasy \textbf{SolidityService}. 


Jeśli użytkownik korzysta ze zwykłej strony internetowej, wtedy przetwarzaniem żądań HTTP zajmuje się \textbf{SolidityController}. Klasa ta działa podobnie do poprzedniej, z taka różnica, że ten kontroler nasłuchuje inne adresy oraz zwraca dane w postaci kodu \textbf{HTML}, zamiast w formacie \textbf{JSON} lub zwykłego tekstu.


\subsection{Kontroler interfejsu programistycznego}

Na listingu \ref{lst:kontrolerapiupload} została przedstawiona metoda kontrolera \textbf{SolidityApiController} umożliwiająca przesyłanie kodu źródłowego. Adnotacje, które wykorzystuje ta metoda, są częścią modułu \textbf{Spring MVC}. Pierwszą adnotacją wykorzystaną w metodzie jest \textbf{@PostMapping}, która zajmuje się mapowaniem żądań HTTP przesyłanych do API. W parametrze tej adnotacji podany został adres, pod którym aplikacja oczekuje żądania. 

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda kontrolera mapująca żądania POST, label=lst:kontrolerapiupload]
@PostMapping("/api/solidityFiles")
public ResponseEntity<SolidityFile> uploadFile(@RequestBody String sourceCode) throws IOException {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    return ResponseEntity.ok(solidityService.save(sourceCode));
}
\end{lstlisting}
\end{center}

Kolejną adnotacją jest \mbox{\textbf{@RequestBody}}. Adnotacja ta informuje framework o tym, żeby ciało żądania HTTP było umieszczone pod zmienną, przy której jest adnotacja. 

Ostatnią rzeczą, która pochodzi z modułu \textbf{Spring MVC} jest klasa \textbf{ResponseEntity}. Umożliwia ona zwrócenie statusu HTTP z danymi zwracanymi przez metodę. Dzięki temu framework wie jaki status ma zwrócić użytkownikowi.

Głównym celem tej metody jest zapisanie za pomocą serwisu nowego kodu źródłowego do aplikacji, w związku z tym na listingu \ref{lst:kontrolerapiupload} widać wywołanie metody \textbf{save} na atrybucie \mbox{\textbf{solidityService}}. Implementacja wywoływanej metody została opisana w dalszej części pracy.

Nad całą klasą \mbox{\textbf{SolidityApiController}} znajduje się adnotacja \textbf{@RestController}, która informuje Springa, że jest to kontroler wykorzystywany do tworzenia API Restowego.

\subsection{Kontroler strony internetowej}

\textbf{SolidityControler}, jest to kontroler odpowiedzialny, za tworzenie strony internetowej  w postaci kodu HTML jest oznaczony adnotacja \textbf{@Controller}. Działa on podobnie jak wcześniej opisany kontroler. Główną różnicą jest to, że w odpowiedzi zwraca kod HTML, który jest wyświetlany jako strona internetowa u użytkownika. Do generowania kodu HTML został wykorzystany moduł \textbf{Thymeleaf}. W jaki sposób są dodawane nowe moduły do projektu, zostało przedstawione na przykład na listingu \ref{lst:dodaniezaleznosci}

Listing \ref{lst:uploadowanie} przedstawia metodę przyjmująca w żądaniu HTTP kod źródłowy. Metoda ta działa podobnie jak w przypadki API, tylko w tym przypadku za pomocą \textbf{return} zwracana jest nazwa pliku zawierającego szablon HTML. Spring widząc, że zwrócono taką nazwę, przeszukuje katalog \textbf{resources}, znajdujący się w projekcie, w celu odnalezienia pasującego szablonu HTML. Istnieje możliwość przekazania danych do szablonu. W tym celu wykorzystywany jest parametr model, na którym wywoływana jest metoda \textbf{addAttribute}. Dane, które są przekazywane za pomocą metody \textbf{addAtribute} pochodzą z obiektu klasy \textbf{SolidityFile}.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przechwytywanie żądania o dodanie nowego kodu źródłowego, label=lst:uploadowanie]
@PostMapping("/solidity/text")
public String handleSourceCodeUpload(@RequestParam("sourceCode") String sourceCode, Model model) throws Exception {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    requireNonNull(model, "Expected not-null model");

    SolidityFile savedSolidityFile = solidityService.save(sourceCode);

    model.addAttribute("solidityFileFunctions", savedSolidityFile.getSolidityFunctions());
    model.addAttribute("solidityFileHash", savedSolidityFile.getSourceCodeHash());
    return "solidity-page";
}
\end{lstlisting}
\end{center}

\subsection{Przetwarzanie kodu źródłowego}

Oba kontrolery korzystają z obiektu klasy \textbf{SolidityService}. Jak widać na rysunku \ref{rys:architektura}, klasa ta wykorzystuje: \textbf{SolidityParser} oraz opisaną już wcześniej, w sekcji 3.3, klasę \textbf{SolidityFileRepository}. 

Serwis po otrzymaniu kodu źródłowego od kontrolerów przekazuje po jednej linii do parsera, który definiuje czy w danej linii jest sygnatura funkcji. Jeśli podczas parsowania linii znaleziono sygnaturę funkcji, to zostaje ona dodana wraz z selektorem do listy funkcji analizowanego pliku. Po przeanalizowaniu wszystkich linii tworzony jest obiekt \textbf{SolidityFile}, który następnie jest zapisywany do bazy danych.

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} można zaobserwować główną metodę klasy \textbf{SolidityParser} wyszukującą funkcję. Metoda przyjmuje pojedynczą linię kodu źródłowego, a w rezultacie zwraca obiekt klasy \textbf{Optional<SolidityFunction>}. Metoda sprawdza cztery możliwe przypadki, w których istnieje możliwość wykrycia funkcji w kodzie źródłowym.

W celu wykrywania błędów w wyrażeniach regularnych lub metodach wyszukujących funkcji sprawdzane jest czy w danej linii została wykryta tylko jedna funkcja. Jeśli okaże się, że wykryto więcej niż jedna funkcje, oznacza to, że jedna z tych metod fałszywie wykrywa. Takie rozwiązanie obniża to wydajność aplikacji, ale w przypadku fałszywych wyników zastanie zwrócony wyjątek. Wszystkie cztery przypadki zostały opisane w dalszej części pracy.

\textbf{Optional} jest to generyczna klasa, która zabezpiecza przed przypadkowym odwołaniem do referencji o wartości \textbf{null} oraz pozwala zabezpieczyć przed nieoczekiwanym przekazywaniem wartości \textbf{null} wewnątrz aplikacji. 

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnatury funkcji, label=lst:wyszukiwaniesygnaturyfunkcji]
Optional<SolidityFunction> findFunctionInLine(String line) {
    List<Optional<SolidityFunction>> functions =
            Stream.of(
                    findFunctionSignature(line),
                    findMappingGetter(line),
                    findArrayGetter(line),
                    findNormalVariableGetter(line)
            ).filter(Optional::isPresent).collect(toList());

    if (functions.size() > 1) {
        throw new IllegalStateException("Expected only one function, but found :" + functions.size());
    } else if (functions.size() == 1) {
        return functions.listIterator().next();
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center}

\subsubsection{Wykrywanie sygnatury zadeklarowanej funkcji}

Pierwszym przypadkiem są funkcje jawnie zadeklarowane w kodzie źródłowym nie posiadające modyfikatora \textbf{internal} lub \textbf{private}. Wykrywaniem takiej funkcji zajmuje się metoda \textbf{findFunctionSignature} widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji}. Do wyszukiwania sygnatury zadeklarowanej funkcji zostało wykorzystane wyrażenie regularne zaprezentowane poniżej:

\begin{lstlisting}[numbers=none]
^\s*function\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*([^(){}]*)\s*\)\s*(?!.*(internal|private)).*$
\end{lstlisting}

Pierwsza grupa w wyrażeniu wyciąga z linii kodu źródłowego nazwę funkcji, natomiast druga parametry funkcji. Wyrażenie wyszukuje w pojedynczej linii kodu źródłowego frazy \textbf{function}, po której następuje nazwa funkcji oraz lista parametrów w nawiasach.

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcjizfunkjci} widać metodę wyszukującą sygnaturę funkcji za pomocą przygotowanego wyrażenia regularnego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda odbierająca żądanie o zapisanie kodu źródłowego na serwerze, label=lst:wyszukiwaniesygnaturyfunkcjizfunkjci]
private Optional<SolidityFunction> findFunctionSignature(String line) {
    Matcher matcher = FUNCTION_PATTERN.matcher(line);
    if (matcher.find()) {
        String functionName = matcher.group(FUNCTION_NAME_GROUP_ID);
        String functionArguments = matcher.group(FUNCTION_ARGUMENTS_GROUP_ID);
        String functionSignature = normalizeFunctionSignature(functionName, functionArguments);
        String functionSelector = getFunctionSelector(functionSignature);
        return Optional.of(new SolidityFunction(functionSelector, functionSignature));
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center}

Po wykryciu funkcji za pomocą wyrażenia regularnego wyciągana jest informacja o argumentach oraz nazwie funkcji z przekazanej linii. Metoda \textbf{normalizeFunctionSignature} tworzy sygnaturę funkcji za pomocą listy parametrów i nazwy. Sygnatura składa się z nazwy, nawiasów oraz typów parametrów funkcji. Niektóre typy parametrów zostają sprowadzone do postaci kanonicznej, natomiast pozostałe typy pozostają bez zmian. Poniżej zostały przedstawione typy, które zostają sprowadzane do postaci kanonicznej:


\begin{center}
uint => uint256\\
int => int256\\
byte => bytes1
\end{center}

Po utworzeniu sygnatury funkcji zostaje wygenerowany selektor. Na listingu \ref{lst:metoda_generująca_selektor_funkcji} została przedstawiona metoda tworząca selektor. Sygnatura funkcji zostaje haszowana za pomocą \textbf{SHA3}, następnie z hasza pobierane są cztery pierwsze bajty, które są selektorem funkcji. Metoda \textbf{sha3String} zwraca hasz w systemie szesnastkowym w postaci napisu.  Do tworzenia hasza została wykorzystana biblioteka \textbf{web3j}, która udostępnia metodę \textbf{sha3String}. 

Po pomyślnej identyfikacji zadeklarowanej funkcji zwracany jest obiekt \textbf{Optional<SolidityFunction>}, który przechowuje informacje o sygnaturze oraz selektorze funkcji.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda generująca selektor funkcji, label=lst:metoda_generująca_selektor_funkcji]
private String getFunctionSelector(String normalizedFunctionSignature) {
    return sha3String(normalizedFunctionSignature).substring(2, 10);
}
\end{lstlisting}
\end{center}

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutów typu mapa}

Drugim przypadkiem jest atrybut publiczny typu mapa. Teraz nie jest jawnie pokazane w kodzie źródłowym, że istnieje tutaj sygnatura funkcji, ponieważ jest ona generowana przez kompilator. W tej sekcji przedstawię jak wygenerować sygnaturę funkcji na podstawie takiego atrybutu. W celu sprawdzenia czy dana linia kodu spełnia ten przypadek, zostało wykorzystane wyrażenie regularne przedstawione poniżej:

\begin{lstlisting}[numbers=none]
^\\s*mapping\\s*\\(\\s*([a-zA-Z][a-zA-Z]*)\\s*=>\\s*(.*)\\s*\\)\\s*public\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*(=.*)?\\s*;+\\s*(//.*)?$
\end{lstlisting}


Pierwsza grupa w wyrażeniu regularnym oznacza typ klucza mapowania, natomiast druga typ zwracanej wartości przez mapę. Trzecia grupa jest to nazwa atrybutu. Typ klucza mapowania jest częścią sygnatury funkcji, która będzie w późniejszym etapie tworzona. Jeśli typ zwracany przez mapę jest typem tablicowym lub kolejna mapą wtedy należy dodać kolejny parametr do tworzonej sygnatury funkcji. 

Na listingu \ref{lst:petla_szukajaca_tablic_lub_map} została przedstawiona pętla będąca częścią metody \textbf{findMappingGetter}. Pętla działa dopóki występuje zagnieżdżanie map lub tablica. 

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Pętla wyszukująca tablicę lub mapę w typie zwracanym przez mapę, label=lst:petla_szukajaca_tablic_lub_map]
while (true) {
    Matcher mappingMatcher = MAPPING_PATTERN.matcher(mappingValue);
    Matcher arrayMatcher = ARRAY_PATTERN.matcher(mappingValue);

    if (mappingMatcher.find()) {
        String canonicalArgument = toCanonicalType(mappingMatcher.group(MAPPING_KEY_GROUP_ID));
        canonicalMappingKeys.add(canonicalArgument);
        mappingValue = mappingMatcher.group(MAPPING_VALUE_GROUP_ID);
        continue;
    }
    if (arrayMatcher.find()) {
        String arrayValue = arrayMatcher.group(ARRAY_VALUE_GROUP_ID);
        int dimensionCount = getArrayDimensionCount(arrayValue);
        for (int i = 0; i < dimensionCount; i++) {
           canonicalMappingKeys.add(CANONICAL_ARRAY_KEY_TYPE);
        }
    }
    break;
} 
\end{lstlisting}
\end{center}     

Do wyszukiwania map w typie zwracanym przez mapę zostało wykorzystane kolejne wyrażenie regularne, które widać poniżej:

\begin{lstlisting}[numbers=none]
^\s*mapping\s*\(\s*([a-zA-Z0-9][a-zA-Z0-9]*)\s*=>\s*(.*)\s*\)\s*
\end{lstlisting}

Po wykryciu mapy za pomocą wyrażenia, wykorzystane zostają dwie zdefiniowane w nim grupy. Pierwsza grupa wyciąga z fragmentu deklaracji mapy informacje o typie klucza, natomiast druga o typie zwracanej przez nią wartości. 

Typ klucza zagnieżdżonej mapy jest dodawany do listy typów parametrów generowanej sygnatury funkcji, natomiast typ zwracany przez mapę jest wykorzystany podczas analizy w kolejnej iteracji pętli. Jeśli w danej iteracji pętli nie znaleziono mapy w typie zwracanym przez poprzednia mapę, wtedy będzie to ostatnia iteracja pętli.


Wszystkie typy przed dodaniem do listy parametrów sygnatury funkcji zostają najpierw sprowadzone do postaci kanoniczej.


W przypadku gdy nie wykryto mapy sprawdzane jest, czy zwracanym typem jest tablica. W tym celu wykorzystane zostało następujące wyrażenie regularne:

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*((\s*\[\s*[a-zA-Z0-9]*\s*]\s*)+)\s*
\end{lstlisting}

W wyrażeniu została wykorzystana jedna grupa, która służy do wyznaczenia ilości wymiarów tablicy. Dla każdego wymiaru zostaje dodany parametr typu \textbf{uint256} do listy parametrów sygnatury. Wspomniany parametr reprezentuje indeks tablicy. Wykrycie tablicy w typie zwracanym przez mapę jest równoznaczne z ostatnia iteracja pętli.

Ostatnim krokiem jest wygenerowanie sygnatury funkcji za pomocą nazwy funkcji oraz listy zgromadzonych parametrów. Na listingu \ref{lst:tworzenie_solidity_function} widać w jaki sposób jest formułowana sygnatura funkcji, następnie jest generowany z jej selektor oraz tworzony obiekt typu \textbf{Optional<SolidityFunction>}.


\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Tworzenie SolidityFunction na podstawie nazwy funkcji i listy typów, label=lst:tworzenie_solidity_function]
String functionSignature = mappingName + "(" + join(",", canonicalMappingKeys) + ")";
String functionSelector = getFunctionSelector(functionSignature);
return Optional.of(new SolidityFunction(functionSelector, functionSignature));
\end{lstlisting}
\end{center}   

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutów typu tablicowego}

Trzecia metoda widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} jest metoda \textbf{findArrayGetter}.
Do wykrywania atrybutu będącego tablicą, zostało zastosowane wyrażenie regularne przedstawione poniżej:

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*((\s*\[\s*[a-zA-Z0-9]*\s*]\s*)+)\s*public\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*(=.*)?\s*;+\s*(//.*)?$
\end{lstlisting}

Wyrażenie to wyszukuje w linii kodu źródłowego publiczny atrybut tablicowy. Pierwsza grupa w wyrażeniu wyodrębnia nawiasy definiujące ilość wymiarów tablicy. Następna grupa, znajdująca się po wyrazie \textbf{public}, reprezentuje nazwę atrybutu. Wyrażenie regularne bierze pod uwagę opcjonalną inicjalizację wartości podczas deklaracji.


Liczba wymiarów tablicy zostaje policzona na podstawie liczby podanych nawiasów podczas deklaracji tablicy. Dla każdego wymiaru zostaje dodany typ \textbf{uint256} do listy typów parametrów. Bazując na nazwie oraz liście typów tworzony jest obiekt \textbf{Optional<SolidityFunction>} w analogiczny sposób jaki został przedstawiony na listingu \ref{lst:tworzenie_solidity_function}.

\subsubsection{Wykrywanie sygnatury funkcji dla pozostałych publicznych atrybutów}
    
Ostatnim przypadkiem, który należało rozpatrzyć wykrywania sygnatury funkcji, są wszystkie atrybuty niebędące tablicami lub mapami. Ten przypadek odzwierciedla metoda \textbf{findNormalVariableGetter} widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} jako ostatnia z czterech metod wykorzystywany do analizy linii kodu źródłowego. Zostało zastosowane tutaj wyrażenie regularne przedstawione poniżej: 

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*\s*(\bconstant)*\s*public\s*(\bconstant)*\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*(=.*)?\s*;+\s*(//.*)?$
\end{lstlisting}

Wyrażenie regularne wyszukuje linię w której znajduje się deklaracja atrybutu publicznego, który może opcjonalnie posiadać modyfikator \textbf{constant}. Wyrażenie oczywiście pomija deklarację publicznych tablic lub map. 

Sygnatura funkcji składa się z nazwy atrybutu wyodrębnianej za pomocą grupy zdefiniowanej w wyrażeniu regularnym. W tym przypadku sygnatura funkcji nie ma żadnych parametrów, wiec wystarczy po nazwie dodać pusty nawias. 

Selektor funkcji jest generowany analogicznie jak w pozostałych przypadkach. Na listingu \ref{lst:metoda_nie_tablica_nie_mapa} widać metodę \textbf{findNormalVariableGetter} generującą sygnaturę na podstawie tego rodzaju atrybutu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnature funkcji dla atrybutów niebędących mapą ani tablica, label=lst:metoda_nie_tablica_nie_mapa]
private Optional<SolidityFunction> findNormalVariableGetter(String line) {
    Matcher matcher = NORMAL_VARIABLE_PATTERN.matcher(line);
    if (matcher.find()) {
        LOGGER.info("Found public normal variable: {}", line);
        String variableName = matcher.group(NORMAL_VARIABLE_NAME_GROUP_ID);

        String functionSignature = variableName + "()";
        String functionSelector = getFunctionSelector(functionSignature);

        return Optional.of(new SolidityFunction(functionSelector, functionSignature));
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center} 

Wszystkie wykryte funkcje w poszczególnych liniach implementacji, zostają zapisane w bazie danych wraz z analizowanym kodem źródłowym oraz jego haszem.

\section{Wyszukiwanie selektorów funkcji w kodzie bajtowym}

Literatura: \cite{autor1, autor2}. TODO

\section{Dopasowywanie implementacji na podstawie kodu bajtowego}

Literatura: \cite{autor1, autor2}. TODO

\section{Wykorzystane technologie}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 




%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Bibliografia.
%____________________________________________________________________________________________
\phantomsection
\begin{thebibliography}{99}
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\addcontentsline{toc}{chapter}{Bibliografia}		% Dodanie do spisu treści.

\bibitem{rfc2616} Network Working Group \url{https://www.ietf.org/rfc/rfc2616.txt}
\bibitem{gramatykasolidity} Solidity Grammar \url{https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt}
\bibitem{ethereumyellowpaper} Dr. Gavin Wood \emph{Ethereum: A secure decentralised generalised transaction Ledger. Byzantium version 4e05aa0 - 2019-03-04}. 
\bibitem{soliditydoc} Solidity Documentation - Getter Functions \url{https://solidity.readthedocs.io/en/v0.5.5/contracts.html#getter-functions}

\end{thebibliography}

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage					
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis tabel.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.	
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}		% Dodanie do spisu treści.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis rysunków.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________%____________________________________________________________________________________________
% Spis listingów. 
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\lstlistoflistings
\addcontentsline{toc}{chapter}{Spis listingów} 
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

\end{document}
