

% 1. Należy w programie ustawić zgodne kodowanie, w tym przypadku jest UTF-8. 
% 2. Kompilować ten plik za pomocą pdfLatex.


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Ustawienia pracy.
%____________________________________________________________________________________________

% Obowiązkowo! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definiowanie stylu i formatu pracy.
\documentclass[a4paper,twoside,12pt]{book}	% twoside - dwustronnie		 
\usepackage{polski}		 		% ustawienie języka
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[utf8]{inputenc}	
\usepackage{latexsym}
\usepackage{indentfirst} 				% wcięcia akapitu
\linespread{1.5}					% odstęp między liniami
\usepackage{geometry}
\geometry{lmargin=3.5cm, rmargin=3cm}	% ustawienie marginesów, lewy większy na oprawę

\usepackage{url}
\usepackage{enumerate}				% numeracja
\usepackage{amsopn}
\usepackage{graphicx} 				% grafika
\usepackage{epstopdf}				% grafika formatu eps
\usepackage{tabularx} 				% tabele
\usepackage{hyperref} 				% łącza
\usepackage{picture} 				% rysunki
\usepackage{upgreek}				% greckie symbole

\usepackage{listings}				% listingi
\usepackage{color}					% kolory


 % Polecenie usunięcia paginy na pustej stronie.
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} 	


% Zmiana nazwy rozdziału z listingami, domyślnie jest Listings.
\renewcommand{\lstlistlistingname}{Spis listingów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec



% Dodatkowo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definicje własnych otoczeń.
\theoremstyle{definition}
\newtheorem{dfn}{Definicja}[chapter]
\newtheorem{prz}[dfn]{Przykład}

\theoremstyle{remark}
\newtheorem{wsk}[dfn]{Wniosek}
% koniec


% Definiowanie własnego stylu listingu.
\lstset{
  frame             	= lines,
  basicstyle        	= \linespread{1}\ttfamily,%\small\footnotesize,
  columns           	= fullflexible,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
  breaklines=true,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec	 



\begin{document}

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Strona tytułowa.
%____________________________________________________________________________________________

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother 
% Tutaj wszystko należny wypełnić w nawiasach {}, nic więcej nie zmieniać!

\author{\textbf{Piotr Jasina}}        	% Podaj imię i nazwisko.
\title{Identyfikacja inteligentnych kontraktów w sieci Ethereum}      % Podaj tytuł polski.
\date{{\textbf{Lublin rok \the\year}}}	% Nic nie zmieniaj, rok wygeneruje automatycznie.
\def\engtitle{Ethereum smart contracts identification} % Podaj tytuł angielski.

\def\kierunek{Informatyka}		% Podaj kierunek studiów.
\def\specjalnosc{.....}			% Podaj specjalność, jeśli istnieje.
\def\nralbumu{279183}			% Podaj nr albumu.

\def\rodzaj{licencjacka}			% Podaj rodzaj pracy.
\def\zaklad{Zakładzie Cyberbezpieczeństwa}	% Podaj nazwę zakładu Twojego promotora.
\def\promotor{dr. Damiana Rusinka}	% Podaj promotora.

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Poniżej w {titlepage} nic nie zmieniać.

\renewcommand{\maketitle}{
\begin{titlepage}
\begin{table}
\begin{tabular}{c@{\hspace{10mm}}|@{\hspace{3mm}}l}
\multicolumn{2}{@{\hspace{15mm}}l}{\vspace{-31mm}} \\
\multicolumn{2}{l}{\hspace{-20mm}\includegraphics[scale=0.4]{UMCS}} \\ 
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{7mm}} \\

\multicolumn{2}{@{\hspace{16mm}}l}{\Large UNIWERSYTET MARII CURIE-SKŁODOWSKIEJ} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large W LUBLINIE} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large Wydział Matematyki, Fizyki i Informatyki} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{16mm}} \\

& \multicolumn{1}{m{13cm}}{Kierunek: \kierunek} \\
% Jeśli nie ma specjalności, to należy zakomentować poniższą linijkę!
% & \multicolumn{1}{m{13cm}}{Specjalność: \specjalnosc} \\
& \\
& \multicolumn{1}{m{13cm}}{\@author} \\
& \multicolumn{1}{m{13cm}}{nr albumu: \nralbumu} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{\Large\textbf{\@title}} \\
& \\
& \multicolumn{1}{m{13cm}}{\engtitle} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{Praca \rodzaj} \\	
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{napisana w \zaklad} \\
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{pod kierunkiem \promotor} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\vspace{7mm}} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\@date}
\end{tabular}
\end{table}
\end{titlepage}
}
% koniec 

% Tworzenie strony tytułowej.
\maketitle
% Wyczyszczenie z numeracji strony za stroną tytułową. 
\clearemptydoublepage


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis treści. 
%____________________________________________________________________________________________
\tableofcontents 		
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 	
\clearemptydoublepage			


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Wstęp pracy.
%____________________________________________________________________________________________
\chapter*{Wstęp}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Wstęp} 	% bez numeru w spisie treści

...
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 1.
%____________________________________________________________________________________________
\chapter[Ethereum]{Ethereum}
% W nawiasach [] zapisujemy skróconą nazwę rozdziału, pojawiający się w paginie górnej oraz w spisie treści.
% W nawiasach {} zapisujemy pełną nazwę rozdziału.
% '\protect \\' służy do dzielenia długiej nazwy rozdziału.


Ethereum jest to otwarta platforma oparta o technologie blockchain, która umożliwia użytkownikom tworzenie i uruchamianie zdecentralizowanych aplikacji. Programy tworzone i uruchamiane na blockchain nazywane są też inteligentnymi kontraktami. 

Do uruchamiania aplikacji została stworzona maszyna wirtualna o nazwie \textbf{Ethereum Virtual Machine}, która może wykonywać kod inteligentnego kontraktu o dowolnej złożoność algorytmicznej. Kod aplikacji stworzonej na EVM jest przechowywany na blockchainie utrzymywanym przez jego użytkowników. Programiści mogą tworzyć aplikacje na EVM  za pomocą przyjaznych języków programowania wzorowanych na Pythonie czy JavaScript \cite{whatisethereum}.

Na potrzeby platformy Ethereum stworzono dedykowany język \textbf{Solidity}, który został stworzony z myślą o tworzeniu inteligentnych kontraktów.



 
\section{Historia}

Początki Ethereum zostały opisane przez programistę Vitalika Buterina w 2013 roku, kiedy jeszcze Ethereum nie nazywało się Ethereum. Programista Vitalik w październiku 2013 roku pracował z zespołem Mastercoin. Zaproponował im stworzenie bardziej uogólnionego protokołu, który wspierałby rożne rodzaje umów bez dodawania  kolejnych funkcjonalności. Mastercoin było pod wrażeniem jego pomysłu, natomiast nie byli zainteresowania zmianami w tym kierunku. Vitalik czuł, że jego koncepcja jest słuszna i postanowił iść w tym kierunku. Około drugiego grudnia Vitalik uświadomił sobie, że inteligentne kontrakty, mogą być w pełni uogólnione, a do opisywania ich warunków można zastosować język skryptowy \cite{vitalikethereumprehistory}. 

W grudniu 2013 do zespołu Valika dołączył między innymi Gavin Wood oraz programista klienta w języku Go Jeffrey Wilcke. Latem 2014 roku była już pierwsza stabilna wersja protokołu Ethereum oraz pół formalna specyfikacja w postaci żółtego papieru stworzonego przez Gavina \cite{vitalikethereumprehistory}.


Na początku lipca 2014 Ethereum rozdysponowało początkowy przydział krypto waluty Ether będącej częścią platformy Ethereum. Rozdysponowana wartość wynosiła około 18 milionów dolarów w zamian za ponad 50 milionów eterów. Wyniki sprzedażny zostały początkowo wykorzystane na opłacenie prac programistów oraz na finansowanie ciągłego rozwoju Ethereum \cite{ethersaleastatisticaloverview}. Po wyprzedaży eteru rozwojem Ethereum zajmowała się organizacja non-profit o nazwie ETH DEV, której dyrektorami stali się: Vitalik Buterin, Gavin Wood oraz Jeffrey Wilcke.

W listopadzie 2014 roku ETH DEV zorganizowało w Berlinie wydarzenie \textbf{DEVCON-0}, które przyciągnęło programistów z całego świata interesujących się Ethereum \cite{devcon0}.

Na początku 2015 roku odbyły się audyty bezpieczeństwa przed uruchomieniem, zorganizowane przez między innymi Jutta Steinera. Audyty dotyczyły przede wszystkim implementacji w Go i C++. Przeprowadzony został też mniejszy audyt dotyczący implementacji Vilika nazwanej \textbf{pyethereum}. Kontrola bezpieczeństwa wprowadziła do protokołu kilka małych zmian. Jedną zmianą było wprowadzenie funkcji haszującej \textbf{SHA3} dla klucza i adresu drzewa Trie, która miała zapobiec atakowi DOS \cite{whyethereumusesecuretries}.

Siec \textbf{Ethereum} została uruchomiona 30 lipca 2015 roku. Był to moment, w którym użytkownicy przystąpili do sieci \textbf{Ethereum}, aby uzyskać eter z bloków górniczych. Natomiast programiści zaczęli pisać inteligentne umowy oraz zdecentralizowane aplikacje gotowe do wdrożenia w sieci \textbf{Ethereum}. Była to wersja testowa, ale jak się okazało, była ona bardziej udana, niż ktokolwiek by się tego spodziewał \cite{proceswydaniaethereum}.

Idąc za ciosem, zorganizowano druga konferencje dla programistów nazwaną \textbf{DEVCON-1}, odbyła się ona w Londynie na początku listopada 2015 roku. Konferencja trwała pięć dni, a przedstawiano na niej ponad 100 prezentacji, paneli dyskusyjnych oraz krótkich rozmów. W konferencji wzięło udział ponad 400 uczestników, była to mieszanka przedsiębiorców, myślicieli, programistów oraz przedstawicieli biznesowych. W konferencji brały udział duże firmy jak IBM czy Microsoft, co wyraźnie wskazywało na duże zainteresowanie ta technologia \cite{historyofethereum}. 


\section{Czym jest Ethereum Virtual Machine?}

EVM jest to środowisko uruchomieniowe dla inteligentnych kontraktów opartych o Ethereum. Początkowo wirtualna maszyna została opisana w żółtym dokumencie opracowanym przez dr. Gavina Wooda. Maszyna wirtualna jest całkowicie odizolowana od reszty głównej sieci blockchain, co pomaga w zapewnienia bezpieczeństwa wykonywania niezaufanego kodu przez komputery z całego świata. Każdy węzeł w sieci Ethereum uruchamia u siebie własną implementację EVM oraz jest w stanie wykonywać na niej te same instrukcje co pozostałe węzły. 


\subsection{Kody operacji}

Inteligentne kontrakty napisane w takich językach jak Solidity nie mogą być bezpośrednio wykonane na EVM. W celu wykonania kontraktu należy jego kod skompilować do nisko poziomowych instrukcji. 

EVM wykorzystuje zbiór instrukcji do wykonywania określonych zadań. Operacje te wspólnie umożliwiają stworzenie oprogramowania zupełnego w sensie Turinga.  Operacje wykonywane na EVM można podzielić na siedem kategorii:


\begin{enumerate}
\item \textbf{Operacje wykorzystujące stos} (POP, PUSH, DUP, SWAP) 

\item \textbf{Operacje udostępniające działania arytmetyczne} (ADD, SUB, GT, LT, AND, OR)

\item \textbf{Operacje środowiskowe} (CALLER, CALLVALUE, NUMBER)

\item \textbf{Operacje modyfikujące pamięć ulotna - memory} (MLOAD, MSTORE, MSTORE8, MSIZE)
- jest to przestrzen w ktorej przechowywane sa tymczasowe dane takie jak argumenty funkcji, czy zmienne lokalne. Dane nie sa przechowywane na blockchanie

\item \textbf{Operacje modyfikujące pamięć nieulotna - storage} (SLOAD, SSTORE) - jest to miejsce w którym przechowywane są dane przechowywane na blockchainie. Każdy kontrakt posiada swój oddzielny obszar na blockchain.

\item \textbf{Operacje skoków oraz licznika programu} (JUMP, JUMPI, PC, JUMPDEST)

\item \textbf{Operacje zatrzymujące} (STOP, RETURN, REVERT, INVALID, SELFDESTRUCT)
\end{enumerate}

\subsection{Kod bajtowy}
W celu efektywnego przechowywania operacji są one kodowane do kodu bajtowego. Każda operacja ma przydzielony jeden bajt. Przykładowo operacja PUSH1 wrzuca na stos jeden bajt,  jest ona reprezentowana przez wartość 0x60. Dla kodu bajtowego 0x6080604001, pierwszy bajt to operacja PUSH1. Zgodnie ze specyfikacją opisaną przed Gavina operacja PUSH1 odczytuje kolejny bajt z kodu bajtowego i wrzuca go na stos, w tym przypadku na stos zostanie wrzucona wartość 0x80. Następną operacją jest ponownie PUSH1(0x60), tylko tym razem na stos została wrzucona wartość 0x40 \cite{ethereumyellowpaper}.

Po wykonaniu dwóch pierwszych operacji na stosie powinny znajdować się dwie wartości: 0x80 oraz 0x40. Kolejnym bajtem jest 0x01, który oznacza operacje ADD. Operacja ADD pobiera ze stosu dwie wartości, wykonuje operacje dodawania, po czym wynik wrzuca z powrotem na stos. Na czubku stosu powinna znajdować się wartość 0xC0.
Podczas wykonywania kodu bajtowego jest on dzielony na pojedyncze bajty. Każdy bajt są to dwa znaki reprezentujące liczbę w systemie szesnastkowym \cite{ethereumyellowpaper}.


\section{Do czego służą Inteligentne kontrakty?}

TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 2.
%____________________________________________________________________________________________
\chapter[Solidity]{Solidity}

\section{Sygnatura funkcji}

TODO


\section{Selektor funkcji}

TODO

\section{Generowanie akcesorów podczas kompilacji}

TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 3.
%____________________________________________________________________________________________
\chapter[Projekt Aplikacji]{Projekt Aplikacji}
Celem mojej pracy licencjackiej było stworzenie aplikacji internetowej umożliwiającej identyfikację  inteligentnych kontraktów w sieci \textbf{Ethereum}. Dzięki aplikacji użytkownik po wprowadzeniu na stronie kodu bajtowego kontraktu jest w stanie otrzymać najbardziej prawdopodobną implementacje kontraktu napisana w języku \textbf{Solidity}.

Aplikacja została stworzona przy wykorzystaniu frameworka \textbf{Spring Boot}, modułu \textbf{Spring Data MongoDB} oraz \textbf{Spring MVC}. Natomiast w celu przechowywania danych wykorzystano nierelacyjną bazę danych \textbf{MongoDB}.

W tym rozdziale znajduje się opis funkcjonalności, architektury, implementacji oraz wykorzystanych technologi.
\section{Opis funkcjonalności}


Na stronie głównej aplikacji znajduje się opis wraz z aktualna liczba kodów źródłowych znajdujących się w bazie danych oraz podstawowe definicje związane z aplikacją. Cała aplikacji udostępnia trzy główne funkcjonalności: identyfikację inteligentnych kontraktu, wprowadzanie plików źródłowych kontraktów do aplikacji oraz interfejs programistyczny aplikacji. Wszystkie funkcjonalności zostały opisane poniżej.

\subsection{Identyfikacja inteligentnych kontraktów}
Pierwszą opcją dostępną w  aplikacji jest identyfikacja inteligentnych kontraktów. Zarówno na stronie głównej, jak i podstronie znajduje się pole, w którym można wprowadzić kod bajtowy. Po wprowadzeniu danych użytkownik zatwierdza je, w obu przypadkach klikając przycisk \textbf{Identify}. Przycisk \textbf{Identify bytecode}, służy do przejścia na podstronę związaną z identyfikacją kontraktu.

Po wprowadzeniu danych i zatwierdzeniu ich przyciskiem \textbf{Identify}, aplikacja rozpoczyna proces analizy wprowadzonego kodu bajtowego oraz wyszukiwane są najbardziej prawdopodobne implementacje kontraktu, posortowane malejąco według współczynnika dopasowania. Na rysunku \ref{rys:wynik_identyfikacji} został przedstawiony przykładowy wynik identyfikacji.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.55]{wynik_identyfikacji.png}
\caption{Wynik identyfikacji inteligentnego kontraktu}
\label{rys:wynik_identyfikacji}
\end{figure}

Domyślnie jest wyświetlanych dziesięć najbardziej prawdopodobnych implementacji, po naciśnięciu przycisku \textbf{Get all}, znajdującego się pod listą kontraktów, zostaną wyświetlone wszystkie dopasowania.


Po naciśnięciu w jedną z wyświetlanych implementacji użytkownik zostanie przeniesiony na podstronę umożliwiającą podgląd implementacji. Na rysunku \ref{rys:podglad_impelementacji} znajduje się przykład przeglądania kodu źródłowego na stronie. Rozwiązanie z numerowaniem linii zostało zaimplementowane w taki sposób, aby podczas kopiowania kodu źródłowego ze strony, nie były kopiowane z nim liczby identyfikujące konkretną linię w kodzie. Istnieje też możliwość pobrania kodu źródłowego ze strony z rozszerzeniem \textbf{.sol}


\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{podglad_impelementacji.png}
\caption{Podgląd implementacji}
\label{rys:podglad_impelementacji}
\end{figure}

\subsection{Dodanie kodu źródłowego kontraktu do aplikacji}
Strona umożliwia dodanie własnego kodu źródłowego kontraktu napisanego w języku \textbf{Solidity}. W tym celu należy zalogować się za pomocą panelu logowania, który zostaje wyświetlony automatycznie przy próbie korzystania z autoryzowanych funkcjonalności aplikacji. Po kliknięciu w \textbf{Identify Solidity} oraz zalogowaniu się na stronie, pojawiają się dwie możliwości wprowadzania kodów źródłowych.


Pierwszym sposobem jest przesłanie do aplikacji pliku zawierającego implementacje kontraktu. W tym celu użytkownik powinien nacisnąć przycisk \textbf{Browse} i wybrać konkretny plik, a następnie zatwierdzić go przyciskiem \textbf{Upload} widocznym na rysunku \ref{rys:ekran_pozuploadowaniu}. 


Innym sposobem na przesłania kodu źródłowego do aplikacji jest wklejenie kodu źródłowego bezpośrednio do formularza znajdującego się po prawej części strony internetowej.


Po prawidłowym dodaniu kodu źródłowego do aplikacji użytkownik powinien zobaczyć podobny rezultat do tego na rysunku \ref{rys:ekran_pozuploadowaniu}. W momencie dodania nowej implementacji, na stronie pojawia się hasz dodanego pliku oraz lista sygnatur funkcji wraz z ich selektorami. Po naciśnięciu na wyświetlany na rysunku \ref{rys:ekran_pozuploadowaniu} hasz pliku, użytkownikowi wyświetli się przesłany kod źródłowy.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{ekran_pozuploadowaniu.png}
\caption{Rezultat przesłania inteligentnego kontraktu do aplikacji}
\label{rys:ekran_pozuploadowaniu}
\end{figure}


\subsection{Interfejs programistyczny aplikacji}
Trzecią funkcjonalnością aplikacji jest interfejs programistyczny. Dzięki niemu można wykorzystać mechanizmy zaimplementowane w aplikacji w innej aplikacji. Przykładowym zastosowaniem API jest utworzenie skryptu umożliwiającego zautomatyzowane wysyłanie kodów źródłowych do aplikacji, bez konieczności korzystania z interfejsu graficznego aplikacji \cite{whatisapi}.

Użytkownik za pomocą API ma możliwość pobrania informacji o kodzie źródłowym, identyfikacji kontraktu oraz przesłania nowego kontraktu do aplikacji.


\subsubsection{Pobieranie informacji o kodzie źródłowym z API}

Podczas pobierania informacji o kodzie źródłowym, użytkownik musi posiadać identyfikator pliku, który chce pobrać. Żądanie pobierające plik z API można zobaczyć na listingu \ref{lst:zadanieokodzrodlowy}. W odpowiedzi użytkownik dostaje zwykły tekst zawierający implementację kontraktu oraz status HTTP 200, 404 lub 500. Status 200 oznacza, że wszystko poszło pomyślnie. W sytuacji, gdy użytkownik otrzyma status 404, oznacza to, że nie udało się znaleźć implementacji o podanym haszu. Odpowiedz zawierająca status 500 oznacza, że wystąpił błąd na serwerze i nie udało się zwrócić kodu źródłowego \cite{resthttpstatuscode}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Żądanie wysyłane w celu pobrania kodu źródłowego, label=lst:zadanieokodzrodlowy]
GET /api/sourceCode/0x06c61b8e505d7a407af9a91bdff8085560e90a133c77ab32bde32e686f6a8d52.sol HTTP/1.1
Host: localhost:8080
Accept: text/plain;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
\end{lstlisting}
\end{center}



\subsubsection{Identyfikacja inteligentnego kontraktu za pomocą API}
W celu identyfikacji kontraktu należy wysłać żądanie pod adres \mbox{/api/bytecode}. W ciele żądania jest wymagane od użytkownika podanie dwóch atrybutów o nazwach: \textbf{bytecode} oraz \textbf{allFiles}. Atrybuty przesyłane do API powinny być zakodowane według schematu \mbox{\textbf{nazwa\_atrybutu=wartosc}}, a wszystkie tak przygotowane atrybuty należy połączyć ze sobą pomocą ampersandu. Poprawny przykład żądania można zobaczyć na listingu \ref{lst:identyfikacjaapi} \cite{urlencodedform}.


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Żądanie wysylane w celu identyfikacji kontraktu za pomocą API, label=lst:identyfikacjaapi]
POST /api/bytecode HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

bytecode=60803350200fe56abcede00229&allFiles=false

\end{lstlisting}
\end{center}

Na listingu \ref{lst:identyfikacjaapi} do atrybutu \textbf{bytecode} został wprowadzony kod bajtowy kontraktu. Do zmiennej \textbf{allFiles} została wprowadzona wartość \textbf{false}, wiec w rezultacie zostanie zwrócone przez aplikację dziesięć najbardziej prawdopodobnych implementacji. Jeśli użytkownik chce pobrać wszystkie możliwe dopasowania, należy ustawić tą zmienną na \textbf{true}. W żądaniu został wprowadzony nagłówek \textbf{Content-Length} określający długość przesyłanych danych oraz \textbf{Content-Type} oznaczający rodzaj przesyłanych danych. 


Jeśli wszystko poszło pomyślnie, użytkownik otrzyma status HTTP 200 wraz z listą składającą się z haszu pliku i współczynnika dopasowania danego pliku w formacie \textbf{JSON}. W przypadku gdy nie zostanie dopasowana żadna implementacja, to aplikacja zwróci status 404, natomiast jeśli w aplikacji wystąpi błąd, to zostanie zwrócony status 500.


\subsubsection{Przesyłanie nowego kodu źródłowego za pomocą API}

Gdy użytkownik chce przesłać nowy kontrakt do aplikacji, musi przejść proces uwierzytelniania. W tym celu należy do żądania dodać nagłówek \textbf{Authorization}. W nagłówku należy podać typ autoryzacji oraz zakodowane dane logowania za pomocą \textbf{Base64} według schematu \textbf{login:haslo}. Na przykładzie z listingu \ref{lst:dodaniedoapi} został przesłany kod źródłowy, natomiast do autoryzacji wykorzystano login: 123 oraz hasło: 123.

\begin{center}
\begin{lstlisting}[caption=Przesyłanie kodu źródłowego za pomocą API, label=lst:dodaniedoapi]
POST /api/solidityFiles HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Accept: application/json
Authorization: Basic MTIzOjEyMw==
Content-Length: 221
Accept: application/json

pragma solidity ^0.4.21;
contract Hello {
    string public message;
    function setMessage(string newMessage) public {
        message = newMessage;
    }
}

\end{lstlisting}
\end{center}



Po pomyślnym przesłaniu kontraktu w odpowiedzi od serwera użytkownik otrzymuje status HTTP 200. W odpowiedzi zostaje również przesłany kod źródłowy, hasz stworzony na podstawie kodu źródłowego oraz listę znalezionych sygnatur funkcji wraz z ich selektorami. W przypadku wystąpienia błędu na serwerze zostaje zwrócony status 500. Na listingu \ref{lst:przykladodpowiedzijson} można zaobserwować przykładowe dane zawarte w odpowiedzi od serwera.

\begin{center}
\begin{lstlisting}[caption=Przykładowa odpowiedz w formacie JSON, label=lst:przykladodpowiedzijson]
{
    "sourceCodeHash": "0x8dea780e1286d12a957d40597b9171a5187f87f6e3f8303505bc53a4453ad5b6",
    "sourceCode": "pragma solidity ^0.4.21;\r\ncontract Hello {\r\n    string public message;\r\n    function setMessage(string newMessage) public {\r\n        message = newMessage;\r\n    }\r\n}",
    "solidityFunctions": [
        {
            "selector": "e21f37ce",
            "signature": "message()"
        },
        {
            "selector": "368b8772",
            "signature": "setMessage(string)"
        }
    ]
}
\end{lstlisting}
\end{center}


\section{Przedstawienie architektury}

W tym podrozdziale opiszę architekturę aplikacji, która realizuje funkcjonalności opisane w sekcji 3.1. Poniżej zostały krótko opisane główne klasy będące częścią aplikacji, widoczne na rysunku \ref{rys:architektura}.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.5]{architektura.png}
\caption{Architektura aplikacji}
\label{rys:architektura}
\end{figure}

\begin{description}
\item[LoginController] - jest to klasa odpowiedzialna za wyświetlenie ekranu logowania

\item[ErrorController] - jej zadaniem jest przechwytywane wszystkich błędów w aplikacji. Po złapaniu błędu, zostaje wyświetlona użytkownikowi strona informująca, że pojawił się błąd w aplikacji, który jest zapisywany w logach aplikacji.

\item[BytecodeController] - służy do wyświetlania użytkownikowi strony związanej z identyfikacją kodu bajtowego oraz do mapowania żądań HTTP służących do identyfikacji. 

\item[SolidityApiController] - zadaniem tej klasy jest nasłuchiwanie adresów związanych z API, zwracanie danych do użytkownika w formacie \textbf{JSON} lub zwykłego tekstu oraz komunikowanie się z obiektem klasy \textbf{SolidityService} oraz \textbf{BytecodeService}. 

\item[SolidityController] - mapuje żądania HTTP związane z przetwarzaniem plików \textbf{Solidity} oraz umożliwia wyświetlenie użytkownikowi kodu źródłowego kontraktu.

\item[Disassembler] - odpowiada za analizę przekazanego kodu bajtowego. W rezultacie zwraca listę instrukcji zawartych w kodzie. Szczegółowe działanie tej klasy zostało opisane w dalszej części pracy, w sekcji 3.5 dotyczącej wyszukiwania selektorów funkcji w kodzie bajtowym. 

\item[SolidityParser] - wyciąga listę informacji o funkcjach z kodu źródłowego kontraktu. Lista zawiera takie informacje jak sygnatura oraz selektor funkcji. Sposób tworzenia selektorów funkcji oraz wyciągania z kodu źródłowego sygnatur funkcji został przedstawiony w sekcji 3.4

\item[SolidityService] - jest to klasa odpowiedzialna za odczytywanie danych z bazy danych oraz za przygotowanie przesłanych danych do zapisu w bazie danych.

\item[BytecodeService] - klasa odpowiada za dopasowywanie kodu bajtowego do kontraktu. W tym celu wykorzystywane są opisane powyżej klasy \textbf{Disassembler} oraz \textbf{SolidityService}, które w połączeniu umożliwiają wyznaczenie współczynnika dopasowania pomiędzy konkretnym plikiem a kodem bajtowym.

\item[SolidityFileRepository] - jest to część aplikacji odpowiedzialna za komunikację z bazą danych oraz mapowanie danych przechowywanych w bazie danych na obiekty zdefiniowane w kodzie aplikacji. Repozytorium jest interfejsem, który wykorzystuje moduł \mbox{\textbf{Spring Data MongoDB}}. Implementacja tego interfejsu spoczywa na frameworku Spring. Szczegóły łączenia z bazą danych zostały opisane w sekcji 3.3

\end{description}


\section{Połączenie z bazą danych}
W celu integracji aplikacji z bazą danych \textbf{MongoDB} został wykorzystany framework \textbf{Spring} oraz moduł \textbf{Spring Data MongoDB}. W związku z tym, że projekt aplikacji jest budowany za pomocą narzędzia \textbf{Apache Maven}, należy dodać do pliku \textbf{pom.xml} wykorzystywane moduły \cite{mongoguide}. 

Na listingu \ref{lst:dodaniezaleznosci} został przedstawiony fragment pliku \textbf{pom.xml} odpowiedzialny za dodawanie modułu \mbox{\textbf{spring-boot-start-data-mongodb}} do projektu. Dodawanie innych modułów jest analogiczne do przykładu z listingu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad dodania zależności w pliku pom.xml, label=lst:dodaniezaleznosci]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
\end{lstlisting}
\end{center}

W pliku konfiguracyjnym \mbox{\textbf{application.properties}} zostały skonfigurowane dane do połączenia z bazą danych. Przykładowa zawartość pliku konfiguracyjnego została przedstawiona na listingu \ref{lst:applicationproperties} \cite{mongoguide}.
 
\begin{center}
\begin{lstlisting}[caption=Kofiguracja bazy danych, label=lst:applicationproperties]
spring.data.mongodb.uri=mongodb://${ADMIN_DB_LOGIN}:${ADMIN_DB_PASSWORD}@ds129904.mlab.com:29904/${DATABASE_NAME_CONTRACT}
admin.login=${ADMIN_LOGIN}
admin.password=${ADMIN_PASSWORD}
\end{lstlisting}
\end{center}


Po skonfigurowaniu pliku \mbox{\textbf{pom.xml}} oraz \mbox{\textbf{application.properties}}, należało utworzyć interfejs \mbox{\textbf{SolidityFileRepository}}, który umożliwia serwisom aplikacji wykonywanie operacji na bazie danych oraz ustala mapowanie obiektów z bazy danych na obiekty klasy \mbox{\textbf{SolidityFile}}. Utworzone w aplikacji repozytorium można zobaczyć na listingu \ref{lst:repozytoriummongo}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Stworzenie repozytorium za pomocą Spring Data MongoDB, label=lst:repozytoriummongo]
@Repository
interface SolidityFileRepository extends MongoRepository<SolidityFile, String> {

    @Query("{\"solidityFunctions\": {$elemMatch: {\"selector\": {$in: ?0}}}}")
    List<SolidityFile> findSolidityFilesBySelectorContainsAll(List<String> functionSelector);

    Optional<SolidityFile> findBySourceCodeHash(String sourceCodeHash);
}
\end{lstlisting}
\end{center}

W pierwszej linii listingu \ref{lst:repozytoriummongo} znajduje się adnotacja \mbox{\textbf{@Repository}} pełniącą rolę stereotypu informującego framework, że ten interfejs jest wykorzystywany, w celu wykonywania operacji z bazą danych.

Kolejną adnotacją jest \mbox{\textbf{@Query}}. Parametrem tej adnotacji jest zapytanie do bazy danych \textbf{MongoDB}, wykonujące zapytanie o listę plików, które posiadają w sobie część przekazanych przez użytkownika selektorów funkcji. Za pomocą tej adnotacji można przypisać konkretnej metodzie z \mbox{\textbf{SolidityFileRepository}} konkretne zapytanie, które aplikacja ma wykonać.

Jeśli metoda w interfejsie nie posiada wspomnianej adnotacji, wtedy framework wygeneruje zapytanie do bazy danych, bazując na nazwie metody oraz przyjmowanych i zwracanych przez metodę typach danych.

Na listingu \ref{lst:przykladencji} została przedstawiona klasa \mbox{\textbf{SolidityFile}}, która reprezentuje obiekt przechowywany w bazie danych. Składa się ona z trzech atrybutów: haszu kodu źródłowego, kodu źródłowego, oraz listy funkcji znalezionych w tym kodzie źródłowym. 


Atrybut \textbf{sourceCodeHash} został utworzony, ponieważ baza danych nie umożliwia utworzenia unikalnego atrybutu w bazie danych z taką duża ilością znaków jak kod źródłowy. Tworzeniem haszu odbywa się w klasie \mbox{\textbf{SolidityService}} widocznej się na rysunku \ref{rys:architektura}. Hasz kodu źródłowego jest identyfikatorem, wiec posiada adnotację \mbox{\textbf{@Id}}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Przyklad klasy wykorzystywanej przez Spring Data MongoDb, label=lst:przykladencji]
public class SolidityFile {
    @Id
    private final String sourceCodeHash;
    private final String sourceCode;
    private final Set<SolidityFunction> solidityFunctions;

    SolidityFile(String sourceCodeHash, String sourceCode, Set<SolidityFunction> solidityFunctions) {
        requireNonNull(sourceCodeHash, "Expected not-null sourceCodeHash");
        requireNonNull(sourceCode, "Expected not-null sourceCode");
        requireNonNull(solidityFunctions, "Expected not-null solidityFunctions");
        this.sourceCodeHash = sourceCodeHash;
        this.sourceCode = sourceCode;
        this.solidityFunctions = solidityFunctions;
    }

    public String getSourceCodeHash() { return sourceCodeHash; }
    public String getSourceCode() { return sourceCode; }
    public Set<SolidityFunction> getSolidityFunctions() { return solidityFunctions; }

    @Override
    public String toString() {
        return "SolidityFile{" + "sourceCodeHash='" 
                 + sourceCodeHash
        	 + '\'' + ", sourceCode='" + sourceCode + '\'' 
        	 + ", solidityFunctions=" + solidityFunctions + '}';}

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SolidityFile)) return false;
        SolidityFile that = (SolidityFile) o;
        return Objects.equals(sourceCodeHash, that.sourceCodeHash) &&
                Objects.equals(sourceCode, that.sourceCode) &&
                Objects.equals(solidityFunctions, that.solidityFunctions);}

    @Override
    public int hashCode() {
        return Objects.hash(sourceCodeHash, sourceCode, solidityFunctions);}
}
\end{lstlisting}
\end{center}

W momencie tworzenia obiektu klasy \textbf{SolidityFile}, konstruktor wywołuje metody sprawdzające, czy użytkownik nie wprowadził wartości \textbf{null}, ponieważ każdy obiekt plik musi posiadać hasz, kod źródłowy oraz listę funkcji.

Klasa \textbf{SolidityFunction}, która jest częścią klasy \textbf{SolidityFile}, posiada dwa atrybuty \textbf{selector} oraz \textbf{signature} typu \textbf{String}. Klasa ta nie wy wymagała tworzenia identyfikatora, wiec nie została użyta adnotacja \mbox{\textbf{@Id}} nad żadnym atrybutem.


\section{Identyfikacja sygnatur funkcji w kodzie źródłowym}


Wyszukiwanie sygnatur funkcji jest rozpoczynane podczas przesłania nowego kodu źródłowego do aplikacji. W momencie wyszukiwania sygnatur funkcji są generowane selektory funkcji, które są finalnie używane podczas identyfikacji kodu bajtowego. 

Problemem podczas wyszukiwania sygnatur w kodzie źródłowym jest to, że część sygnatur jest niejawna, ponieważ są one dodatkowo generowane przez kompilator \textbf{Ethereum Virtual Machine} dla wybranych atrybutów kontraktu \cite{soliditygetterfunction}. 


\subsection{Kontroler interfejsu programistycznego}

Na listingu \ref{lst:kontrolerapiupload} została przedstawiona metoda kontrolera \textbf{SolidityApiController} umożliwiająca przesyłanie kodu źródłowego. Adnotacje, które wykorzystuje ta metoda, są częścią modułu \textbf{Spring MVC}. Pierwszą adnotacją wykorzystaną w metodzie jest \textbf{@PostMapping}, która zajmuje się mapowaniem żądań HTTP przesyłanych do API. W parametrze tej adnotacji podany został adres, pod którym aplikacja oczekuje żądania \cite{springmvc}. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda kontrolera mapująca żądania POST, label=lst:kontrolerapiupload]
@PostMapping("/api/solidityFiles")
public ResponseEntity<SolidityFile> uploadFile(@RequestBody String sourceCode) throws IOException {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    return ResponseEntity.ok(solidityService.save(sourceCode));
}
\end{lstlisting}
\end{center}

Kolejną adnotacją jest \mbox{\textbf{@RequestBody}}. Adnotacja ta informuje framework o tym, żeby ciało żądania HTTP było umieszczone pod wskazaną zmienną. 

Podczas zwracania danych w API wykorzystana została klasa \textbf{ResponseEntity}. Jest to wrapper umożliwiający zwrócenie statusu HTTP wraz z danymi. Informacja z tej klasy jest wykorzystywana przez framework podczas tworzenia odpowiedzi HTTP.

Głównym celem tej metody jest zapisanie nowego kodu źródłowego do aplikacji, w związku z tym na listingu \ref{lst:kontrolerapiupload} widać wywołanie metody \textbf{save} na atrybucie \mbox{\textbf{solidityService}}.


\subsection{Kontroler strony internetowej}

\textbf{SolidityControler} jest to klasa odpowiedzialna, za tworzenie strony internetowej korzystając z szablonów HTML oraz modułu \textbf{Thymeleaf}. Listing \ref{lst:uploadowanie} przedstawia metodę przyjmująca w żądaniu HTTP kod źródłowy. Metoda ta działa podobnie jak w przypadku API, tylko w tym przypadku zwracana zostaje zwrócona nazwa szablonu wykorzystywanego do renderowania strony. Istnieje możliwość przekazania danych do szablonu, w tym celu wykorzystywany jest parametr \textbf{model}, na którym wywoływana jest metoda \textbf{addAttribute} \cite{thymeleafguide}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Przechwytywanie żądania o dodanie nowego kodu źródłowego, label=lst:uploadowanie]
@PostMapping("/solidity/text")
public String handleSourceCodeUpload(@RequestParam("sourceCode") String sourceCode, Model model) throws Exception {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    requireNonNull(model, "Expected not-null model");

    SolidityFile savedSolidityFile = solidityService.save(sourceCode);

    model.addAttribute("solidityFileFunctions", savedSolidityFile.getSolidityFunctions());
    model.addAttribute("solidityFileHash", savedSolidityFile.getSourceCodeHash());
    return "solidity-page";
}
\end{lstlisting}
\end{center}

\subsection{Przetwarzanie kodu źródłowego}

\textbf{SolidityService} po otrzymaniu kodu źródłowego od kontrolerów przekazuje po jednej linii do  \textbf{SolidityParser}, który definiuje czy w danej linii jest sygnatura funkcji. Jeśli podczas parsowania linii znaleziono sygnaturę funkcji, to zostaje ona dodana wraz z selektorem do listy funkcji. Po przeanalizowaniu wszystkich linii tworzony jest obiekt \textbf{SolidityFile}, który następnie za pomocą \textbf{SolidityFileRepository} jest zapisywany do bazy danych.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnatury funkcji, label=lst:wyszukiwaniesygnaturyfunkcji]
Optional<SolidityFunction> findFunctionInLine(String line) {
    List<Optional<SolidityFunction>> functions =
            Stream.of(
                    findFunctionSignature(line),
                    findMappingGetter(line),
                    findArrayGetter(line),
                    findNormalVariableGetter(line)
            ).filter(Optional::isPresent).collect(toList());

    if (functions.size() > 1) {
        throw new IllegalStateException("Expected only one function, but found :" + functions.size());
    } else if (functions.size() == 1) {
        return functions.listIterator().next();
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center}

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} widać metodę klasy \textbf{SolidityParser} wyszukującą funkcję w implementacji kontraktu. Metoda po przyjęciu linii w rezultacie zwraca obiekt klasy \textbf{Optional<SolidityFunction>} \cite{baeldungoptional}. Metoda sprawdza cztery możliwe przypadki, w których istnieje możliwość wykrycia funkcji w kodzie źródłowym kontraktu.

Do wykrywania błędów podczas wyszukiwania funkcji sprawdzane są wszystkie cztery przypadki, jeśli okaże się, że więcej niż jedna metoda wykryła funkcję, oznacza to, że jedna z metod działa niepoprawnie i fałszywie wykrywa funkcje. Wszystkie cztery przypadki zostały opisane poniżej.


\subsubsection{Wykrywanie sygnatury zadeklarowanej funkcji}

Pierwszym przypadkiem są funkcje jawnie zadeklarowane w kodzie źródłowym nie posiadające modyfikatora \textbf{internal} lub \textbf{private}. Wykrywaniem takiej funkcji zajmuje się metoda \textbf{findFunctionSignature} widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji}. Do wyszukiwania sygnatury zadeklarowanej funkcji zostało wykorzystane wyrażenie regularne zaprezentowane poniżej:

\begin{lstlisting}[numbers=none]
^\s*function\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*([^(){}]*)\s*\)\s*(?!.*(internal|private)).*$
\end{lstlisting}

Pierwsza grupa w wyrażeniu wyciąga z linii kodu źródłowego nazwę funkcji, natomiast druga parametry funkcji. Wyrażenie wyszukuje w pojedynczej linii kodu źródłowego frazy \textbf{function}, po której następuje nazwa funkcji oraz lista parametrów w nawiasach \ref{soliditygrammar}.

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcjizfunkjci} została przedstawiona metoda wyszukującą sygnaturę funkcji za pomocą przedstawionego wyrażenia regularnego.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda odbierająca żądanie o zapisanie kodu źródłowego na serwerze, label=lst:wyszukiwaniesygnaturyfunkcjizfunkjci]
private Optional<SolidityFunction> findFunctionSignature(String line) {
    Matcher matcher = FUNCTION_PATTERN.matcher(line);
    if (matcher.find()) {
        String functionName = matcher.group(FUNCTION_NAME_GROUP_ID);
        String functionArguments = matcher.group(FUNCTION_ARGUMENTS_GROUP_ID);
        String functionSignature = normalizeFunctionSignature(functionName, functionArguments);
        String functionSelector = getFunctionSelector(functionSignature);
        return Optional.of(new SolidityFunction(functionSelector, functionSignature));
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center}

Po wykryciu funkcji za pomocą wyrażenia regularnego wyciągana jest informacja o parametrach i nazwie funkcji z przekazanej linii. Za pomocą wyciągniętych informacji metoda \textbf{normalizeFunctionSignature} tworzy sygnaturę funkcji. Sygnatura składa się z nazwy oraz typów parametrów funkcji podanych w nawiasie. Niektóre typy parametrów zostają sprowadzone do postaci kanonicznej, natomiast pozostałe typy pozostają bez zmian. Poniżej zostały przedstawione typy, które zostają sprowadzane do postaci kanonicznej:


\begin{center}
uint => uint256\\
int => int256\\
byte => bytes1
\end{center}

Po utworzeniu sygnatury funkcji zostaje wygenerowany selektor. Na listingu \ref{lst:metoda_generująca_selektor_funkcji} została przedstawiona metoda tworząca selektor. Sygnatura funkcji zostaje haszowana za pomocą funkcji \textbf{sha3String}, ktora pochodzi z biblioteki \textbf{web3j}, następnie z hasza pobierane są cztery pierwsze bajty, które są selektorem funkcji. Metoda \textbf{sha3String} zwraca hasz w systemie szesnastkowym w postaci napisu, dlatego wyłuskiwane są znaki od dwa do dziesięć. 

\begin{center}
\lstset{language=java}
\begin{lstlisting}[caption=Metoda generująca selektor funkcji, label=lst:metoda_generująca_selektor_funkcji]
private String getFunctionSelector(String normalizedFunctionSignature) {
    return sha3String(normalizedFunctionSignature).substring(2, 10);
}
\end{lstlisting}
\end{center}

Po pomyślnej identyfikacji zadeklarowanej funkcji zwracany jest obiekt \textbf{Optional<SolidityFunction>} przez metodę \textbf{findFunctionSignature}. Analizując w ten sposób każdą linię kodu źródłowego kontraktu, \textbf{SolidityService} uzyskuje zbiór obiektów \textbf{SolidityFunction}.

\subsubsection{Generowanie sygnatury funkcji dla publicznych atrybutów typu mapa}

Drugim rodzajem jest atrybut publiczny typu \textbf{mapping}. W tym przypadku nie zostało jawnie pokazane, że istnieje w kodzie źródłowym sygnatura funkcji, ponieważ jest ona generowana przez kompilator \cite{soliditygetterfunction}. W tej sekcji przedstawię proces generowania sygnatury funkcji na podstawie wspomnianego atrybutu. 

W celu wykrycia deklaracji mapy w kodzie źródłowym, zostało wykorzystane wyrażenie regularne przedstawione poniżej:

\begin{lstlisting}[numbers=none]
^\\s*mapping\\s*\\(\\s*([a-zA-Z][a-zA-Z]*)\\s*=>\\s*(.*)\\s*\\)\\s*public\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*(=.*)?\\s*;+\\s*(//.*)?$
\end{lstlisting}


Pierwsza grupa w wyrażeniu regularnym oznacza typ klucza mapy, natomiast druga typ zwracanej wartości przez mapę. Trzecia grupa oznacza nazwę atrybutu, która również jest nazwa sygnatury funkcji. Typ klucza mapowania jest umieszczany w parametrze tworzonej sygnatury funkcji. Jeśli typ zwracany przez mapę jest typem tablicowym lub kolejną mapą, wtedy należy dodać kolejny parametr do sygnatury funkcji. 

Na listingu \ref{lst:petla_szukajaca_tablic_lub_map} została przedstawiona pętla, która jest częścią metody \textbf{findMappingGetter}. Pętla działa dopóki występuje zagnieżdżanie map. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Pętla wyszukująca tablicę lub mapę w typie zwracanym przez mapę, label=lst:petla_szukajaca_tablic_lub_map]
while (true) {
    Matcher mappingMatcher = MAPPING_PATTERN.matcher(mappingValue);
    Matcher arrayMatcher = ARRAY_PATTERN.matcher(mappingValue);

    if (mappingMatcher.find()) {
        String canonicalArgument = toCanonicalType(mappingMatcher.group(MAPPING_KEY_GROUP_ID));
        canonicalMappingKeys.add(canonicalArgument);
        mappingValue = mappingMatcher.group(MAPPING_VALUE_GROUP_ID);
        continue;
    }
    if (arrayMatcher.find()) {
        String arrayValue = arrayMatcher.group(ARRAY_VALUE_GROUP_ID);
        int dimensionCount = getArrayDimensionCount(arrayValue);
        for (int i = 0; i < dimensionCount; i++) {
           canonicalMappingKeys.add(CANONICAL_ARRAY_KEY_TYPE);
        }
    }
    break;
} 
\end{lstlisting}
\end{center}     

Do wyszukiwania map w typie zwracanym przez poprzednią mapę zostało wykorzystane następujące wyrażenie regularne:

\begin{lstlisting}[numbers=none]
^\s*mapping\s*\(\s*([a-zA-Z0-9][a-zA-Z0-9]*)\s*=>\s*(.*)\s*\)\s*
\end{lstlisting}

Pierwsza grupa wyrażenia wyciąga z fragmentu deklaracji mapy informacje o typie klucza, natomiast druga o typie zwracanej przez nią wartości.
Typ klucza zagnieżdżonej mapy jest dodawany do listy typów parametrów generowanej sygnatury funkcji, natomiast typ zwracany przez mapę jest wykorzystany z tym samym wyrażeniem regularnym w kolejnej iteracji pętli. 

W przypadku, gdy nie wykryto mapy, jest sprawdzane, czy zwracanym typem jest tablica. W tym celu wykorzystane zostało następujące wyrażenie regularne:

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*((\s*\[\s*[a-zA-Z0-9]*\s*]\s*)+)\s*
\end{lstlisting}

W wyrażeniu została określona grupa, która służy do wyznaczenia ilości wymiarów tablicy. Dla każdego wymiaru zostaje dodany parametr typu \textbf{uint256} do listy parametrów sygnatury. Wspomniany parametr reprezentuje indeks tablicy. Wykrycie tablicy w typie zwracanym przez mapę jest równoznaczne z ostatnią iteracja pętli.

Ostatnim krokiem jest wygenerowanie sygnatury funkcji za pomocą nazwy funkcji oraz listy zgromadzonych typów parametrów. Wszystkie typy przed dodaniem do listy zostają najpierw sprowadzone do postaci kanoniczej.

Na listingu \ref{lst:tworzenie_solidity_function} widać w jaki sposób jest formułowana sygnatura funkcji, następnie jest generowany z jej selektor oraz tworzony obiekt typu\\ \textbf{Optional<SolidityFunction>}.


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Tworzenie SolidityFunction na podstawie nazwy funkcji i listy typów, label=lst:tworzenie_solidity_function]
String functionSignature = mappingName + "(" + join(",", canonicalMappingKeys) + ")";
String functionSelector = getFunctionSelector(functionSignature);
return Optional.of(new SolidityFunction(functionSelector, functionSignature));
\end{lstlisting}
\end{center}   

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutów typu tablicowego}

Trzecią metodą widoczną na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} jest \textbf{findArrayGetter}. Metoda służy do wykrywania publicznego atrybutu, który jest tablicą i w tym celu wykorzystuje wyrażenie regularne przedstawione poniżej:


\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*((\s*\[\s*[a-zA-Z0-9]*\s*]\s*)+)\s*public\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*(=.*)?\s*;+\s*(//.*)?$
\end{lstlisting}

Wyrażenie to wyszukuje w linii kodu źródłowego publiczny atrybut tablicowy. Pierwsza grupa w wyrażeniu wyodrębnia nawiasy definiujące ilość wymiarów tablicy. Kolejna grupa, znajdująca się po wyrazie \textbf{public}, reprezentuje nazwę atrybutu. Wyrażenie regularne bierze pod uwagę możliwość inicjalizacji wartości podczas deklaracji atrybutu.


Liczba wymiarów tablicy zostaje określona na podstawie liczby podanych nawiasów podczas deklaracji tablicy. Dla każdego wymiaru zostaje dodany typ \textbf{uint256} do listy typów parametrów, ponieważ tablica posiada numeryczny indeks \cite{solidityarrayindex}.

 Bazując na nazwie oraz liście typów tworzony jest obiekt\\ \textbf{Optional<SolidityFunction>} w analogiczny sposób, jaki został przedstawiony na listingu \ref{lst:tworzenie_solidity_function}.

\subsubsection{Wykrywanie sygnatury funkcji dla pozostałych publicznych atrybutów}
    
Ostatnim przypadkiem, który należało rozpatrzyć podczas wykrywania sygnatury funkcji, są wszystkie atrybuty zadeklarowane jako publiczne niebędące tablicami lub mapami. Ten przypadek odzwierciedla metoda \textbf{findNormalVariableGetter} widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} jako ostatnia z czterech metod wykorzystywany do analizy linii kodu źródłowego. Zostało zastosowane tutaj wyrażenie regularne przedstawione poniżej: 

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*\s*(\bconstant)*\s*public\s*(\bconstant)*\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*(=.*)?\s*;+\s*(//.*)?$
\end{lstlisting}

Wyrażenie regularne wyszukuje linię, w której znajduje się deklaracja atrybutu publicznego, który może opcjonalnie posiadać modyfikator \textbf{constant}. Wyrażenie deklaracje atrybutow bez typu \textbf{mapping} oraz tablic. 

Sygnatura funkcji składa się z nazwy atrybutu wyodrębnianej za pomocą grupy zdefiniowanej w wyrażeniu regularnym. W tym przypadku sygnatura funkcji nie posiada żadnych parametrów, wiec wystarczy po nazwie dodać pusty nawias. 

Selektor funkcji jest generowany analogicznie jak w pozostałych przypadkach. Na listingu \ref{lst:metoda_nie_tablica_nie_mapa} widać metodę \textbf{findNormalVariableGetter} generującą sygnaturę na podstawie tego rodzaju atrybutu.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnature funkcji dla atrybutów niebędących mapą ani tablica, label=lst:metoda_nie_tablica_nie_mapa]
private Optional<SolidityFunction> findNormalVariableGetter(String line) {
    Matcher matcher = NORMAL_VARIABLE_PATTERN.matcher(line);
    if (matcher.find()) {
        LOGGER.info("Found public normal variable: {}", line);
        String variableName = matcher.group(NORMAL_VARIABLE_NAME_GROUP_ID);

        String functionSignature = variableName + "()";
        String functionSelector = getFunctionSelector(functionSignature);

        return Optional.of(new SolidityFunction(functionSelector, functionSignature));
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center} 

Wszystkie wykryte funkcje w poszczególnych liniach implementacji, zostają zapisane w bazie danych wraz z analizowanym kodem źródłowym oraz jego haszem.

\section{Wyszukiwanie selektorów funkcji w kodzie bajtowym}


Podczas identyfikacji inteligentnego kontraktu podawany jest kod bajtowy, który posiada w sobie informacje selektory funkcji. Następnie na podstawie selektorów funkcji zawartych w kodzie bajtowym, zostają dopasowane implementacje inteligentnych kontraktów przechowywane w bazie danych. 

W tym podrozdziale przedstawię, w jaki sposób na podstawie kodu bajtowego są wyszukiwane selektory funkcji wykorzystywane podczas dopasowywania implementacji.


W celu wykrycia selektorów funkcji należy najpierw uzyskać listę instrukcji wykonywanych w kodzie bajtowym wraz z parametrami tych instrukcji. Do tego posłuży klasa \textbf{Dissassembler}, do której jest przekazywany kod bajtowy za pomocą metody \textbf{dissassembly} . W rezultacie wspomnianej metody zwracana jest lista instrukcji reprezentowanych przez klase \textbf{Instruction}. Klasa \textbf{Instruction} składa się z dwóch atrybutów: \textbf{opcode} typu \textbf{Opcode} oraz \textbf{hexParameters} typu \textbf{String}.

\subsection{Reprezentacja operacji EVM wewnątrz aplikacji}

\textbf{Opcode} jest to typ wyliczeniowy, który definiuje wszystkie kody operacji, jakie można wykonać na \textbf{Ethereum Virtual Machine}. Wszystkie te operacje zostały opisane w dokumencie definiującym \textbf{EVM} \cite{ethereumyellowpaper}.


Typ wyliczeniowy posiada w sobie trzy atrybuty: \textbf{hexValue}, \textbf{operandSize} oraz \textbf{description}, które są przekazywane w konstruktorze. Na listingu \ref{lst:fragment_opcodow} widać fragment deklaracji poszczególnych operacji. Pierwszym parametrem konstruktora jest \textbf{hexValue}, czyli kod operacji w postaci szesnastkowej. Następnie podawany jest \textbf{operandSize}, który określa rozmiar parametru danej operacji za pomocą liczby bajtów. Ostatnią przekazywaną informacją jest opis operacji.


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Fragment kodu źródłowego definiującego kody operacji w typie wyliczeniowym, label=lst:fragment_opcodow]
...
MSIZE(0x59, 0, "Get the size of active memory in bytes."),
GAS(0x5A, 0, "Get the amount of available gas, including the corresponding reduction the amount of available gas."),
JUMPDEST(0x5B, 0, "Mark a valid destination for jumps."),

PUSH1(0x60, 1, "Place 1 byte item on stack."),
PUSH2(0x61, 2, "Place 2-byte item on stack."),
PUSH3(0x62, 3, "Place 3-byte item on stack."),
...
\end{lstlisting}
\end{center} 

Ponieważ kod bajtowy przechowuje kody operacji oraz ich parametry w postaci szesnastkowej, w tym celu została utworzona klasa \textbf{OpcodeTable}, która umożliwia mapowanie kodu operacji na konkretny obiekt zdefiniowany w typie wyliczeniowym \textbf{Opcode}. Klasa \textbf{OpcodeTable} została zaprezentowana na listingu \ref{lst:mapowanie_na_opcode}. W przypadku, gdy podany kod nie posiada swojego odpowiednika w typie wyliczeniowym, wtedy zostaje zwrócony kod \textbf{UNKNOWNCODE}. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Klasa mapujaca identyfikator operacji na reprezentacje operacji typu wyliczeniowego, label=lst:mapowanie_na_opcode]
class OpcodeTable {
    private OpcodeTable() {
        throw new UnsupportedOperationException();
    }

    private static final Map<Integer, Opcode> opcodes =
            unmodifiableMap(new HashMap<Integer, Opcode>() {{
                for (Opcode opcode : Opcode.values()) {
                    put(opcode.getHexValue(), opcode);
                }
            }});

    static Opcode getOpcodeByHex(String stringHex) {
        if(stringHex.length() != 2){
            throw new IllegalArgumentException("Expected length=2 stringHex");
        }
        return getOpcodeByHex(Integer.parseInt(stringHex, 16));
    }

    static Opcode getOpcodeByHex(int hex) {
        Opcode opcode = opcodes.get(hex);
        if (isNull(opcode)) {
            return Opcode.UNKNOWNCODE;
        }
        return opcode;
    }
}
\end{lstlisting}
\end{center} 

\subsection{Odczytywanie instrukcji z kodu bajtowego}

Mając zdefiniowane w aplikacji wszystkie operacje maszyny wirtualnej \textbf{Ethereum}, można przystąpić do wyszukiwania wszystkich instrukcji z kodu bajtowego. Na listingu \ref{lst:metoda_wyszukujaca_instrukcje} widać metodę przestawiającą ten proces. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukująca instrukcje instrukcje w kodzie bajtowym, label=lst:metoda_wyszukujaca_instrukcje]
private List<Instruction> getInstructions(String bytecode) {
    String validBytecode = getValidBytecode(bytecode);
    HexStringIterator hexStringIterator = new HexStringIterator(validBytecode);

    List<Instruction> instructions = new ArrayList<>();
    while (hexStringIterator.hasNext()) {
        Opcode opcode = getOpcodeByHex(hexStringIterator.next());
        String instructionParameter = getInstructionOperand(opcode.getOperandSize(), hexStringIterator);
        instructions.add(new Instruction(opcode, instructionParameter.toLowerCase()));
    }
    return instructions;
} 
\end{lstlisting}
\end{center} 

Do iteracji po kodzie bajtowym został wykorzystany iterator typu \textbf{HexStringIterator}, który odczytuje po jednym bajcie, dopóki istnieją kolejne bajty. W każdej iteracji pętli jest definiowany konkretny obiekt typu \textbf{Opcode} za pomocą metody \textbf{getOpcodeByHex} przedstawionej na listingu \ref{lst:mapowanie_na_opcode}. Następnie w zależności od kodu operacji zostają pobierane kolejne bajty, które są parametrem instrukcji \cite{ethereumyellowpaper}. Na podstawie tych informacji tworzony jest obiekt typu \textbf{Instruction}, który jest dodawany do listy \textbf{instructions}, zwracanej na końcu wykonywania metody.


\subsection{Wyszukiwanie selektorów funkcji z listy instrukcji}

Po wykryciu wszystkich operacji wraz z ich parametrami przez klase Disassembly, klasa BytecodeService moze przystapic w wyszukiwania ostatecznych selektorow funkcji. 

Na listingu \ref{lst:metoda_wyszukujaca_selektory} została przedstawiona metoda zwracająca listę selektorów funkcji znajdujących się w kodzie bajtowym. Odczytując z listy po trzy kolejne instrukcje, zostaje wyszukiwany schemat operacji wykonywanych na \textbf{EVM}, na podstawie którego aplikacja wyszukuje moment wrzucenia selektora funkcji na stos \cite{deconstructingsmartcontract}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukująca selektory funkcji na podstawie listy instrukcji, label=lst:metoda_wyszukujaca_selektory]
private List<String> findFunctionSelectors(String bytecode) {
    List<Instruction> instructions = disassembler.disassembly(bytecode);
    List<String> functionSelectors = new ArrayList<>();
    for (int i = 0; i < instructions.size() - 2; i++) {
        Instruction first = instructions.get(i);
        Instruction second = instructions.get(i + 1);
        Instruction third = instructions.get(i + 2);
        boolean isFunctionSchemeFound =
                first.hasMnemonic(PUSH_4_MNEMONIC) && second.hasMnemonic(EQ_MNEMONIC) && third.hasMnemonic(PUSH_2_MNEMONIC);
        if (isFunctionSchemeFound) {
            functionSelectors.add(first.getHexParameters());
        }
    }
    return functionSelectors;
}
\end{lstlisting}
\end{center}

Gdy zmienna \textbf{isFunctionSchemeFound} przechowuje wartość \textbf{true}, wtedy wiadomo, że został wyszukany charakterystyczny dla selektorów funkcji schemat kodów operacji. W takim przypadku pobierany jest parametr ze zmiennej \textbf{first} oraz dodawany jest on do listy \textbf{functionSelectors}.

\section{Dopasowywanie implementacji na podstawie kodu bajtowego}
Ostatnia rzeczą zwieńczającą cały projekt aplikacji jest dopasowywanie najbardziej prawdopodobnej implementacji na podstawie posiadanego kodu bajtowego oraz potencjalnie jak najbardziej uzupełnionej bazy danych plików. 


Do wyznaczania procentowego dopasowania kodu bajtowego do implementacji można było zastosować kilka podejść. Każde z nim posiada swoje wady i zalety, które zostały przedstawione poniżej.

\section{Wykorzystane technologie}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 




%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Bibliografia.
%____________________________________________________________________________________________
\phantomsection
\begin{thebibliography}{99}
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\addcontentsline{toc}{chapter}{Bibliografia}		% Dodanie do spisu treści.


\bibitem{whatisethereum} \url{http://ethdocs.org/en/latest/introduction/what-is-ethereum.html}
\bibitem{vitalikethereumprehistory} Vitalik Buterin \emph{A Prehistory of the Ethereum Protocol} \url{https://vitalik.ca/2017-09-15-prehistory.html}
\bibitem{ethersaleastatisticaloverview} Ethereum Blog \emph{Ether Sale: A Statistical Overview } \url{https://blog.ethereum.org/2014/08/08/ether-sale-a-statistical-overview/}
\bibitem{devcon0} Ethereum \emph{DEVCON-8 recap} \url{https://blog.ethereum.org/2014/12/05/d%CE%BEvcon-0-recap/}
\bibitem{whyethereumusesecuretries} Seung Woo Kim \emph{Secure Tree: Why State Tries Key is 256 Bits} \url{https://medium.com/codechain/secure-tree-why-state-tries-key-is-256-bits-1276beb68485}
\bibitem{ethereumyellowpaper} Dr. Gavin Wood \emph{Ethereum: A secure decentralised generalised transaction Ledger. Byzantium version 4e05aa0 - 2019-03-04}.
\bibitem{historyofethereum} Ethereum Homestead \emph{History of Ethereum } \url{https://ethereum-homestead.readthedocs.io/en/latest/introduction/history-of-ethereum.html}
\bibitem{proceswydaniaethereum} Ethereum \emph{Ethereum Launch Process} \url{https://ethereum.github.io/blog/2015/03/03/ethereum-launch-process/}



\bibitem{soliditygrammar} Ethereum \emph{Solidity Grammar} \url{https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt}
\bibitem{deconstructingsmartcontract} Alejandro Santander \emph{Deconstructing a Solidity Contract} \url{https://blog.zeppelin.solutions/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737}. 
\bibitem{reversingethereumsmartcontract} Brandon Arvanaghi \emph{Reversing Ethereum Smart Contracts} \url{https://arvanaghi.com/blog/reversing-ethereum-smart-contracts/}.
\bibitem{soliditygetterfunction} Solidity Documentation \emph{Getter Functions} \url{https://solidity.readthedocs.io/en/v0.5.5/contracts.html#getter-functions}.
\bibitem{whatisapi} Elliot Bettilyon \emph{What Is an API and Why Should I Use One?} \url{https://medium.com/@TebbaVonMathenstien/what-is-an-api-and-why-should-i-use-one-863c3365726b}.
\bibitem{resthttpstatuscode} Internet Engineering Task Force (IETF) \emph{Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content} \url{https://tools.ietf.org/html/rfc7231}.
\bibitem{solidityarrayindex} Solidity Documentation \emph{Arrays} \url{https://solidity.readthedocs.io/en/v0.5.3/types.html#arrays}.
\bibitem{urlencodedform} Dinesh Balaji \emph{Understanding HTML Form Encoding: URL Encoded and Multipart Forms} \url{https://dev.to/sidthesloth92/understanding-html-form-encoding-url-encoded-and-multipart-forms-3lpa}.
\bibitem{rfc2616} Network Working Group \emph{Hypertext Transfer Protocol - HTTP/1.1} \url{https://www.ietf.org/rfc/rfc2616.txt}.
\bibitem{baeldungoptional}  Yannick Majoros \emph{Java 8 Optional - Avoid Null and NullPointerException Altogether - and Keep It Pretty} \url{https://dzone.com/articles/java-8-optional-avoid-null-and}.
\bibitem{springmvc} Baeldung \emph{Spring Web Annotations} \url{https://www.baeldung.com/spring-mvc-annotations}.
\bibitem{thymeleafguide} Rafał Borowiec \emph{Spring MVC and Thymeleaf: how to access data from templates} \url{https://www.thymeleaf.org/doc/articles/springmvcaccessdata.html}.
\bibitem{mongoguide} Spring \emph{Accessing Data with MongoDB} \url{https://spring.io/guides/gs/accessing-data-mongodb/}.
\end{thebibliography}

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage					
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis tabel.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.	
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}		% Dodanie do spisu treści.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis rysunków.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________%____________________________________________________________________________________________
% Spis listingów. 
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\lstlistoflistings
\addcontentsline{toc}{chapter}{Spis listingów} 
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

\end{document}
