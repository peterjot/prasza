% 1. Należy w programie ustawić zgodne kodowanie, w tym przypadku jest UTF-8. 
% 2. Kompilować ten plik za pomocą pdfLatex.


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Ustawienia pracy.
%____________________________________________________________________________________________

% Obowiązkowo! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definiowanie stylu i formatu pracy.
\documentclass[a4paper,twoside,12pt]{book}	% twoside - dwustronnie		 
\usepackage{polski}		 		% ustawienie języka
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[utf8]{inputenc}	
\usepackage{latexsym}
\usepackage{indentfirst} 				% wcięcia akapitu
\linespread{1.5}					% odstęp między liniami
\usepackage{geometry}
\geometry{lmargin=3.5cm, rmargin=3cm}	% ustawienie marginesów, lewy większy na oprawę

\usepackage{url}
\usepackage{enumerate}				% numeracja
\usepackage{amsopn}
\usepackage{graphicx} 				% grafika
\usepackage{epstopdf}				% grafika formatu eps
\usepackage{tabularx} 				% tabele
\usepackage{hyperref} 				% łącza
\usepackage{picture} 				% rysunki
\usepackage{upgreek}				% greckie symbole

\usepackage{listings}				% listingi
\usepackage{color}					% kolory


 % Polecenie usunięcia paginy na pustej stronie.
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} 	


% Zmiana nazwy rozdziału z listingami, domyślnie jest Listings.
\renewcommand{\lstlistlistingname}{Spis listingów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec



% Dodatkowo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definicje własnych otoczeń.
\theoremstyle{definition}
\newtheorem{dfn}{Definicja}[chapter]
\newtheorem{prz}[dfn]{Przykład}

\theoremstyle{remark}
\newtheorem{wsk}[dfn]{Wniosek}
% koniec


% Definiowanie własnego stylu listingu.
\lstset{
  frame             	= lines,
  basicstyle        	= \linespread{1}\ttfamily,%\small\footnotesize,
  columns           	= fullflexible,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
  breaklines=true,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec	 



\begin{document}

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Strona tytułowa.
%____________________________________________________________________________________________

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother 
% Tutaj wszystko należny wypełnić w nawiasach {}, nic więcej nie zmieniać!

\author{\textbf{Piotr Jasina}}        	% Podaj imię i nazwisko.
\title{Identyfikacja inteligentnych kontraktów w sieci Ethereum}      % Podaj tytuł polski.
\date{{\textbf{Lublin rok \the\year}}}	% Nic nie zmieniaj, rok wygeneruje automatycznie.
\def\engtitle{Ethereum smart contracts identification} % Podaj tytuł angielski.

\def\kierunek{Informatyka}		% Podaj kierunek studiów.
\def\specjalnosc{.....}			% Podaj specjalność, jeśli istnieje.
\def\nralbumu{279183}			% Podaj nr albumu.

\def\rodzaj{licencjacka}			% Podaj rodzaj pracy.
\def\zaklad{Zakładzie Cyberbezpieczeństwa}	% Podaj nazwę zakładu Twojego promotora.
\def\promotor{dr. Damiana Rusinka}	% Podaj promotora.

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Poniżej w {titlepage} nic nie zmieniać.

\renewcommand{\maketitle}{
\begin{titlepage}
\begin{table}
\begin{tabular}{c@{\hspace{10mm}}|@{\hspace{3mm}}l}
\multicolumn{2}{@{\hspace{15mm}}l}{\vspace{-31mm}} \\
\multicolumn{2}{l}{\hspace{-20mm}\includegraphics[scale=0.4]{UMCS}} \\ 
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{7mm}} \\

\multicolumn{2}{@{\hspace{16mm}}l}{\Large UNIWERSYTET MARII CURIE-SKŁODOWSKIEJ} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large W LUBLINIE} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large Wydział Matematyki, Fizyki i Informatyki} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{16mm}} \\

& \multicolumn{1}{m{13cm}}{Kierunek: \kierunek} \\
% Jeśli nie ma specjalności, to należy zakomentować poniższą linijkę!
% & \multicolumn{1}{m{13cm}}{Specjalność: \specjalnosc} \\
& \\
& \multicolumn{1}{m{13cm}}{\@author} \\
& \multicolumn{1}{m{13cm}}{nr albumu: \nralbumu} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{\Large\textbf{\@title}} \\
& \\
& \multicolumn{1}{m{13cm}}{\engtitle} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{Praca \rodzaj} \\	
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{napisana w \zaklad} \\
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{pod kierunkiem \promotor} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\vspace{7mm}} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\@date}
\end{tabular}
\end{table}
\end{titlepage}
}
% koniec 

% Tworzenie strony tytułowej.
\maketitle
% Wyczyszczenie z numeracji strony za stroną tytułową. 
\clearemptydoublepage


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis treści. 
%____________________________________________________________________________________________
\tableofcontents 		
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 	
\clearemptydoublepage			


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Wstęp pracy.
%____________________________________________________________________________________________
\chapter*{Wstęp}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Wstęp} 	% bez numeru w spisie treści

...
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 1.
%____________________________________________________________________________________________
\chapter[Ethereum]{Ethereum}
% W nawiasach [] zapisujemy skróconą nazwę rozdziału, pojawiający się w paginie górnej oraz w spisie treści.
% W nawiasach {} zapisujemy pełną nazwę rozdziału.
% '\protect \\' służy do dzielenia długiej nazwy rozdziału.

\section{Historia}

Literatura: \cite{autor1, autor2}. TODO


\section{Opis platformy}

Literatura: \cite{autor1, autor2}. TODO

\section{Ethereum Virtual Machine}

Literatura: \cite{autor1, autor2}. TODO

\section{Inteligentne kontrakty}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 2.
%____________________________________________________________________________________________
\chapter[Solidity]{Solidity}

\section{Sygnatura funkcji}

Literatura: \cite{autor1, autor2}. TODO


\section{Selektor funkcji}

Literatura: \cite{autor1, autor2}. TODO

\section{Generowanie akcesorów podczas kompilacji}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 3.
%____________________________________________________________________________________________
\chapter[Projekt Aplikacji]{Projekt Aplikacji}
Celem mojej pracy licencjackiej było stworzenie aplikacji internetowej umożliwiającej identyfikację  inteligentnych kontraktów wykorzystywanych w sieci Ethereum. Dzięki aplikacji użytkownik po wprowadzeniu na stronie kodu bajtowego kontraktu jest w stanie otrzymać najbardziej prawdopodobną implementacje kontraktu napisana w języku Solidity bazując na bazie danych aplikacji.

Poniżej zostało opisane działanie aplikacji wraz ze szczegółowym opisem funkcjonalności, architektury oraz wykorzystanych technologi.
\section{Funkcjonalność}
Podczas korzystania z aplikacji uzytkownik ma dostepne trzy funkcjonalnosci: identyfikację inteligentnych kontraktu, wprowadzanie plików źródłowych kontraktów do aplikacji oraz interfejs programistyczny aplikacji. Na stronie głównej poniżej menu znajduje się opis aplikacji wraz z aktualna liczba kodów źródłowych znajdujących się w bazie danych aplikacji oraz podstawowe definicje związane z projektem aplikacji.

\subsection{Identyfikacja inteligentnych kontraktów}
Pierwsza opcją dostępną w  aplikacji jest identyfikacja inteligentnych kontraktów. Identyfikacje kontraktu można rozpocząć będąc na stronie główniej lub na podstronie dedykowanej specjalnie identyfikacji kontraktów. Zarówno na stronie głównej, jak i na podstronie znajduje się pole w którym można wprowadzić kod bajtowy. Po wprowadzeniu danych użytkownik zatwierdza je w obu przypadkach klikając przycisk \textbf{Identify}. Natomiast, jeśli użytkownik chce udać się na podstronę, należy wybrać przycisk w menu o nazwie \textbf{Identify bytecode}, następnie użytkownik zostanie przekierowany na podstronę dedykowaną identyfikacji kontraktów. W przypadku wprowadzenia kodu bajtowego na stronie głównej zostaniemy również przekierowani na podstronę z taka różnica, ze pojawią się od razu wyniki identyfikacji kontraktu. Zarówno na stronie głównej, jak i podstronie dedykowanej identyfikacji, użytkownik jest zobowiązany wprowadzać kod bajtowy w szesnastkowym systemie liczbowym, w innym wypadku identyfikacja nie przejdzie prawidłowo.


Podczas wprowadzania kodu istnieje możliwość wprowadzenia kodu z prefiksem \textbf{0x} lub bez tego prefixu. Jeśli użytkownik poda kod z prefiksem to aplikacja podczas przetwarzania tego kodu zignoruje ten prefiks. Takie rozwiązanie zostało zastosowane w celu zapewnienia użytkownikowi większej wygody oraz komfortu w korzystaniu z aplikacji. Użytkownik nie będzie musiał zastanawiać się czy kopiując kod bajtowy z dowolnego źródła, jest on z prefiksem czy nie, ponieważ obie opcje są wspierane.


Po wprowadzeniu danych i zatwierdzeniu ich przyciskiem \textbf{Identify}, aplikacja rozpoczyna proces analizy wprowadzonego kodu bajtowego oraz wyszukiwane są najbardziej prawdopodobne implementacje posortowane malejąco według współczynnika dopasowania. W rezultacie jak możemy zobaczyć na rysunku \ref{rys:wynik_identyfikacji} użytkownik otrzymuje listę dziesięciu najbardziej prawdopodobnych implementacji.

Mimo że domyślnie jest wyświetlanych tylko dziesięć najbardziej prawdopodobnych implementacji, istnieje też możliwość pobrania wszystkich wyników identyfikacji kontraktu używając przycisku \textbf{Get all}. Jak widać na rysunku \ref{rys:wynik_identyfikacji}, przycisk \textbf{Get all} znajduje się pod pierwszą dziesiątka wyników. Po naciśnięciu przycisku strona zostanie załadowana ponownie wraz z pełną lista identyfikatorów plików i ich współczynnikami dopasowania.


Po naciśnięciu w jedną z wyświetlanych implementacji, użytkownikowi pojawi się w nowej karcie przeglądarki podstrona umożliwiająca podgląd implementacji.


Jak widać na rysunku \ref{rys:podglad_impelementacji} kod źródłowy kontraktu jest wyświetlany ze specjalnie przygotowanym dla języka Solidity podświetleniem składni przygotowanym, natomiast po lewej stronie można zobaczyć przygotowaną numeracje wierszy, która ma za zadanie ułatwić nawigację po kodzie źródłowym na stronie internetowej. Rozwiązanie z numerowaniem linii zostało zaimplementowane w taki sposób, aby podczas kopiowania kodu źródłowego ze strony, nie były kopiowane z nim liczby identyfikujące konkretną linie w kodzie.


\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.3]{wynik_identyfikacji.png}
\caption{Wynik identyfikacji inteligentnego kontraktu}
\label{rys:wynik_identyfikacji}
\end{figure}

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.3]{podglad_impelementacji.png}
\caption{Podgląd implementacji}
\label{rys:podglad_impelementacji}
\end{figure}

\subsection{Dodanie kodu źródłowego kontraktu do aplikacji}
Kolejna funkcjonalnością dostępną dla użytkownika jest możliwość dodania własnego kodu źródłowego kontraktu napisanego w języku Solidity. Opcja ta umożliwia użytkownikowi uzupełnienie aktualnej bazy danych o kolejne kody źródłowe inteligentnych kontraktów. W rezultacie zgromadzenia dużej ilości implementacji w bazie danych, wszyscy pozostali użytkownicy maja większą szansę na precyzyjną identyfikacje kontraktu. W celu wykorzystania tej funkcjonalności użytkownik musi zdobyć autoryzowany dostęp poprzez zalogowanie się i uwierzytelnienie za pomocą panelu logowania. Zakładając, że osoba korzystająca z tej części aplikacji posiada odpowiednie uprawnienia to po naciśnięciu przycisku \textbf{Upload solidity}, zostanie przekierowana na podstronę, na której ma możliwość wprowadzenia kodu źródłowego. Zostały utworzone dwie możliwości wprowadzania kodów źródłowych, które opiszę poniżej. 


Pierwszą sposobem jest przesłanie do aplikacji pliku zawierającego implementacje kontraktu napisana w języku Solidity. W tym przypadku użytkownik powinien kliknąć przycisk \textbf{Browse}, który umożliwi mu wybranie za pomocą przeglądarki internetowej konkretnego pliku znajdującego się na dysku lokalnym, a następnie zatwierdzić go przyciskiem \textbf{Upload} znajdującym się obok wcześniej wspomnianego przycisku. 


Innym sposobem na przesłanie kodu źródłowego do aplikacji jest wklejenie kodu źródłowego bezpośrednio do formularza znajdującego się po prawej części strony internetowej. Ta opcja została utworzona w celu zapewnienia użytkownikowi większej elastyczności i komfortu w korzystaniu z aplikacji. Przykładowo podczas korzystania z aplikacji, użytkownik może bezpośrednio skopiować kod źródłowy, który jest w dowolnym innym źródle tekstowym np. innej stronie internetowej i wkleić go bezpośrednio do aplikacji bez konieczności tworzenia pliku tymczasowego.



\subsection{Interfejs programistyczny aplikacji}
Trzecia funkcjonalnością aplikacji jest interfejs programistyczny. Umożliwia on tworzenie własnego oprogramowania oraz skryptów, bazując na utworzonej prze zemnie aplikacji, przez innych programistów. Dzięki temu można wykorzystać mechanizmy zaimplementowane w aplikacji w celu rozszerzenia ich w innej aplikacji lub w celu zautomatyzowania niektórych procesów bez wykorzystania GUI (ang. graphical user interface) aplikacji.


W celu skorzystania z interfejsu programistycznego należy utworzyć żądanie HTTP. Za pomocą żądania HTTP użytkownik aplikacji ma możliwość dostarczenia na serwer nowego kodu źródłowego, pobrania kodu źródłowego na podstawie hasza kodu źródłowego znajdującego się na serwerze oraz identyfikacje kontraktu.


Przykładowym zastosowaniem API (ang. Application programming interface) może być utworzenie skryptu umożliwiającego zautomatyzowanie wysyłania kodów źródłowych do aplikacji, bez konieczności korzystania z interfejsu graficznego aplikacji. W tym przypadku użytkownik, który chce przesłać nowy plik do aplikacji musi najpierw przejść proces autoryzacji, natomiast pozostałe funkcje API nie wymagają uwierzytelniania użytkownika przez aplikacje.


\subsubsection{Pobieranie informacji o kodzie źródłowym z API}
Jeśli użytkownik chce pobrać za pomocą API informacje o konkretnym kodzie źródłowym kontraktu, w tym celu powinien utworzyć żądanie HTTP. W przypadku tej funkcjonalności nie jest wymagane uwierzytelnienie użytkownika. 

Na listingu \ref{lst:przykladowezadaniehttp} można zaobserwować przykładowe żądanie HTTP, które jest wykorzystane w celu pobrania informacji o konkretnym kodzie źródłowym.
Użytkownik podczas korzystania z API powinien zwrócić szczególna uwagę na wykorzystywaną metodę w nagłówku HTTP, ponieważ interfejs aplikacji wspiera tylko wybrane metody. Na listingu \ref{lst:przykladowezadaniehttp} widać, że używaną metodą jest \textbf{GET}, która jest jedną z kilku dostępnych metod w standardzie \textit{HTTP/1.1}, istnieją też między innymi metody: \textit{POST}, \textit{HEAD}, \textit{PUT} czy \textit{DELETE}. Metody HTTP zostały opisane szczegółowo w sekcji 9.2 dokumentu RFC2616 \cite{rfc2616}.


Zaraz za metoda GET, można zobaczyć listingu \ref{lst:przykladowezadaniehttp}, znajduje się adres pod którym zostanie wysyłane żądanie. Na końcu adresu po znaku zapytania podane zostały atrybuty o nazwie \textit{fileHash} ze wskazaną wartością hasza pliku. Odpowiedzią na tak przygotowane zapytanie będzie w tym przypadku zwykły tekst implementację kontraktu oraz status HTTP 200, mówiący użytkownikowi, że wszystko poszło dobrze. W sytuacji gdy, użytkownik otrzyma status HTTP 404, oznacza to, że nie udało się znaleźć implementacji o podanym haszu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przykladowe żądanie HTTP, label=lst:przykladowezadaniehttp]
GET /api/solidityFiles/sourceCode?fileHash=0x06c61b8e505d7a407af9a91bdff8085560e90a133c77ab32bde32e686f6a8d52 HTTP/1.1
Host: contractmy.herokuapp.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: pl-PL,pl;q=0.9,en-US;q=0.8,en;q=0.7
\end{lstlisting}
\end{center}


\subsubsection{Identyfikacja inteligentnego kontraktu za pomocą API}
Podczas identyfikacji inteligentnego kontraktu, za pomocą interfejsu programistycznego, żądanie pokazane na listingu \ref{lst:przykladowezadaniehttp} musimy nieco zmodyfikować. Podczas identyfikacji wykorzystywana jest metoda POST. W nagłówku HTTP należy więc wprowadzić tą metodę zamiast GET, a następie zmienić ścieżkę na \textit{/api/bytecode}. Pod podana ścieżką zostanie wysłane żądanie HTTP. W przypadku metody POST opisanej w sekcji 9.5 dokumentu \mbox{RFC2616} \cite{rfc2616} podajemy poniżej nagłówka zawartość, która będzie przesłana do serwera. W odróżnieniu od wykorzystanej poprzednio metody GET, tutaj atrybuty powinny zostać podane poniżej nagłówka, zamiast w adresie.


API pod adresem \mbox{/api/bytecode} wymaga od użytkownika dwóch atrybutów o nazwach: bytecode oraz allFiles.
Poniżej nagłówka HTTP w żądaniu należy wprowadzić odpowiednio zakodowane atrybuty. W celu zakodowania listy atrybutów, każdy atrybut zapisuje się w postaci:
\begin{verbatim}
NAZWA_ATRYBUTU=WARTOSC_ATRYBUTU
\end{verbatim}
łącząc je wszystkie ampersandem. Poprawnie zakodowana zawartość w żądaniu HTTP w tym przypadku powinna wyglądać następująco: 
\begin{verbatim}
bytecode=KOD_BAJTOWY&allFiles=WARTOSC_LOGICZNA. 
\end{verbatim}


W tym przypadku wartość \mbox{KOD\_BAJTOWY} użytkownik musi zamienić na swój kod bajtowy, który chce przeanalizować, a \mbox{WARTOSC\_LOGICZNA} należy zamienić na napis \textit{true} lub \textit{false}, w zależności od tego, czy chcemy w rezultacie otrzymać wszystkie dopasowania implementacji, czy chcemy otrzymać tylko pierwszą dziesiątkę najbardziej pasujących. Dodatkowo w nagłówku należy wprowadzić parametr \textbf{Content-Length}, którego wartością powinna być długość wysyłanych danych. Przykładowo dla zawartości:
\begin{verbatim}
bytecode=234a12b45&allFiles=true
\end{verbatim}
fragment nagłówka powinien wyglądać następująco:
\begin{verbatim}
Content-Length: 32
\end{verbatim}
W rezultacie zapytania, użytkownik otrzyma status HTTP 200, listę składająca się z haszu pliku oraz współczynnika dopasowania danego pliku w formacie JSON. W sytuacji, gdy dla konkretnego kodu bajtowego nie udało się dopasować żadnej implementacji, zwrócony zostanie status HTTP 404 mówiący o tym, że nic nie udało się znaleźć.


\subsubsection{Przesyłanie nowego kodu źródłowego za pomocą API}
W aplikacji istnieje możliwość przesłania kodu źródłowego w sposób programowy, wykorzystując API. W odróżnieniu od sposobu opisanego powyżej, teraz nie będą używane atrybuty z nazwami, tylko zostanie wysłane żądanie HTTP, którego ciałem będzie czysty tekst, czyli będzie wprowadzony tylko kod źródłowy bez wykorzystywania nazw atrybutów. 


W celu wysłania takiego żądania najpierw użytkownik musi zostać uwierzytelniony, w innym przypadku próba dodania nowego kodu źródłowego do aplikacji ukończy się niepowodzeniem. Zakładając, że użytkownik został uwierzytelniony oraz bazując na przykładowym żądaniu HTTP z listingu \ref{lst:przykladowezadaniehttp}, należy wprowadzić poniżej nagłówka cały kod źródłowy kontraktu. Natomiast w nagłówku użytkownik musi ustawić metodę POST, wskazać ścieżkę na \mbox{/api/solidityFiles} oraz analogicznie do sekcji wyżej, ustawić wartość \mbox{\textit{Content-Length}} w zależności od długości przesyłanych danych. 


Należy pamiętać, że kod źródłowy musi być zaimplementowany w języku Solidity, w innym wypadku otrzymamy fałszywe informacje. 


Po pomyślnym przesłaniu kontraktu, w odpowiedzi od serwera utrzymujemy status HTTP 200, który informuje osobę korzystającą z API, że wszystko poszło pomyślnie. Dodatkowo w informacji zwrotnej użytkownik otrzymuje przesłany przez niego kod źródłowy, hasz stworzony na podstawie kodu źródłowego oraz listę znalezionych w nim funkcji wraz z akcesoriami generowanymi podczas kompilacji. Na listingu \ref{lst:przykladodpowiedzijson} można zaobserwować przykładowe dane zwracane przez API po prawidłowym dodaniu nowego kodu źródłowego.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przykładowa odpowiedz w formacie JSON(w skróconej formie), label=lst:przykladodpowiedzijson]
{
    "sourceCodeHash": "0x80b739cbf3e89eeea1a96d9cfcf0567ddfef2af82eb14d2c5f97862f71e56265",
    "sourceCode": "pragma solidity ^0.4.25;\n\ncontract Hello {\n\n\tstring public message;\n\t\n\tconstructor(string initialMessage) public {\n\t\tmessage = initialMessage;\n\t}\n\t\n\tfunction setMessage(string newMessage) public {\n\t\tmessage = newMessage;\n\t}\n\n}",
    "solidityFunctions": [
        {
            "selector": "e21f37ce",
            "signature": "message()"
        },
        {
            "selector": "368b8772",
            "signature": "setMessage(string)"
        }
    ]
}
\end{lstlisting}
\end{center}

Pod atrybutem \textbf{sourceCodeHash} została umieszczona wartość hasza pliku źródłowego, natomiast pod atrybutem \textbf{sourceCode} znajduje sie przeslana przez uzytkownika implementacja w języku Solidity. Kolejnym elementem otrzymanej odpowiedzi w formacie JSON jest \textbf{solidityFunction}, pod tą nazwa znajduje się lista funkcji znalezionych w przesłanym kodzie zawierająca selektor oraz sygnaturę poszczegolnej funkcji.

\section{Architektura}

Literatura: \cite{autor1, autor2}. TODO

\subsection{Wyszukiwanie sygnatur funkcji w kodzie źródłowym}

Literatura: \cite{autor1, autor2}. TODO

\subsection{Wyszukiwanie selektorów funkcji w kodzie bajtowym}

Literatura: \cite{autor1, autor2}. TODO

\subsection{Szukanie implementacji na podstawie kodu bajtowego}

Literatura: \cite{autor1, autor2}. TODO

\section{Wykorzystane technologie}

Literatura: \cite{autor1, autor2}. TODO


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 




%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Bibliografia.
%____________________________________________________________________________________________
\phantomsection
\begin{thebibliography}{99}
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\addcontentsline{toc}{chapter}{Bibliografia}		% Dodanie do spisu treści.

\bibitem{rfc2616} Network Working Group \url{https://www.ietf.org/rfc/rfc2616.txt}.
\bibitem{autor1} Bibliografia 2. \emph{Nazwa}. 

\end{thebibliography}

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage					
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis tabel.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.	
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}		% Dodanie do spisu treści.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis rysunków.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________%____________________________________________________________________________________________
% Spis listingów. 
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\lstlistoflistings
\addcontentsline{toc}{chapter}{Spis listingów} 
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

\end{document}
