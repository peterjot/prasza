

% 1. Należy w programie ustawić zgodne kodowanie, w tym przypadku jest UTF-8. 
% 2. Kompilować ten plik za pomocą pdfLatex.


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Ustawienia pracy.
%____________________________________________________________________________________________

% Obowiązkowo! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definiowanie stylu i formatu pracy.
\documentclass[a4paper,twoside,12pt]{book}	% twoside - dwustronnie		 
\usepackage{polski}		 		% ustawienie języka
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage[utf8]{inputenc}	
\usepackage{latexsym}
\usepackage{indentfirst} 				% wcięcia akapitu
\linespread{1.5}					% odstęp między liniami
\usepackage{geometry}
\geometry{lmargin=3.5cm, rmargin=3cm}	% ustawienie marginesów, lewy większy na oprawę

\usepackage{url}
\usepackage{enumerate}				% numeracja
\usepackage{amsopn}
\usepackage{graphicx} 				% grafika
\usepackage{epstopdf}				% grafika formatu eps
\usepackage{tabularx} 				% tabele
\usepackage{hyperref} 				% łącza
\usepackage{picture} 				% rysunki
\usepackage{upgreek}				% greckie symbole

\usepackage{listings}				% listingi
\usepackage{color}					% kolory

\usepackage{makecell}				% mozliwosc zlamania tekstu w tabeli

 % Polecenie usunięcia paginy na pustej stronie.
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} 	


% Zmiana nazwy rozdziału z listingami, domyślnie jest Listings.
\renewcommand{\lstlistlistingname}{Spis listingów}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec



% Dodatkowo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Definicje własnych otoczeń.
\theoremstyle{definition}
\newtheorem{dfn}{Definicja}[chapter]
\newtheorem{prz}[dfn]{Przykład}

\theoremstyle{remark}
\newtheorem{wsk}[dfn]{Wniosek}
% koniec


% Definiowanie własnego stylu listingu.
\lstset{
  frame             	= lines,
  basicstyle        	= \linespread{1}\ttfamily,%\small\footnotesize,
  columns           	= fullflexible,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
  breaklines=true,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% koniec	 



\begin{document}

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Strona tytułowa.
%____________________________________________________________________________________________

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother 
% Tutaj wszystko należny wypełnić w nawiasach {}, nic więcej nie zmieniać!

\author{\textbf{Piotr Jasina}}        	% Podaj imię i nazwisko.
\title{Identyfikacja inteligentnych kontraktów w sieci Ethereum}      % Podaj tytuł polski.
\date{{\textbf{Lublin rok \the\year}}}	% Nic nie zmieniaj, rok wygeneruje automatycznie.
\def\engtitle{Ethereum smart contracts identification} % Podaj tytuł angielski.

\def\kierunek{Informatyka}		% Podaj kierunek studiów.
\def\specjalnosc{.....}			% Podaj specjalność, jeśli istnieje.
\def\nralbumu{279183}			% Podaj nr albumu.

\def\rodzaj{licencjacka}			% Podaj rodzaj pracy.
\def\zaklad{Zakładzie Cyberbezpieczeństwa}	% Podaj nazwę zakładu Twojego promotora.
\def\promotor{dr. Damiana Rusinka}	% Podaj promotora.

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Poniżej w {titlepage} nic nie zmieniać.

\renewcommand{\maketitle}{
\begin{titlepage}
\begin{table}
\begin{tabular}{c@{\hspace{10mm}}|@{\hspace{3mm}}l}
\multicolumn{2}{@{\hspace{15mm}}l}{\vspace{-31mm}} \\
\multicolumn{2}{l}{\hspace{-20mm}\includegraphics[scale=0.4]{UMCS}} \\ 
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{7mm}} \\

\multicolumn{2}{@{\hspace{16mm}}l}{\Large UNIWERSYTET MARII CURIE-SKŁODOWSKIEJ} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large W LUBLINIE} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{-4mm}} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\Large Wydział Matematyki, Fizyki i Informatyki} \\
\multicolumn{2}{@{\hspace{16mm}}l}{\vspace{16mm}} \\

& \multicolumn{1}{m{13cm}}{Kierunek: \kierunek} \\
% Jeśli nie ma specjalności, to należy zakomentować poniższą linijkę!
% & \multicolumn{1}{m{13cm}}{Specjalność: \specjalnosc} \\
& \\
& \multicolumn{1}{m{13cm}}{\@author} \\
& \multicolumn{1}{m{13cm}}{nr albumu: \nralbumu} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{\Large\textbf{\@title}} \\
& \\
& \multicolumn{1}{m{13cm}}{\engtitle} \\
& \\
& \\
& \multicolumn{1}{m{13cm}}{Praca \rodzaj} \\	
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{napisana w \zaklad} \\
& \vspace{-7mm} \\
& \multicolumn{1}{m{13cm}}{pod kierunkiem \promotor} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\vspace{7mm}} \\
\multicolumn{2}{@{\hspace{20mm}}l}{\@date}
\end{tabular}
\end{table}
\end{titlepage}
}
% koniec 

% Tworzenie strony tytułowej.
\maketitle
% Wyczyszczenie z numeracji strony za stroną tytułową. 
\clearemptydoublepage


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis treści. 
%____________________________________________________________________________________________
\tableofcontents 		
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 	
\clearemptydoublepage			


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Wstęp pracy.
%____________________________________________________________________________________________
\chapter*{Wstęp}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Wstęp} 	% bez numeru w spisie treści

Tematem pracy dyplomowej jest opracowanie narzędzia umożliwiającego identyfikacje inteligentnych kontraktów w sieci Ethereum na podstawie kodu bajtowego.
Niniejsza praca została podzielona na trzy części - wstęp teoretyczny z wiedzy dotyczącej platformy Ethereum, informacje dotyczące języka Solidity oraz cześć praktyczną omawiająca implementacje rozwiązania.

Pierwszy rozdział zawiera informacje dotyczące powstania sieci Ethereum, zalet wykorzystania inteligentnych kontraktów oraz opisuje wykorzystanie maszyny wirtualnej jako cześć sieci Ethereum.

Drugi rozdział omawia specyfikę języka Solidity, sposób generowania akcesorów do zmiennych podczas kompilacji oraz interakcje z kontraktami. Podczas omawiania interakcji z inteligentnymi kontraktami została przybliżona tematyka generowania selektorów funkcji wykorzystywanych podczas implementacji rozwiązania.

Ostatni rozdział pracy przedstawia funkcjonalności utworzonej aplikacji, sposób wykrywania sygnatur funkcji w kodzie źródłowym oraz wyszukiwania selektorów funkcji w kodzie bajtowym. Po zaimplementowaniu aplikacji zostały przeprowadzone testy metod wyznaczania współczynnika dopasowania implementacji oraz skuteczności aplikacji pod kątem dopasowania implementacji do kodu bajtowego.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 1.
%____________________________________________________________________________________________
\chapter[Ethereum]{Ethereum}
% W nawiasach [] zapisujemy skróconą nazwę rozdziału, pojawiający się w paginie górnej oraz w spisie treści.
% W nawiasach {} zapisujemy pełną nazwę rozdziału.
% '\protect \\' służy do dzielenia długiej nazwy rozdziału.


Ethereum jest to otwarta platforma oparta o technologie blockchain, która umożliwia użytkownikom tworzenie i uruchamianie zdecentralizowanych aplikacji. Programy tworzone i uruchamiane na blockchain nazywane są też inteligentnymi kontraktami. 

Do uruchamiania aplikacji została stworzona maszyna wirtualna o nazwie Ethereum Virtual Machine, która może wykonywać kod inteligentnego kontraktu o dowolnej złożoność algorytmicznej. Kod aplikacji stworzonej na EVM jest przechowywany na blockchainie utrzymywanym przez jego użytkowników. Programiści mogą tworzyć aplikacje na EVM  za pomocą przyjaznych języków programowania wzorowanych na Pythonie czy JavaScript.\cite{whatisethereum}

Na potrzeby platformy Ethereum stworzono dedykowany język Solidity, który został stworzony z myślą o tworzeniu inteligentnych kontraktów.



 
\section{Historia}

Początki Ethereum zostały opisane przez programistę Vitalika Buterina w 2013 roku. Vitalik w październiku 2013 roku pracował nad nową kryptowalutą z zespołem Mastercoin. Zaproponował im stworzenie bardziej uogólnionego protokołu, który wspierałby rożne rodzaje umów bez dodawania  kolejnych funkcjonalności. Mastercoin było pod wrażeniem jego pomysłu, natomiast nie byli zainteresowania zmianami w tym kierunku. Vitalik czuł, że jego koncepcja jest słuszna i postanowił iść w tym kierunku. Około drugiego grudnia Vitalik uświadomił sobie, że inteligentne kontrakty mogą być w pełni uogólnione, a do opisywania ich warunków można zastosować język skryptowy.\cite{vitalikethereumprehistory}

W grudniu 2013 do zespołu Valika dołączył między innymi Gavin Wood oraz programista klienta w języku Go Jeffrey Wilcke. Latem 2014 roku była już pierwsza stabilna wersja protokołu Ethereum oraz pół formalna specyfikacja w postaci żółtego papieru stworzonego przez Gavina.\cite{vitalikethereumprehistory}


Na początku lipca 2014 Ethereum rozdysponowało początkowy przydział krypto waluty Ether będącej częścią platformy Ethereum. Rozdysponowana wartość wynosiła około 18 milionów dolarów w zamian za ponad 50 milionów Etherów. Wyniki sprzedażny zostały początkowo wykorzystane na opłacenie prac programistów oraz na finansowanie ciągłego rozwoju Ethereum.\cite{ethersaleastatisticaloverview} Po wyprzedaży Etheru rozwojem Ethereum zajmowała się organizacja non-profit o nazwie ETH DEV, której dyrektorami stali się: Vitalik Buterin, Gavin Wood oraz Jeffrey Wilcke.

W listopadzie 2014 roku ETH DEV zorganizowało w Berlinie wydarzenie DEVCON-0, które przyciągnęło programistów z całego świata interesujących się Ethereum.\cite{devcon0}

Na początku 2015 roku odbyły się audyty bezpieczeństwa przed uruchomieniem, zorganizowane przez między innymi Jutta Steinera. Audyty dotyczyły przede wszystkim implementacji w Go i C++. Przeprowadzony został też mniejszy audyt dotyczący implementacji Vilika nazwanej pyethereum. Kontrola bezpieczeństwa wprowadziła do protokołu kilka małych zmian. Jedną zmianą było wprowadzenie funkcji haszującej SHA3 dla klucza i adresu drzewa Trie, która miała zapobiec atakowi DOS.\cite{whyethereumusesecuretries}

Sieć Ethereum została uruchomiona 30 lipca 2015 roku. Był to moment, w którym użytkownicy przystąpili do sieci, aby uzyskać eter z bloków górniczych. Natomiast programiści zaczęli pisać inteligentne umowy oraz zdecentralizowane aplikacje gotowe do wdrożenia w sieci Ethereum. Była to wersja testowa, ale jak się okazało, była ona bardziej udana, niż ktokolwiek by się tego spodziewał.\cite{proceswydaniaethereum}

Idąc za ciosem, zorganizowano druga konferencje dla programistów nazwaną DEVCON-1, odbyła się ona w Londynie na początku listopada 2015 roku. Konferencja trwała pięć dni, a przedstawiano na niej ponad 100 prezentacji, paneli dyskusyjnych oraz krótkich rozmów. W konferencji wzięło udział ponad 400 uczestników, była to mieszanka przedsiębiorców, myślicieli, programistów oraz przedstawicieli biznesowych. W konferencji brały udział duże firmy jak IBM czy Microsoft, co wyraźnie wskazywało na duże zainteresowanie ta technologia.\cite{historyofethereum} 


\section{Czym są Inteligentne kontrakty?}

Określenie inteligentne kontrakty to zostało zaproponowane już w 1994 roku przez Nicka Szabo, który cztery lata później zajmował się projektowaniem kryptowaluty Bitgold, która ostatecznie nie została zaimplementowana. 

Ogólnym celem projektowania inteligentnych umów według Nicka Szabo było spełnienie wspólnych warunków umowy (takich jak warunki płatności czy poufności) oraz zminimalizowanie potrzeby zaufanych pośredników. Inteligentne kontrakty miały za zadanie zapewnić większe bezpieczeństwo niż tradycyjne umowy oraz obniżyć koszty transakcji związanych z tworzeniem umów.\cite{ethereumyellowpaper}

Dzięki inteligentnym kontraktom działa ICO (Initial Coin Offering), czyli nowoczesna metoda crowdfundingu, która umożliwia zbieranie kapitału za pomocą kryptowalut. W ICO umowy inwestycyjne są zastępowane cyfrowymi kontraktami, a płatności są rozliczane w kryptowalutach.\cite{smartcontractswhatis}


Pierwszą popularną kryptowalutą, która wykorzystuje inteligentne kontrakty jest \emph{Bitcoin}. Wadą tej kryptowaluty jest język skryptowy, który umożliwia wykorzystywanie jedynie operacji udostępnionych przez autora. Tworzenie kontraktów jest bardzo ograniczone, ze względu na brak cechy kompletności Turinga w języku. 


Inteligentne kontrakty zyskały nowe znaczenie oraz dużą popularność wraz z rozwojem platformy Ethereum. Platforma ta posiada język, który umożliwia tworzenie inteligentnych kontraktów, które mają cechę kompletności Turinga. Dzięki temu Ethereum jest platformą, która właściwie posiada programowalny blockchain, na którym są przechowywane zdecentralizowane aplikacje. Aplikacje te są uruchamiane przez użytkowników sieci za pomocą EVM. Współcześnie każdy użytkownik korzystający z platformy Ethereum może stworzyć aplikacje, która nie posiada jednego serwera, tylko jest rozproszona po całej sieci Ethereum.\cite{smartcontractswhatis}


Niestety inteligentne kontrakty, jak większość rozwiązań informatycznych, posiadają swoje wady. Wszystkie kontrakty umieszczone na blockchainie są widoczne dla każdego użytkownika. W przypadku luki bezpieczeństwa nie ma możliwości szybkiej naprawy kontraktu umieszczonego w sieci, dodatkowo w praktyce jest trudno napisać dobry inteligenty kontrakt, w którym wszystko zostało przewidziane.

Każdy kontrakt na blockchainie jest przechowywany w postaci jawnego kodu bajtowego, do którego mają wgląd wszyscy użytkownicy sieci, dlatego bardzo ważne jest analizowanie kontraktów pod kątem bezpieczeństwa przed umieszczeniem ich w sieci oraz przed korzystaniem z udostępnionych już kontraktów.

W dalszej części pracy zostanie przedstawione, w jaki sposób stworzyć aplikację, która ułatwi odnalezienie implementacji pasującej do wybranego kodu bajtowego. Posiadanie implementacji kontraktu w znaczącym stopniu ułatwia analizę go pod kątem bezpieczeństwa oraz w celu zrozumienia działania kontraktu. 


\section{Ethereum Virtual Machine}

EVM jest to środowisko uruchomieniowe dla inteligentnych kontraktów opartych o Ethereum. Początkowo wirtualna maszyna została opisana w żółtym dokumencie opracowanym przez dr. Gavina Wooda. Maszyna wirtualna jest całkowicie odizolowana od reszty głównej sieci blockchain, co pomaga w zapewnienia bezpieczeństwa wykonywania niezaufanego kodu przez komputery z całego świata. Każdy węzeł w sieci uruchamia u siebie własną implementację EVM oraz jest w stanie wykonywać na niej te same instrukcje co pozostałe węzły.


\subsection{Kody operacji}

Inteligentne kontrakty napisane w takich językach jak Solidity nie mogą być bezpośrednio wykonane na EVM. W celu wykonania kontraktu należy jego kod skompilować do niskopoziomowych instrukcji. 

Wirtualna maszyna wykorzystuje zbiór instrukcji do wykonywania określonych zadań. Operacje te umożliwiają stworzenie programu zupełnego w sensie Turinga.  Operacje wykonywane na EVM można podzielić na siedem kategorii:


\begin{enumerate}
\item \textbf{Operacje wykorzystujące stos} (POP, PUSH, DUP, SWAP) 

\item \textbf{Operacje udostępniające działania arytmetyczne} (ADD, SUB, GT, LT, AND, OR)

\item \textbf{Operacje środowiskowe} (CALLER, CALLVALUE, NUMBER)

\item \textbf{Operacje modyfikujące pamięć ulotna - memory} (MLOAD, MSTORE, MSTORE8, MSIZE)
- jest to przestrzen w ktorej przechowywane sa tymczasowe dane takie jak argumenty funkcji, czy zmienne lokalne. Dane nie sa przechowywane na blockchanie

\item \textbf{Operacje modyfikujące pamięć nieulotna - storage} (SLOAD, SSTORE) - jest to miejsce w którym przechowywane są dane przechowywane na blockchainie. Każdy kontrakt posiada swój oddzielny obszar na blockchain.

\item \textbf{Operacje skoków oraz licznika programu} (JUMP, JUMPI, PC, JUMPDEST)

\item \textbf{Operacje zatrzymujące} (STOP, RETURN, REVERT, INVALID, SELFDESTRUCT)
\end{enumerate}

Powyżej przedstawiono tylko przykłady operacji z danej kategorii, natomiast pozostałe operacje zostały przedstawione w dokumencie dr. Gavina Wooda.\cite{ethereumyellowpaper}

\subsection{Kod bajtowy}
W celu efektywnego przechowywania operacji są one kompilowane do kodu bajtowego. Każda operacja ma przydzielony jeden bajt na przykład operacja PUSH1, która umieszcza na stosie jeden bajt jest reprezentowana przez wartość 0x60. Dla kodu bajtowego 0x6080604001, pierwszy bajt to operacja PUSH1(0x60). Zgodnie ze specyfikacją opisaną przez Gavina operacja PUSH1 odczytuje kolejny bajt z kodu bajtowego i wrzuca go na stos, w tym przypadku na stos zostanie wrzucona wartość 0x80. Następną operacją jest ponownie PUSH1, tylko tym razem na stos została wrzucona wartość 0x40.\cite{ethereumyellowpaper}

Po wykonaniu dwóch pierwszych operacji na stosie znajdują się dwie wartości: 0x80 oraz 0x40. Kolejnym bajtem jest 0x01, który oznacza operacje ADD. Operacja ADD pobiera ze stosu dwie wartości, wykonuje operacje dodawania, po czym wynik wrzuca z powrotem na stos. W rezultacie górze stosu znajduje się wartość 0xC0.
Podczas wykonywania kodu bajtowego jest on dzielony na pojedyncze bajty. Każdy bajt są to dwie cyfry w systemie szesnastkowym.\cite{ethereumyellowpaper}



\subsection{Analiza kodu bajtowego}

Kontrakty, które zostały umieszczone na blockchainie są przechowywane w postaci kodu bajtowego. Chcąc przeanalizować działanie kontraktu umieszczonego w sieci Ethereum, może okazać się, że kod bajtowy nie jest wystarczająco czytelny. Z tego powodu powstały narzędzia umożliwiające analizę kodu bajtowego. Jednym z takich narzędzi jest eveem.org lub ethervm.io, są to aplikacje internetowe umożliwiające zdekompilowanie do asemblera.

Niestety podczas deasemblacji nazwy funkcji, atrybutów oraz wydarzeń są tracone z powodu optymalizacji. Istnieje jednak sposób na odzyskanie poprzez wykorzystanie bazy danych zawierającej popularne nazwy. Przykładem takiej bazy danych  jest 4byte.directory, czyli aplikacja internetowa przechowującą sygnatury funkcji wraz z ich reprezentacjami bajtowymi.


% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 2.
%____________________________________________________________________________________________
\chapter[Solidity]{Solidity}

Solidity jest to język umożliwiający tworzenie inteligentnych kontraktów w sieci Ethereum. Kod napisany w Solidity jest bardzo podobny do C++, C\#, JavaScript lub Pythona. Jedną z wad języka Solidity jest mała ilość literatury do nauki języka, ponieważ powstał on w 2014 roku i na moment pisania pracy jest dosyć nowy względem innych języków programowania.

\section{Modyfikatory widoczności funkcji oraz zmiennych}

W Solidity występują dwa rodzaje wywołań funkcji: wewnętrzne (funkcja jest wywoływana wewnątrz tej samej umowy) oraz zewnętrzne (funkcji jest wywoływana z innego kontraktu).\cite{soliditygetterfunction}

Dodatkowo zostały utworzone cztery modyfikatory dla funkcji i zmiennych:

\begin{enumerate}
	
	\item{\textbf{external}} - dzięki temu modyfikatorowi funkcja jest możliwa tylko do wywołania na zewnątrz kontraktu, wywołanie jej wewnątrz tego samego kontraktu spowoduje błąd kompilacji.
	
	\item{\textbf{public}} - funkcja określona w ten sposób jest częścią interfejsu kontraktu. Funkcja ta może zostać wywołana zarówno wewnętrznie jak i zewnętrznie. W przypadku publicznych zmiennych zostanie automatycznie wygenerowana  funkcja zwana akcesorem. Modyfikator public jest domyślnie używany dla funkcji.
	
	\item{\textbf{internal}} - funkcje i zmienne z tym specyfikatorem są dostępne tylko wewnątrz kontraktu, w której się znajdują, ponad to są dostępne dla kontraktów pochodnych. Ten modyfikator jest domyślnie ustawiony dla utworzonych akcesorów zmiennych.
	
	\item{\textbf{private}} - funkcje i zmienne, która są prywatne są widoczne tylko wewnątrz kontraktu i nie mogą zostać odziedziczone.


\end{enumerate}

Specyfikator widoczności znajduje się po typie zmiennej oraz w przypadku funkcji pomiędzy listą parametrów, a wartością zwracaną. 

\begin{center}
\begin{lstlisting}[caption=Przykłady różnych specyfikatorów w Solidity, label=lst:przyklady_specyfikatorow]
pragma solidity ^0.4.0;

contract cont1 {
    uint private data;

    function func(uint x) private returns(uint y) { return x + 1; }
    function dataSet(uint x) { data = x; }
    function dataGet() public returns(uint) { return data; }
    function compute(uint x, uint y) internal returns (uint) { return x+y; }
}

contract cont2 {
    function dataRead() {
        cont1 z = new cont1();
        uint local = z.func(7); // error: member "func" is not visible
        z.dataSet(3);
        local = z.dataGet();
        local = z.compute(3, 5); // error: member "compute" is not visible
    }
}

contract cont3 is cont1 {
    function g() {
        cont1 z = new cont1();
        uint val = compute(3, 5); // access to internal member (from derived to parent contract)
    }
}
\end{lstlisting}
\end{center} 

Na listingu \ref{lst:przyklady_specyfikatorow} widać przykład trzech kontraktów posiadających funkcje z różnego rodzaju specyfikatorami. Kontrakt \textbf{cont1} posiada funkcję prywatną \textbf{func}. Oznacza to, że może ona zostać wywołana tylko wewnątrz kontraktu. W przypadku gdy w kontrakcie \textbf{cont2} zostanie utworzony obiekt kontraktu \textbf{cont1}, to podczas odwołania się do funkcji \textbf{func} z kontraktu \textbf{cont1} programista otrzyma błąd kompilacji. \cite{soliditygetterfunction}

W kontrakcie \textbf{cont1} znajduje się wewnętrzna funkcja \textbf{compute}. Mimo tego, że nie można jej wywołać z innego kontraktu, to można wykorzystać dziedziczenie w celu wywołania tej funkcji. Kontrakt \textbf{cont3} jest przykładem takiego rozwiązania. Kontrakt \textbf{cont3} dziedziczy po \textbf{cont1}, a następnie prawidłowo wywołuje wewnętrzną funkcję kontraktu \textbf{cont1}.\cite{soliditygetterfunction}

\section{Generowanie akcesorów podczas kompilacji}

Kompilator podczas kompilacji tworzy zewnętrze akcesory dla wszystkich zmiennych z modyfikatorem public.

\begin{center}
\begin{lstlisting}[caption=Przykład zmiennej publicznej w Solidity, label=lst:przyklad_zmiennej_public]
pragma solidity ^0.4.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // internal access
        uint val = this.data(); // external access
    }
}
\end{lstlisting}
\end{center} 

Na listingu \ref{lst:przyklad_zmiennej_public} widać zadeklarowaną zmienną \textbf{data} z modyfikatorem public. Dla takich zmiennych tworzony jest akcesor zewnętrzny, oznacza to, że można go wywołać tylko na zewnątrz kontaktu. Natomiast można również odwołać się do zmiennej wewnątrz kontraktu bez wykorzystywania akcesora.\cite{soliditygetterfunction}

\begin{center}
\begin{lstlisting}[caption=Przykłady bardziej skomplikowanej zmiennej publicznej w Solidity, label=lst:przyklad_skomplikowanej_zmiennej_public]
pragma solidity ^0.4.0;

contract RealyComplex {
    struct Data {
        uint foo;
        bytes3 bar;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}
\end{lstlisting}
\end{center} 


Na listingu \ref{lst:przyklad_skomplikowanej_zmiennej_public} widać bardziej skomplikowany przykład tworzenia funkcji na podstawie publicznej zmiennej. W tym przypadku funkcja, która zostanie wygenerowana, będzie wyglądać następująco:

\begin{verbatim}
function data(uint x1, bool x2, uint x3) 
returns (uint foo, bytes3 bar) {
foo = data[x1][x2][x3].foo;   bar = data[x1][x2][x3].bar; }
\end{verbatim}

Warto zauważyć, że mapa znajdująca się w strukturze jest pomijana, ponieważ nie ma dobrego sposobu na przekazanie klucza mapy do struktury.\cite{soliditygetterfunction} 

\section{Interakcja z inteligentnymi kontraktami}

Inteligentne kontrakty po umieszczeniu na blockchanie są przechowywane w postaci kodu bajtowego, a wszystkie sygnatury funkcji kontraktu są zahaszowane podczas kompilacji. W celu ułatwienia innym korzystania z tworzonych kontraktów utworzono specyfikacje ABI, dzięki której użytkownik kontraktu może uzyskać informacje o metodach interakcji.

\subsection{Czym jest ABI?}

ABI(Application Binary Interface) jest to ustandaryzowany sposób interakcji z kontraktem w sieci Ethereum. Ułatwia on wykorzystywanie funkcji udostępnionych przez kontrakty. ABI zawiera specyfikacje udostępnionych przez kontrakt funkcji wraz z nazwami i typami danych wejściowych i wyjściowych. Na podstawie ABI można wygenerować selektor funkcji, który umożliwia wywołanie konkretnej funkcji na kodzie bajtowym kontraktu.\cite{whatisabi}

Podczas upubliczniania kontraktu w sieci Ethereum, zalecane jest upublicznienie kodu źródłowego kontraktu z danymi umieszczonych w konstruktorze, wersją kompilatora oraz flagami użytymi podczas kompilacji kontraktu. Dzięki temu użytkownicy mogą zweryfikować czy kontrakt umieszczony w sieci pasuje do upublicznionego kodu źródłowego, a upubliczniony kod źródłowy sprawi, że kontrakt umieszczony w sieci będzie bardziej zaufany wśród innych użytkowników.

Jeśli twórca kontraktu nie chce udostępniać swojej implementacji, a chciałby, żeby inni użytkownicy mogli wygodnie korzystać z jego kontraktu powinien upublicznić ABI.

Istnieją też w sieci Ethereum kontrakty, których kod źródłowy, czy ABI nie zostało nigdzie upublicznione, w związku z tym ciężko jest ustalić, w jaki sposób prowadzić interakcję z takimi kontraktami. W takich sytuacjach konieczne jest wykorzystanie metod inżynierii wstecznej, baz danych sygnatur funkcji oraz innych aplikacji umożliwiających identyfikację takiego kodu bajtowego.

\subsection{Przykład interakcji z innym kontraktem}

\begin{center}
\begin{lstlisting}[caption=Przykład wywołania metody z innego kontraktu, label=lst:przyklad_wywolania_innego_kontraktu]
pragma solidity ^0.4.18;
contract ExistingWithoutABI  {
    
    address dc;
    
    function ExistingWithoutABI(address adr) public {
        dc = adr;
    }
    
    function setA_Signature(uint value) public returns(bool success){
        require(dc.call(bytes4(keccak256("setA(uint256)")), value));
        return true;
    }
}
\end{lstlisting}
\end{center} 

Na listingu \ref{lst:przyklad_wywolania_innego_kontraktu} widać przykład interakcji z innym udostępnionym w sieci kontraktem. W konstruktorze podawany jest adres kontraktu, na którym następnie będą wywoływane operacje. Jeśli osoba korzystająca z kontraktu ma informacje o jego sygnaturach funkcji, to łatwo może taką funkcję wywołać. 

W celu wywołania funkcji na innym kontrakcie została użyta metoda \textbf{call} na zmiennej \textbf{dc}. Zmienna \textbf{dc} jest adresem innego kontraktu.  Metoda \textbf{call} przyjmuje selektor funkcji którą zostanie wywołana oraz przekazywaną wartość. Selektor funkcji jest tworzony z sygnatury \textbf{setA(uint256)}, poprzez utworzenie skrótu za pomocą SHA3 oraz pobranie czterech pierwszych bajtów z utworzonego skrótu.

\subsubsection{Sygnatura funkcji}

Sygnatura funkcji, która jest wykorzystywana do tworzenia selektora funkcji, musi zostać odpowiednio zakodowana według specyfikacji ABI.\cite{whatisabi} Warto zwrócić uwagę, że sygnatura funkcji może zostać utworzona również dla automatycznie generowanych akcesorów opisanych w poprzednim podrozdziale.

Sygnatura funkcji składa się z nazwy funkcji oraz otoczonej nawiasami listy typów parametrów oddzielonych przecinkami. Wszystkie typy parametrów należy sprowadzić do postaci kanonicznej.

\begin{center}
\begin{lstlisting}[caption=Listing przedstawiający rożne sygnatury funkcji, label=lst:rozne_sygnatury_funkcji]
pragma solidity >=0.4.16 <0.7.0;

contract Foo {
  function bar(bytes3[2] memory) public pure {}
  function sam(bytes memory, bool, uint[] memory) public pure {}
  function baz(uint32 x, bool y) public pure returns (bool z) { z = x > 12 || y; }
}
\end{lstlisting}
\end{center} 


Na listingu \ref{lst:rozne_sygnatury_funkcji} widać przykład trzech metod. Sygnatury funkcji dla tych metod będą wyglądały następująco:

\begin{enumerate}
\item \textbf{bar(bytes3[2])}
\item \textbf{sam(bytes,bool,uint256[])}
\item \textbf{baz(uint32,bool)}
\end{enumerate}

W przypadku funkcji \textbf{sam} parametr \textbf{uint} został sprowadzony do postaci kanonicznej, czyli do typu \textbf{uint256}. Ze wszystkich trzech funkcji widocznych na listingu zostały wyciągnięte tylko typy ich parametrów oraz nazwa funkcji.

Język Solidity wspiera wszystkie typy wykorzystywane w ABI, natomiast niektóre typy z Solidity nie są obsługiwane przez ABI.


\begin{table}[ph!]
%\begin{table}
\centering
\caption{Mapowanie typów Solidity do ABI}\label{tab:mapowanietypow}
\begin{tabular}{| c | c | m{15pt}}\hline \rule[5mm]{0cm}{0mm}
Solidity & ABI \\ \hline\hline
address payable & \textbf{address} \\ \hline
contract & \textbf{address} \\ \hline
enum & \makecell{najmniejszy typ \textbf{uint}, \\który przechowa wszystkie wartości} \\ \hline
uint & \textbf{uint256} \\ \hline
int & \textbf{int256} \\ \hline
byte & \textbf{bytes1} \\ \hline
fixed & \textbf{fixed128x18}  \\ \hline
ufixed & \textbf{ufixed128x18} \\ \hline
\end{tabular}
\end{table} 

Na tabeli \ref{tab:mapowanietypow} po lewej stronie widać typy, które nie są wspierane przez ABI, a po prawej typy, które są częścią ABI. W przypadku typów uint, int, byte, fixed, ufixed są to aliasy, dlatego należy je również sprowadzić do postaci kanonicznej. Typy fixed i ufixed nie są obecnie zaimplementowane w Solidity.\cite{soliditytypes}



% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Rozdział 3.
%____________________________________________________________________________________________
\chapter[Projekt Aplikacji]{Projekt Aplikacji}
Celem mojej pracy licencjackiej było stworzenie aplikacji internetowej umożliwiającej identyfikację inteligentnych kontraktów w sieci Ethereum. Dzięki aplikacji użytkownik po wprowadzeniu na stronie kodu bajtowego kontraktu jest w stanie otrzymać najbardziej prawdopodobną implementacje kontraktu napisana w języku Solidity.

Aplikacja została stworzona przy wykorzystaniu frameworka Spring Boot, modułu Spring Data MongoDB oraz Spring MVC. Natomiast w celu przechowywania danych wykorzystano nierelacyjną bazę danych MongoDB.

W tym rozdziale znajduje się opis funkcjonalności, architektury, implementacji oraz wykorzystanych technologi.
\section{Opis funkcjonalności}


Na stronie głównej aplikacji znajduje się opis wraz z aktualna liczba kodów źródłowych znajdujących się w bazie danych oraz podstawowe definicje związane z aplikacją. Cała aplikacji udostępnia trzy główne funkcjonalności: identyfikację inteligentnych kontraktu, wprowadzanie plików źródłowych kontraktów do aplikacji oraz interfejs programistyczny aplikacji. Wszystkie funkcjonalności zostały opisane poniżej.

\subsection{Identyfikacja inteligentnych kontraktów}
Pierwszą opcją dostępną w  aplikacji jest identyfikacja inteligentnych kontraktów. Zarówno na stronie głównej widocznej na rysunku \ref{rys:strona_glowna}, jak i podstronie  znajduje się pole, w którym można wprowadzić kod bajtowy. Po wprowadzeniu danych użytkownik zatwierdza je, w obu przypadkach klikając przycisk \textbf{Identify}.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.50]{strona_glowna.png}
\caption{Strona główna}
\label{rys:strona_glowna}
\end{figure}


Po wprowadzeniu danych i zatwierdzeniu ich przyciskiem, aplikacja rozpoczyna proces analizy wprowadzonego kodu bajtowego oraz wyszukiwane jest dziesięć najbardziej prawdopodobnych implementacji kontraktów (posortowanych malejąco według współczynnika dopasowania). Na rysunku \ref{rys:wynik_identyfikacji} został przedstawiony przykładowy wynik identyfikacji.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.55]{wynik_identyfikacji.png}
\caption{Wynik identyfikacji inteligentnego kontraktu}
\label{rys:wynik_identyfikacji}
\end{figure}


Po naciśnięciu w jedną z wyświetlanych implementacji użytkownik zostanie przeniesiony na podstronę umożliwiającą podgląd implementacji. Na rysunku \ref{rys:podglad_impelementacji} znajduje się przykład przeglądania kodu źródłowego na stronie. Rozwiązanie z numerowaniem linii zostało zaimplementowane w taki sposób, aby podczas kopiowania kodu źródłowego ze strony, nie były kopiowane z nim liczby identyfikujące konkretną linię w kodzie. Istnieje też możliwość pobrania kodu źródłowego ze strony z rozszerzeniem \textbf{.sol}


\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{podglad_impelementacji.png}
\caption{Podgląd implementacji}
\label{rys:podglad_impelementacji}
\end{figure}

\subsection{Dodanie kodu źródłowego kontraktu do aplikacji}
Strona umożliwia dodanie własnego kodu źródłowego kontraktu napisanego w języku \textbf{Solidity}. W tym celu należy zalogować się za pomocą panelu logowania, który zostaje wyświetlony automatycznie przy próbie korzystania z autoryzowanych funkcjonalności aplikacji. Po kliknięciu w \textbf{Identify Solidity} oraz zalogowaniu się na stronie, pojawiają się dwie możliwości wprowadzania kodów źródłowych.


Pierwszym sposobem jest przesłanie do aplikacji pliku zawierającego implementacje kontraktu. W tym celu użytkownik powinien nacisnąć przycisk \textbf{Browse} i wybrać konkretny plik, a następnie zatwierdzić go przyciskiem \textbf{Upload} widocznym na rysunku \ref{rys:ekran_pozuploadowaniu}. 


Innym sposobem na przesłania kodu źródłowego do aplikacji jest wklejenie kodu źródłowego bezpośrednio do formularza znajdującego się po prawej stronie.


Po prawidłowym dodaniu kodu źródłowego do aplikacji użytkownik powinien zobaczyć podobny rezultat do tego na rysunku \ref{rys:ekran_pozuploadowaniu}. W momencie dodania nowej implementacji, na stronie pojawia się hasz dodanego pliku oraz lista sygnatur funkcji wraz z ich selektorami. Po naciśnięciu na wyświetlany na rysunku \ref{rys:ekran_pozuploadowaniu} hasz pliku, użytkownikowi wyświetli się przesłany kod źródłowy.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.6]{ekran_pozuploadowaniu.png}
\caption{Rezultat przesłania inteligentnego kontraktu do aplikacji}
\label{rys:ekran_pozuploadowaniu}
\end{figure}


\subsection{Interfejs programistyczny aplikacji}
Trzecią funkcjonalnością aplikacji jest interfejs programistyczny. Dzięki niemu można wykorzystać mechanizmy zaimplementowane w aplikacji w innej aplikacji. Przykładowym zastosowaniem API jest utworzenie skryptu umożliwiającego zautomatyzowane wysyłanie kodów źródłowych do aplikacji, bez konieczności korzystania z interfejsu graficznego aplikacji.\cite{whatisapi}

Użytkownik za pomocą API ma możliwość pobrania informacji o kodzie źródłowym, identyfikacji kontraktu oraz przesłania nowego kontraktu do aplikacji.


\subsubsection{Pobieranie informacji o kodzie źródłowym z API}

Podczas pobierania informacji o kodzie źródłowym, użytkownik musi posiadać identyfikator pliku, który chce pobrać. Żądanie pobierające plik z API można zobaczyć na listingu \ref{lst:zadanieokodzrodlowy}. W odpowiedzi użytkownik dostaje zwykły tekst zawierający implementację kontraktu oraz status HTTP 200, 404 lub 500. Status 200 oznacza, że wszystko poszło pomyślnie. W sytuacji, gdy użytkownik otrzyma status 404, oznacza to, że nie udało się znaleźć implementacji o podanym haszu. Odpowiedz zawierająca status 500 oznacza, że wystąpił błąd na serwerze i nie udało się zwrócić kodu źródłowego.\cite{resthttpstatuscode}

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Żądanie wysyłane w celu pobrania kodu źródłowego, label=lst:zadanieokodzrodlowy]
GET /api/sourceCode/0x06c61b8e505d7a407af9a91bdff8085560e90a133c77ab32bde32e686f6a8d52.sol HTTP/1.1
Host: localhost:8080
Accept: text/plain;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
\end{lstlisting}
\end{center}



\subsubsection{Identyfikacja inteligentnego kontraktu za pomocą API}
W celu identyfikacji kontraktu należy wysłać żądanie pod adres \mbox{/api/bytecode}. W ciele żądania jest wymagane od użytkownika podanie kodu bajtowego, służącego do identyfikacji. Poprawny przykład żądania można zobaczyć na listingu \ref{lst:identyfikacjaapi}.\cite{urlencodedform}


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Żądanie wysylane w celu identyfikacji kontraktu za pomocą API, label=lst:identyfikacjaapi]
POST /api/bytecode HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Content-Length: 26

60803350200fe56abcede00229

\end{lstlisting}
\end{center}

Na listingu \ref{lst:identyfikacjaapi} został wprowadzony kod bajtowy kontraktu. W żądaniu został wprowadzony nagłówek \textbf{Content-Length} określający długość przesyłanych danych oraz \textbf{Content-Type} oznaczający rodzaj przesyłanych danych. 


Jeśli wszystko poszło pomyślnie, użytkownik otrzyma status HTTP 200 wraz z listą składającą się z haszu pliku i współczynnika dopasowania danego pliku w formacie JSON. W przypadku gdy nie zostanie dopasowana żadna implementacja, to aplikacja zwróci status 404, natomiast jeśli w aplikacji wystąpi błąd, to zostanie zwrócony status 500.


\subsubsection{Przesyłanie nowego kodu źródłowego za pomocą API}

Gdy użytkownik chce przesłać nowy kontrakt do aplikacji, musi przejść proces uwierzytelniania. W tym celu należy do żądania dodać nagłówek \textbf{Authorization}. W nagłówku należy podać typ autoryzacji oraz zakodowane dane logowania za pomocą kodowania Base64 według schematu \textbf{login:haslo}. Na przykładzie z listingu \ref{lst:dodaniedoapi} został przesłany kod źródłowy, natomiast do autoryzacji wykorzystano login 123 oraz hasło 123.

\begin{center}
\begin{lstlisting}[caption=Przesyłanie kodu źródłowego za pomocą API, label=lst:dodaniedoapi]
POST /api/solidityFiles HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Accept: application/json
Authorization: Basic MTIzOjEyMw==
Content-Length: 221
Accept: application/json

pragma solidity ^0.4.21;
contract Hello {
    string public message;
    function setMessage(string newMessage) public {
        message = newMessage;
    }
}

\end{lstlisting}
\end{center}



Po pomyślnym przesłaniu kontraktu w odpowiedzi od serwera użytkownik otrzymuje status HTTP 200. W odpowiedzi zostaje również przesłany kod źródłowy, hasz stworzony na podstawie kodu źródłowego oraz listę znalezionych sygnatur funkcji wraz z ich selektorami. W przypadku wystąpienia błędu na serwerze zostaje zwrócony status 500. Na listingu \ref{lst:przykladodpowiedzijson} można zaobserwować przykładowe dane zawarte w odpowiedzi od serwera.

\begin{center}
\begin{lstlisting}[caption=Przykładowa odpowiedz w formacie JSON, label=lst:przykladodpowiedzijson]
{
    "sourceCodeHash": "0x8dea780e1286d12a957d40597b9171a5187f87f6e3f8303505bc53a4453ad5b6",
    "sourceCode": "pragma solidity ^0.4.21;\r\ncontract Hello {\r\n    string public message;\r\n    function setMessage(string newMessage) public {\r\n        message = newMessage;\r\n    }\r\n}",
    "solidityFunctions": [
        {
            "selector": "e21f37ce",
            "signature": "message()"
        },
        {
            "selector": "368b8772",
            "signature": "setMessage(string)"
        }
    ]
}
\end{lstlisting}
\end{center}


\section{Architektura aplikacji}

W tym podrozdziale opiszę architekturę aplikacji, która realizuje funkcjonalności opisane w sekcji 3.1. Poniżej zostały krótko opisane główne klasy będące częścią aplikacji, widoczne na rysunku \ref{rys:architektura}.

\begin{figure}[bp!]\centering 	
\includegraphics[scale=0.5]{architektura.png}
\caption{Architektura aplikacji}
\label{rys:architektura}
\end{figure}

\begin{description}
\item[LoginController] - jest to klasa odpowiedzialna za wyświetlenie ekranu logowania.

\item[ErrorController] - jej zadaniem jest przechwytywane wszystkich błędów w aplikacji. Po złapaniu błędu, zostaje wyświetlona użytkownikowi strona informująca, że pojawił się błąd w aplikacji, który jest zapisywany w logach aplikacji.

\item[BytecodeController] - służy do wyświetlania użytkownikowi strony związanej z identyfikacją kodu bajtowego oraz do mapowania żądań HTTP służących do identyfikacji. 

\item[SolidityApiController] - zadaniem tej klasy jest nasłuchiwanie adresów związanych z API, zwracanie danych do użytkownika w formacie \textbf{JSON} lub zwykłego tekstu oraz komunikowanie się z obiektem klasy \textbf{SolidityService} oraz \textbf{BytecodeService}. 

\item[SolidityController] - mapuje żądania HTTP związane z przetwarzaniem plików \textbf{Solidity} oraz umożliwia wyświetlenie użytkownikowi kodu źródłowego kontraktu.

\item[Disassembler] - odpowiada za analizę przekazanego kodu bajtowego. W rezultacie zwraca listę instrukcji zawartych w kodzie. Szczegółowe działanie tej klasy zostało opisane w dalszej części pracy, w sekcji 3.5 dotyczącej wyszukiwania selektorów funkcji w kodzie bajtowym. 

\item[SolidityParser] - wyciąga listę informacji o funkcjach z kodu źródłowego kontraktu. Lista zawiera takie informacje jak sygnatura oraz selektor funkcji. Sposób tworzenia selektorów funkcji oraz wyciągania z kodu źródłowego sygnatur funkcji został przedstawiony w sekcji 3.4

\item[SolidityService] - jest to klasa odpowiedzialna za odczytywanie danych z bazy danych oraz za przygotowanie przesłanych danych do zapisu w bazie danych.

\item[BytecodeService] - klasa odpowiada za dopasowywanie kodu bajtowego do kontraktu. W tym celu wykorzystywane są opisane powyżej klasy \textbf{Disassembler} oraz \textbf{SolidityService}, które w połączeniu umożliwiają wyznaczenie współczynnika dopasowania pomiędzy konkretnym plikiem a kodem bajtowym.

\item[SolidityFileRepository] - jest to część aplikacji odpowiedzialna za komunikację z bazą danych oraz mapowanie danych przechowywanych w bazie danych na obiekty zdefiniowane w kodzie aplikacji. Repozytorium jest interfejsem, który wykorzystuje moduł Spring Data MongoDB. Implementacja tego interfejsu spoczywa na frameworku Spring. Szczegóły łączenia z bazą danych zostały opisane w sekcji 3.3

\end{description}


\section{Połączenie z bazą danych}
W celu integracji aplikacji z bazą danych MongoDB został wykorzystany framework Spring oraz moduł Spring Data MongoDB. W związku z tym, że projekt aplikacji jest budowany za pomocą narzędzia Apache Maven, należy dodać do pliku \textbf{pom.xml} wykorzystywane moduły.\cite{mongoguide} 

Na listingu \ref{lst:dodaniezaleznosci} został przedstawiony fragment pliku \textbf{pom.xml} odpowiedzialny za dodawanie modułu \mbox{\textbf{spring-boot-start-data-mongodb}} do projektu. Dodawanie innych modułów jest analogiczne do przykładu z listingu.

\begin{center}
\lstset{language=XML}
\begin{lstlisting}[caption=Przyklad dodania zależności w pliku pom.xml, label=lst:dodaniezaleznosci]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
\end{lstlisting}
\end{center}

W pliku konfiguracyjnym \mbox{\textbf{application.properties}} zostały skonfigurowane dane do połączenia z bazą danych. Przykładowa zawartość pliku konfiguracyjnego została przedstawiona na listingu \ref{lst:applicationproperties}.\cite{mongoguide}
 
\begin{center}
\begin{lstlisting}[caption=Kofiguracja bazy danych, label=lst:applicationproperties]
admin.login=${ADMIN_LOGIN}
admin.password=${ADMIN_PASSWORD}
spring.data.mongodb.uri=${DB_URI}
server.port=${SERVER_PORT:8080}
\end{lstlisting}
\end{center}


Po skonfigurowaniu pliku \mbox{\textbf{pom.xml}} oraz \mbox{\textbf{application.properties}}, należało utworzyć interfejs \mbox{\textbf{SolidityFileRepository}}, który umożliwia serwisom aplikacji wykonywanie operacji na bazie danych oraz ustala mapowanie obiektów z bazy danych na obiekty klasy \mbox{\textbf{SolidityFile}}. Utworzone w aplikacji repozytorium można zobaczyć na listingu \ref{lst:repozytoriummongo}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Stworzenie repozytorium za pomocą Spring Data MongoDB, label=lst:repozytoriummongo]
@Repository
interface SolidityFileRepository extends MongoRepository<SolidityFile, String> {

    @Query("{\"solidityFunctions\": {$elemMatch: {\"selector\": {$in: ?0}}}}")
    List<SolidityFile> findSolidityFilesBySelectorContainsAll(List<String> functionSelector);

    Optional<SolidityFile> findBySourceCodeHash(String sourceCodeHash);
}
\end{lstlisting}
\end{center}

W pierwszej linii listingu \ref{lst:repozytoriummongo} znajduje się adnotacja \mbox{\textbf{@Repository}} pełniącą rolę stereotypu informującego framework, że ten interfejs jest wykorzystywany, w celu wykonywania operacji z bazą danych.

Kolejną adnotacją jest \mbox{\textbf{@Query}}. Parametrem tej adnotacji jest zapytanie do bazy danych MongoDB, wykonujące zapytanie o listę plików, które posiadają w sobie część przekazanych przez użytkownika selektorów funkcji. Za pomocą tej adnotacji można przypisać konkretnej metodzie z \mbox{\textbf{SolidityFileRepository}} konkretne zapytanie, które aplikacja ma wykonać.

Jeśli metoda w interfejsie nie posiada wspomnianej adnotacji, wtedy framework wygeneruje zapytanie do bazy danych, bazując na nazwie metody oraz przyjmowanych i zwracanych przez metodę typach danych.

Na listingu \ref{lst:przykladencji} została przedstawiona klasa \mbox{\textbf{SolidityFile}}, która reprezentuje obiekt przechowywany w bazie danych. Składa się ona z trzech atrybutów: haszu kodu źródłowego, kodu źródłowego, oraz listy funkcji znalezionych w tym kodzie źródłowym. 


Atrybut \textbf{sourceCodeHash} został utworzony, ponieważ baza danych nie umożliwia utworzenia unikalnego atrybutu w bazie danych z taką duża ilością znaków jak kod źródłowy. Tworzeniem haszu odbywa się w klasie \mbox{\textbf{SolidityService}} widocznej się na rysunku \ref{rys:architektura}. Hasz kodu źródłowego jest identyfikatorem, wiec posiada adnotację \mbox{\textbf{@Id}}.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Przyklad klasy wykorzystywanej przez Spring Data MongoDb, label=lst:przykladencji]
public class SolidityFile {
    @Id
    private final String sourceCodeHash;
    private final String sourceCode;
    private final Set<SolidityFunction> solidityFunctions;

    SolidityFile(String sourceCodeHash, String sourceCode, Set<SolidityFunction> solidityFunctions) {
        requireNonNull(sourceCodeHash, "Expected not-null sourceCodeHash");
        requireNonNull(sourceCode, "Expected not-null sourceCode");
        requireNonNull(solidityFunctions, "Expected not-null solidityFunctions");
        this.sourceCodeHash = sourceCodeHash;
        this.sourceCode = sourceCode;
        this.solidityFunctions = solidityFunctions;
    }

    public String getSourceCodeHash() { return sourceCodeHash; }
    public String getSourceCode() { return sourceCode; }
    public Set<SolidityFunction> getSolidityFunctions() { return solidityFunctions; }

    @Override
    public String toString() {
        return "SolidityFile{" + "sourceCodeHash='" 
                 + sourceCodeHash
        	 + '\'' + ", sourceCode='" + sourceCode + '\'' 
        	 + ", solidityFunctions=" + solidityFunctions + '}';}

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SolidityFile)) return false;
        SolidityFile that = (SolidityFile) o;
        return Objects.equals(sourceCodeHash, that.sourceCodeHash) &&
                Objects.equals(sourceCode, that.sourceCode) &&
                Objects.equals(solidityFunctions, that.solidityFunctions);}

    @Override
    public int hashCode() {
        return Objects.hash(sourceCodeHash, sourceCode, solidityFunctions);}
}
\end{lstlisting}
\end{center}

W momencie tworzenia obiektu klasy \textbf{SolidityFile}, konstruktor wywołuje metody sprawdzające, czy użytkownik nie wprowadził wartości \textbf{null}, ponieważ każdy obiekt plik musi posiadać hasz, kod źródłowy oraz listę funkcji.

Klasa \textbf{SolidityFunction}, która jest częścią klasy \textbf{SolidityFile}, posiada dwa atrybuty \textbf{selector} oraz \textbf{signature} typu tekstowego. Klasa ta nie wy wymagała tworzenia identyfikatora, wiec nie została użyta adnotacja \mbox{\textbf{@Id}} nad żadnym atrybutem.


\section{Identyfikacja sygnatur funkcji w kodzie źródłowym}


Wyszukiwanie sygnatur funkcji jest rozpoczynane podczas przesłania nowego kodu źródłowego do aplikacji. W momencie wyszukiwania sygnatur funkcji są generowane selektory funkcji, które są finalnie używane podczas identyfikacji kodu źródłowego. 

Problemem podczas wyszukiwania sygnatur w kodzie źródłowym jest to, że część sygnatur jest niejawna, ponieważ są one dodatkowo generowane podczas kompilacji dla wybranych atrybutów kontraktu.\cite{soliditygetterfunction} 


\subsection{Kontroler interfejsu programistycznego}

Na listingu \ref{lst:kontrolerapiupload} została przedstawiona metoda kontrolera \textbf{SolidityApiController} umożliwiająca przesyłanie kodu źródłowego. Adnotacje, które wykorzystuje ta metoda, są częścią modułu Spring MVC. Pierwszą adnotacją wykorzystaną w metodzie jest \textbf{@PostMapping}, która zajmuje się mapowaniem żądań HTTP przesyłanych do API. W parametrze tej adnotacji podany został adres, pod którym aplikacja oczekuje żądania.\cite{springmvc} 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda kontrolera mapująca żądania POST, label=lst:kontrolerapiupload]
@PostMapping("/api/solidityFiles")
public ResponseEntity<SolidityFile> uploadFile(@RequestBody String sourceCode) throws IOException {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    return ResponseEntity.ok(solidityService.save(sourceCode));
}
\end{lstlisting}
\end{center}

Kolejną adnotacją jest \mbox{\textbf{@RequestBody}}. Adnotacja ta informuje framework o tym, żeby ciało żądania HTTP było umieszczone pod wskazaną zmienną. 

Podczas zwracania danych w API wykorzystana została klasa \textbf{ResponseEntity}. Jest to wrapper umożliwiający zwrócenie statusu HTTP wraz z danymi. Informacja z tej klasy jest wykorzystywana przez framework podczas tworzenia odpowiedzi HTTP.

Głównym celem tej metody jest zapisanie nowego kodu źródłowego do aplikacji, w związku z tym na listingu \ref{lst:kontrolerapiupload} widać wywołanie metody \textbf{save} na atrybucie \mbox{\textbf{solidityService}}.


\subsection{Kontroler strony internetowej}

\textbf{SolidityControler} jest to klasa odpowiedzialna, za tworzenie strony internetowej korzystając z szablonów HTML oraz modułu Thymeleaf. Listing \ref{lst:uploadowanie} przedstawia metodę przyjmująca w żądaniu HTTP kod źródłowy. Metoda ta działa podobnie jak w przypadku API, tylko w tym przypadku zwracana zostaje zwrócona nazwa szablonu wykorzystywanego do renderowania strony. Istnieje możliwość przekazania danych do szablonu, w tym celu wykorzystywany jest parametr \textbf{model}, na którym wywoływana jest metoda \textbf{addAttribute}.\cite{thymeleafguide}

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Przechwytywanie żądania o dodanie nowego kodu źródłowego, label=lst:uploadowanie]
@PostMapping("/solidity/text")
public String handleSourceCodeUpload(@RequestParam("sourceCode") String sourceCode, Model model) throws Exception {
    requireNonNull(sourceCode, "Expected not-null sourceCode");
    requireNonNull(model, "Expected not-null model");

    SolidityFile savedSolidityFile = solidityService.save(sourceCode);

    model.addAttribute("solidityFileFunctions", savedSolidityFile.getSolidityFunctions());
    model.addAttribute("solidityFileHash", savedSolidityFile.getSourceCodeHash());
    return "solidity-page";
}
\end{lstlisting}
\end{center}

\subsection{Przetwarzanie kodu źródłowego}

\textbf{SolidityService} po otrzymaniu kodu źródłowego od kontrolerów przekazuje po jednej linii do  \textbf{SolidityParser}, który definiuje czy w danej linii jest sygnatura funkcji. Jeśli podczas parsowania linii znaleziono sygnaturę funkcji, to zostaje ona dodana wraz z selektorem do listy funkcji. Po przeanalizowaniu wszystkich linii tworzony jest obiekt \textbf{SolidityFile}, który następnie za pomocą \textbf{SolidityFileRepository} jest zapisywany do bazy danych.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnatury funkcji, label=lst:wyszukiwaniesygnaturyfunkcji]
Optional<SolidityFunction> findFunctionInLine(String line) {
    List<Optional<SolidityFunction>> functions =
            Stream.of(
                    findFunctionSignature(line),
                    findMappingGetter(line),
                    findArrayGetter(line),
                    findNormalVariableGetter(line)
            ).filter(Optional::isPresent).collect(toList());

    if (functions.size() > 1) {
        throw new IllegalStateException("Expected only one function, but found :" + functions.size());
    } else if (functions.size() == 1) {
        return functions.listIterator().next();
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center}

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} widać metodę klasy \textbf{SolidityParser} wyszukującą funkcję w implementacji kontraktu. Metoda po przyjęciu linii w rezultacie zwraca obiekt klasy \textbf{Optional<SolidityFunction>}.\cite{baeldungoptional} Metoda sprawdza cztery możliwe przypadki, w których istnieje możliwość wykrycia funkcji w kodzie źródłowym kontraktu.

Do wykrywania błędów podczas wyszukiwania funkcji sprawdzane są wszystkie cztery przypadki, jeśli okaże się, że więcej niż jedna metoda wykryła funkcję, oznacza to, że jedna z metod działa niepoprawnie i fałszywie wykrywa funkcje. Wszystkie cztery przypadki zostały opisane poniżej.


\subsubsection{Wykrywanie sygnatury zadeklarowanej funkcji}

Pierwszym przypadkiem są funkcje jawnie zadeklarowane w kodzie źródłowym nie posiadające modyfikatora \textbf{internal} lub \textbf{private}. Wykrywaniem takiej funkcji zajmuje się metoda \textbf{findFunctionSignature} widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji}. Do wyszukiwania sygnatury zadeklarowanej funkcji zostało wykorzystane wyrażenie regularne zaprezentowane poniżej:

\begin{lstlisting}[numbers=none]
^\s*function\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*([^(){}]*)\s*\)\s*(?!.*(internal|private)).*$
\end{lstlisting}

Pierwsza grupa w wyrażeniu wyciąga z linii kodu źródłowego nazwę funkcji, natomiast druga parametry funkcji. Wyrażenie wyszukuje w pojedynczej linii kodu źródłowego frazy \textbf{function}, po której następuje nazwa funkcji oraz lista parametrów w nawiasach.\cite{soliditygrammar}

Na listingu \ref{lst:wyszukiwaniesygnaturyfunkcjizfunkjci} została przedstawiona metoda wyszukującą sygnaturę funkcji za pomocą przedstawionego wyrażenia regularnego.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukująca sygnaturę funkcji, label=lst:wyszukiwaniesygnaturyfunkcjizfunkjci]
private Optional<SolidityFunction> findFunctionSignature(String line) {
    Matcher matcher = FUNCTION_PATTERN.matcher(line);
    if (matcher.find()) {
        String functionName = matcher.group(FUNCTION_NAME_GROUP_ID);
        String functionArguments = matcher.group(FUNCTION_ARGUMENTS_GROUP_ID);
        String functionSignature = normalizeFunctionSignature(functionName, functionArguments);
        String functionSelector = getFunctionSelector(functionSignature);
        return Optional.of(new SolidityFunction(functionSelector, functionSignature));
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center}

Po wykryciu funkcji za pomocą wyrażenia regularnego wyciągana jest informacja o parametrach i nazwie funkcji z przekazanej linii. Za pomocą wyciągniętych informacji metoda \textbf{normalizeFunctionSignature} tworzy sygnaturę funkcji. Sygnatura składa się z nazwy oraz typów parametrów funkcji podanych w nawiasie. Niektóre typy parametrów zostają sprowadzone do postaci kanonicznej, natomiast pozostałe typy pozostają bez zmian. Poniżej zostały przedstawione typy, które zostają sprowadzane do postaci kanonicznej:


\begin{center}
uint => uint256\\
int => int256\\
byte => bytes1\\
fixed => fixed128x18\\
ufixed => ufixed128x18
\end{center}

Po utworzeniu sygnatury funkcji zostaje wygenerowany selektor. Na listingu \ref{lst:metoda_generująca_selektor_funkcji} została przedstawiona metoda tworząca selektor. Sygnatura funkcji zostaje haszowana za pomocą funkcji \textbf{sha3String}, ktora pochodzi z biblioteki web3j, następnie z hasza pobierane są cztery pierwsze bajty, które są selektorem funkcji. Metoda \textbf{sha3String} zwraca hasz w systemie szesnastkowym w postaci napisu, dlatego wyłuskiwane są znaki od dwa do dziesięć. 

\begin{center}
\lstset{language=java}
\begin{lstlisting}[caption=Metoda generująca selektor funkcji, label=lst:metoda_generująca_selektor_funkcji]
private String getFunctionSelector(String normalizedFunctionSignature) {
    return sha3String(normalizedFunctionSignature).substring(2, 10);
}
\end{lstlisting}
\end{center}

Po pomyślnej identyfikacji zadeklarowanej funkcji zwracany jest obiekt \textbf{Optional<SolidityFunction>} przez metodę \textbf{findFunctionSignature}. Analizując w ten sposób każdą linię kodu źródłowego kontraktu, \textbf{SolidityService} uzyskuje zbiór obiektów \textbf{SolidityFunction}.

\subsubsection{Generowanie sygnatury funkcji dla publicznych atrybutów typu mapa}

Drugim rodzajem jest atrybut publiczny typu \textbf{mapping}. W tym przypadku nie zostało jawnie pokazane, że istnieje w kodzie źródłowym sygnatura funkcji, ponieważ jest ona generowana przez kompilator.\cite{soliditygetterfunction} W tej sekcji przedstawię proces generowania sygnatury funkcji na podstawie wspomnianego atrybutu. 

W celu wykrycia deklaracji mapy w kodzie źródłowym, zostało wykorzystane wyrażenie regularne przedstawione poniżej:

\begin{lstlisting}[numbers=none]
^\\s*mapping\\s*\\(\\s*([a-zA-Z][a-zA-Z]*)\\s*=>\\s*(.*)\\s*\\)\\s*public\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*(=.*)?\\s*;+\\s*(//.*)?$
\end{lstlisting}


Pierwsza grupa w wyrażeniu regularnym oznacza typ klucza mapy, natomiast druga typ zwracanej wartości przez mapę. Trzecia grupa oznacza nazwę atrybutu, która również jest nazwa sygnatury funkcji. Typ klucza mapowania jest umieszczany w parametrze tworzonej sygnatury funkcji. Jeśli typ zwracany przez mapę jest typem tablicowym lub kolejną mapą, wtedy należy dodać kolejny parametr do sygnatury funkcji. 

Na listingu \ref{lst:petla_szukajaca_tablic_lub_map} została przedstawiona pętla, która jest częścią metody \textbf{findMappingGetter}. Pętla działa dopóki występuje zagnieżdżanie map. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Pętla wyszukująca tablicę lub mapę w typie zwracanym przez mapę, label=lst:petla_szukajaca_tablic_lub_map]
while (true) {
    Matcher mappingMatcher = MAPPING_PATTERN.matcher(mappingValue);
    Matcher arrayMatcher = ARRAY_PATTERN.matcher(mappingValue);

    if (mappingMatcher.find()) {
        String canonicalArgument = toCanonicalType(mappingMatcher.group(MAPPING_KEY_GROUP_ID));
        canonicalMappingKeys.add(canonicalArgument);
        mappingValue = mappingMatcher.group(MAPPING_VALUE_GROUP_ID);
        continue;
    }
    if (arrayMatcher.find()) {
        String arrayValue = arrayMatcher.group(ARRAY_VALUE_GROUP_ID);
        int dimensionCount = getArrayDimensionCount(arrayValue);
        for (int i = 0; i < dimensionCount; i++) {
           canonicalMappingKeys.add(CANONICAL_ARRAY_KEY_TYPE);
        }
    }
    break;
} 
\end{lstlisting}
\end{center}     

Do wyszukiwania map w typie zwracanym przez poprzednią mapę zostało wykorzystane następujące wyrażenie regularne:

\begin{lstlisting}[numbers=none]
^\s*mapping\s*\(\s*([a-zA-Z0-9][a-zA-Z0-9]*)\s*=>\s*(.*)\s*\)\s*
\end{lstlisting}

Pierwsza grupa wyrażenia wyciąga z fragmentu deklaracji mapy informacje o typie klucza, natomiast druga o typie zwracanej przez nią wartości.
Typ klucza zagnieżdżonej mapy jest dodawany do listy typów parametrów generowanej sygnatury funkcji, natomiast typ zwracany przez mapę jest wykorzystany z tym samym wyrażeniem regularnym w kolejnej iteracji pętli. 

W przypadku, gdy nie wykryto mapy, jest sprawdzane, czy zwracanym typem jest tablica. W tym celu wykorzystane zostało następujące wyrażenie regularne:

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*((\s*\[\s*[a-zA-Z0-9]*\s*]\s*)+)\s*
\end{lstlisting}

W wyrażeniu została określona grupa, która służy do wyznaczenia ilości wymiarów tablicy. Dla każdego wymiaru zostaje dodany parametr typu \textbf{uint256} do listy parametrów sygnatury. Wspomniany parametr reprezentuje indeks tablicy. Wykrycie tablicy w typie zwracanym przez mapę jest równoznaczne z ostatnią iteracja pętli.

Ostatnim krokiem jest wygenerowanie sygnatury funkcji za pomocą nazwy funkcji oraz listy zgromadzonych typów parametrów. Wszystkie typy przed dodaniem do listy zostają najpierw sprowadzone do postaci kanoniczej.

Na listingu \ref{lst:tworzenie_solidity_function} widać w jaki sposób jest formułowana sygnatura funkcji, następnie jest generowany z jej selektor oraz tworzony obiekt typu\\ \textbf{Optional<SolidityFunction>}.


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Tworzenie SolidityFunction na podstawie nazwy funkcji i listy typów, label=lst:tworzenie_solidity_function]
String functionSignature = mappingName + "(" + join(",", canonicalMappingKeys) + ")";
String functionSelector = getFunctionSelector(functionSignature);
return Optional.of(new SolidityFunction(functionSelector, functionSignature));
\end{lstlisting}
\end{center}   

\subsubsection{Wykrywanie sygnatury funkcji dla publicznych atrybutów typu tablicowego}

Trzecią metodą widoczną na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} jest \textbf{findArrayGetter}. Metoda służy do wykrywania publicznego atrybutu, który jest tablicą i w tym celu wykorzystuje wyrażenie regularne przedstawione poniżej:


\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*((\s*\[\s*[a-zA-Z0-9]*\s*]\s*)+)\s*public\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*(=.*)?\s*;+\s*(//.*)?$
\end{lstlisting}

Wyrażenie to wyszukuje w linii kodu źródłowego publiczny atrybut tablicowy. Pierwsza grupa w wyrażeniu wyodrębnia nawiasy definiujące ilość wymiarów tablicy. Kolejna grupa, znajdująca się po wyrazie \textbf{public}, reprezentuje nazwę atrybutu. Wyrażenie regularne bierze pod uwagę możliwość inicjalizacji wartości podczas deklaracji atrybutu.


Liczba wymiarów tablicy zostaje określona na podstawie liczby podanych nawiasów podczas deklaracji tablicy. Dla każdego wymiaru zostaje dodany typ \textbf{uint256} do listy typów parametrów, ponieważ tablica posiada numeryczny indeks.\cite{solidityarrayindex}

 Bazując na nazwie oraz liście typów tworzony jest obiekt\\ \textbf{Optional<SolidityFunction>} w analogiczny sposób, jaki został przedstawiony na listingu \ref{lst:tworzenie_solidity_function}.

\subsubsection{Wykrywanie sygnatury funkcji dla pozostałych publicznych atrybutów}
    
Ostatnim przypadkiem, który należało rozpatrzyć podczas wykrywania sygnatury funkcji, są wszystkie atrybuty zadeklarowane jako publiczne niebędące tablicami lub mapami. Ten przypadek odzwierciedla metoda \textbf{findNormalVariableGetter} widoczna na listingu \ref{lst:wyszukiwaniesygnaturyfunkcji} jako ostatnia z czterech metod wykorzystywany do analizy linii kodu źródłowego. Zostało zastosowane tutaj wyrażenie regularne przedstawione poniżej: 

\begin{lstlisting}[numbers=none]
^\s*[a-zA-Z0-9][a-zA-Z0-9]*\s*(\bconstant)*\s*public\s*(\bconstant)*\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*(=.*)?\s*;+\s*(//.*)?$
\end{lstlisting}

Wyrażenie regularne wyszukuje linię, w której znajduje się deklaracja atrybutu publicznego, który może opcjonalnie posiadać modyfikator \textbf{constant}. Wyrażenie deklaracje atrybutow bez typu \textbf{mapping} oraz tablic. 

Sygnatura funkcji składa się z nazwy atrybutu wyodrębnianej za pomocą grupy zdefiniowanej w wyrażeniu regularnym. W tym przypadku sygnatura funkcji nie posiada żadnych parametrów, wiec wystarczy po nazwie dodać pusty nawias. 

Selektor funkcji jest generowany analogicznie jak w pozostałych przypadkach. Na listingu \ref{lst:metoda_nie_tablica_nie_mapa} widać metodę \textbf{findNormalVariableGetter} generującą sygnaturę na podstawie tego rodzaju atrybutu.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukujaca sygnature funkcji dla atrybutów niebędących mapą ani tablica, label=lst:metoda_nie_tablica_nie_mapa]
private Optional<SolidityFunction> findNormalVariableGetter(String line) {
    Matcher matcher = NORMAL_VARIABLE_PATTERN.matcher(line);
    if (matcher.find()) {
        LOGGER.info("Found public normal variable: {}", line);
        String variableName = matcher.group(NORMAL_VARIABLE_NAME_GROUP_ID);

        String functionSignature = variableName + "()";
        String functionSelector = getFunctionSelector(functionSignature);

        return Optional.of(new SolidityFunction(functionSelector, functionSignature));
    }
    return Optional.empty();
}
\end{lstlisting}
\end{center} 

Wszystkie wykryte funkcje w poszczególnych liniach implementacji, zostają zapisane w bazie danych wraz z analizowanym kodem źródłowym oraz jego haszem.

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Zapisywanie kodu źródłowego ze zbiorem jego funkcji oraz haszu, label=lst:zapisywanieplikuzfunkcjami]
SolidityFile save(byte[] sourceCodeBytes) throws IOException {
    String sourceCode = new String(sourceCodeBytes, StandardCharsets.UTF_8);
    final String preparedSourceCode = sourceCode
        .replaceAll("(?m)\\s+$", "").replaceAll("(?m) +", " ")
        .replaceAll("(?m)^\\s+","");
         
        Set<SolidityFunction> functionsFromFile = findSolidityFunctionsFromSourceFile(new ByteArrayInputStream(sourceCodeBytes));
        
        return solidityFileRepository.save(new SolidityFile(sha3String(preparedSourceCode), sourceCode, functionsFromFile));
}
\end{lstlisting}
\end{center} 

Na listingu \ref{lst:zapisywanieplikuzfunkcjami} widać metodę klasy \textbf{SolidityService}, która zapisuje do bazy danych kod źródłowy, jego hasz oraz zbiór funkcji zidentyfikowanych w kodzie.
Przed utworzeniem hasza kodu źródłowego, usuwane są z niego wszystkie nadmierne spacje oraz puste linie, następnie jest tworzony hasz za pomocą funkcji haszującej SHA3.


\section{Wyszukiwanie selektorów funkcji w kodzie bajtowym}


Podczas identyfikacji inteligentnego kontraktu podawany jest kod bajtowy, który posiada w sobie selektory funkcji. Następnie na podstawie selektorów funkcji zawartych w kodzie bajtowym, zostają dopasowane implementacje inteligentnych kontraktów przechowywane w bazie danych. 

W tym podrozdziale przedstawię, w jaki sposób na podstawie kodu bajtowego są wyszukiwane selektory funkcji wykorzystywane podczas dopasowywania implementacji.


W celu wykrycia selektorów funkcji należy najpierw uzyskać listę instrukcji wykonywanych w kodzie bajtowym wraz z parametrami tych instrukcji. Do tego posłuży klasa \textbf{Dissassembler}, do której jest przekazywany kod bajtowy za pomocą metody \textbf{dissassembly} . W rezultacie wspomnianej metody zwracana jest lista instrukcji reprezentowanych przez klase \textbf{Instruction}. Klasa \textbf{Instruction} składa się z dwóch atrybutów: \textbf{opcode} typu \textbf{Opcode} oraz \textbf{hexParameters} typu \textbf{String}.

\subsection{Reprezentacja operacji EVM wewnątrz aplikacji}

\textbf{Opcode} jest to typ wyliczeniowy, który definiuje wszystkie kody operacji, jakie można wykonać na Ethereum Virtual Machine. Wszystkie te operacje zostały opisane w dokumencie definiującym EVM.\cite{ethereumyellowpaper}


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Reprezentacja kodów operacji w postaci typy wyliczeniowego, label=lst:fragment_opcodow]
...
MSIZE(0x59, 0, "Get the size of active memory in bytes."),
GAS(0x5A, 0, "Get the amount of available gas, including the corresponding reduction the amount of available gas."),
JUMPDEST(0x5B, 0, "Mark a valid destination for jumps."),

PUSH1(0x60, 1, "Place 1 byte item on stack."),
PUSH2(0x61, 2, "Place 2-byte item on stack."),
PUSH3(0x62, 3, "Place 3-byte item on stack."),
...
\end{lstlisting}
\end{center} 


Typ wyliczeniowy posiada w sobie trzy atrybuty: \textbf{hexValue}, \textbf{operandSize} oraz \textbf{description}, które są przekazywane w konstruktorze. Na listingu \ref{lst:fragment_opcodow} widać fragment deklaracji poszczególnych operacji. Pierwszym parametrem konstruktora jest \textbf{hexValue}, czyli kod operacji w postaci szesnastkowej. Następnie podawany jest \textbf{operandSize}, który określa rozmiar parametru danej operacji za pomocą liczby bajtów. Ostatnią przekazywaną informacją jest opis operacji.


\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Klasa mapujaca identyfikator operacji na reprezentacje operacji typu wyliczeniowego, label=lst:mapowanie_na_opcode]
class OpcodeTable {
    private OpcodeTable() { throw new UnsupportedOperationException();}

    private static final Map<Integer, Opcode> opcodes =
            unmodifiableMap(new HashMap<Integer, Opcode>() {{
                for (Opcode opcode : Opcode.values()) {
                    put(opcode.getHexValue(), opcode);
                }
            }});

    static Opcode getOpcodeByHex(String stringHex) {
        if(stringHex.length() != 2){
            throw new IllegalArgumentException("Expected length=2 stringHex");
        }
        return getOpcodeByHex(Integer.parseInt(stringHex, 16));
    }

    static Opcode getOpcodeByHex(int hex) {
        Opcode opcode = opcodes.get(hex);
        if (isNull(opcode)) {
            return Opcode.UNKNOWNCODE;
        }
        return opcode;
    }
}
\end{lstlisting}
\end{center} 



Ponieważ kod bajtowy przechowuje kody operacji oraz ich parametry w postaci szesnastkowej, w tym celu została utworzona klasa \textbf{OpcodeTable}, która umożliwia mapowanie kodu operacji na konkretny obiekt zdefiniowany w typie wyliczeniowym \textbf{Opcode}. Klasa \textbf{OpcodeTable} została zaprezentowana na listingu \ref{lst:mapowanie_na_opcode}. W przypadku, gdy podany kod nie posiada swojego odpowiednika w typie wyliczeniowym, wtedy zostaje zwrócony kod \textbf{UNKNOWNCODE}. 


\subsection{Odczytywanie instrukcji z kodu bajtowego}

Mając zdefiniowane w aplikacji wszystkie operacje maszyny wirtualnej Ethereum, można przystąpić do wyszukiwania wszystkich instrukcji z kodu bajtowego. Na listingu \ref{lst:metoda_wyszukujaca_instrukcje} widać metodę przestawiającą ten proces. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukująca instrukcje instrukcje w kodzie bajtowym, label=lst:metoda_wyszukujaca_instrukcje]
private List<Instruction> getInstructions(String bytecode) {
    String validBytecode = getValidBytecode(bytecode);
    HexStringIterator hexStringIterator = new HexStringIterator(validBytecode);

    List<Instruction> instructions = new ArrayList<>();
    while (hexStringIterator.hasNext()) {
        Opcode opcode = getOpcodeByHex(hexStringIterator.next());
        String instructionParameter = getInstructionOperand(opcode.getOperandSize(), hexStringIterator);
        instructions.add(new Instruction(opcode, instructionParameter.toLowerCase()));
    }
    return instructions;
} 
\end{lstlisting}
\end{center} 

Do iteracji po kodzie bajtowym został wykorzystany iterator typu \textbf{HexStringIterator}, który odczytuje po jednym bajcie, dopóki istnieją kolejne bajty. W każdej iteracji pętli jest definiowany konkretny obiekt typu \textbf{Opcode} za pomocą metody \textbf{getOpcodeByHex} przedstawionej na listingu \ref{lst:mapowanie_na_opcode}. Następnie w zależności od kodu operacji zostają pobierane kolejne bajty, które są parametrem instrukcji.\cite{ethereumyellowpaper} Na podstawie tych informacji tworzony jest obiekt typu \textbf{Instruction}, który jest dodawany do listy \textbf{instructions}, zwracanej na końcu wykonywania metody.


\subsection{Wyszukiwanie selektorów funkcji z listy instrukcji}

Po wykryciu wszystkich operacji wraz z ich parametrami przez klasę \textbf{Disassembly}, klasa \textbf{BytecodeService} może przystąpić do wyszukiwania ostatecznych selektorów funkcji. 

\begin{center}
\lstset{language=Java}
\begin{lstlisting}[caption=Metoda wyszukująca selektory funkcji na podstawie listy instrukcji, label=lst:metoda_wyszukujaca_selektory]
    private List<String> findFunctionSelectors(String bytecode) {
        final List<Instruction> instructions = disassembler.disassembly(bytecode);
        final List<String> functionSelectors = new LinkedList<>();
        int i = 0;
        final int size = instructions.size();

        while (i < size - 2) {
            Instruction first = instructions.get(i);
            Instruction second = instructions.get(i + 1);
            Instruction third = instructions.get(i + 2);

            boolean isCreationCodeEndFound =
                    first.hasOpcode(PUSH1) && first.hasHexParameter("00") &&
                            second.hasOpcode(RETURN) &&
                            third.hasOpcode(STOP);

            if (isCreationCodeEndFound) {i += 3;break;}
            i++;
        }
        
        boolean isCalldataloadOpcodeFound = false;
        while (i < size) {
            Instruction instruction = instructions.get(i);
            if (instruction.hasOpcode(JUMPDEST)) {break;}
            if (instruction.hasOpcode(CALLDATALOAD)) {isCalldataloadOpcodeFound = true;}

            if (isCalldataloadOpcodeFound &&
                    instruction.hasOpcode(PUSH4) &&
                    !(instruction.hasHexParameter(PUSH4_MASK))) {
                functionSelectors.add(instruction.getHexParameter());
            }
            i++;
        }
        return functionSelectors;
    }
\end{lstlisting}
\end{center}

Na listingu \ref{lst:metoda_wyszukujaca_selektory} została przedstawiona metoda \textbf{findFunctionSelectors} zwracająca listę selektorów funkcji znajdujących się w kodzie bajtowym. 

Kod bajtowy dzieli się na część creation oraz runtime. Cześć creation odpowiada za utworzenie kontraktu, natomiast runtime za uruchamianie go. Sygnatury funkcji są zdefiniowane na początku części runtime, wiec cześć creation można pominąć.\cite{deconstructingsmartcontract}



Pierwsza pętla widoczna na listingu \ref{lst:metoda_wyszukujaca_selektory} pomija wszystkie instrukcje znajdujące się w części creation. Koniec części creation określa schemat trzech instrukcji. Pierwszą instrukcją jest PUSH1, która umieszcza na stosie wartość 0, po niej muszą występują kolejno operacja RETURN oraz STOP.\cite{deconstructingsmartcontract} Na listingu \ref{lst:metoda_wyszukujaca_selektory} w 12 linii zostały zaimplementowane wspomniane warunki.


Po pominięciu pierwszej części kodu bajtowego należy wyciągnąć selektory funkcji z części runtime. W tym celu wyszukiwana jest operacja CALLDATALOAD. Jeśli operacja została znaleziona oznacza to że następnie będzie odczytywany selektor funkcji z wiadomości przekazanej od użytkownika.\cite{deconstructingsmartcontract}

Selektor ten zostaje poddany serii skoków warunkowych. Każdy skok odpowiada jednej funkcji. Przed każdym skokiem warunkowym musi zostać wrzucona na stos wartość wykorzystana do porównania. W związku z tym wszystkie selektory funkcji są wrzucane na stos za pomocą operacji PUSH4, a przed konkretnym skokiem warunkowym są porównywane za pomocą operacji EQ.\cite{deconstructingsmartcontract}

Jeśli selektor przekazany przez użytkownika pasuje do jednego z selektorów funkcji znajdujących się w kodzie bajtowym, wtedy następuje skok do fragmentu kodu bajtowego zawierającego implementacje tej funkcji. W innym przypadku skok nastąpi do operacji JUMPDEST znajdującej się po serii skoków warunkowych.\cite{deconstructingsmartcontract}

W związku z powyższym druga pętla widoczna na listingu \ref{lst:metoda_wyszukujaca_selektory} iteruje po kodzie bajtowym w celu wyszukania operacji CALLDATALOAD. Następnie wszystkie znalezione parametry operacji PUSH4 zostają dodane do listy \textbf{functionSelectors} do momentu wyszukania operacji JUMPSTDEST. Jedynym wyjątkiem będzie czterobajtowa maska która zostaje pominięta.



\section{Dopasowywanie implementacji na podstawie kodu bajtowego}

Po wyszukaniu wszystkich selektorów funkcji z kodu bajtowego zostają one wykorzystane do wyszukania odpowiedniej implementacji. Z bazy danych zostają wyszukane wszystkie pliki posiadające chociaż jeden selektor funkcji znajdujący się w kodzie bajtowym. Dla każdego pobranego w ten sposób pliku wyznaczany jest współczynnik dopasowania kodu bajtowego z plikiem. 

\subsection{Sposoby na wyznaczanie współczynnika dopasowania}

Do wyznaczania współczynnika dopasowania kodu bajtowego dla konkretnej implementacji można było zastosować kilka podejść. Poniżej opiszę trzy przetestowane przez mnie sposoby: 



\begin{enumerate}
\item Pierwszym sposobem jest wyznaczenie ilości dopasowanych selektorów funkcji kodu bajtowego w danym pliku Solidity względem wszystkich selektorów funkcji w kodzie bajtowym. 
Rozwiązanie to można zaprezentować za pomocą wzoru:

\begin{center}
W = M/B
\end{center}

gdzie:

W - współczynnik dopasowania implementacji

M - liczba selektorów funkcji wspólnych dla pliku oraz kodu bajtowego 

B - liczba selektorów funkcji występujących w kodzie bajtowym


Po zastosowaniu takiego rozwiązania, gdy użytkownik otrzyma wynik 100\%, wtedy może mieć pewność, że wszystkie selektory znalezione w kodzie bajtowym mają swój odpowiednik w implementacji. Problem mogą sprawić implementacje posiadające bardzo dużą ilość selektorów funkcji np. biblioteki matematyczne, wtedy wyniki dla takich bibliotek będą miały równie wysoki współczynnik dopasowania co implementacja, która jest mniejsza oraz bardziej zbliżona do prawdziwej, a to z kolei może fałszywie zakłamywać wyniki.

\item Drugim sposobem jest zwracanie ilości dopasowanych selektorów funkcji z kodu bajtowego względem ilości wszystkich selektorów zidentyfikowanych w kodzie źródłowym. 
Rozwiązanie to przedstawia wzór:

\begin{center}
W = M/S
\end{center}

W - współczynnik dopasowania implementacji

M - liczba selektorów funkcji wspólnych dla pliku oraz kodu bajtowego 

S - liczba selektorów funkcji występujących w kodzie źródłowym


Problemem w tym rozwiązaniu jest to, że podczas wyszukiwania sygnatur funkcji w implementacji wyszukiwane są wszystkie funkcje w pliku z różnych kontraktów zależnych od siebie. Podczas dziedziczenia jest też dziedziczona sygnatura funkcji, która jest zapisywana w kodzie bajtowym ostatecznego kontraktu. Natomiast w przypadku innej relacji kontraktów w kodzie bajtowym nie występują selektory funkcji z innego kontraktu. Przykładowo podczas parsowania pliku Solidity może być taka sytuacja, że zostaną wykryte wszystkie sygnatury funkcji, natomiast podczas analizy kodu bajtowego nie zostaną one wykryte. W takim wypadku zaprezentowany współczynnik będzie mógł zawyżać wynik dopasowania.

\item Trzecim sposobem, który może rozwiązać problemy dwóch poprzednich, jest obliczenie \textbf{współczynnika podobieństwa Jaccarda}. Współczynnik ten jest zdefiniowany jako iloraz mocy części wspólnej zbiorów i mocy sumy zbiorów. Biorąc pod uwagę, że zarówno wyszukiwanie funkcji w kodzie bajtowym, jak i w implementacji może zwrócić czasami niedokładny wynik, wtedy współczynnik ten będzie odpowiednio ustalać wynik, mając na uwadze problemy dwóch poprzednich sposobów. Po dostosowaniu indeksu Jaccarda w aplikacji wzór będzie wyglądać następująco:

\begin{center}
W = M / ( S + B - M )
\end{center}

W - współczynnik dopasowania implementacji

M - liczba selektorów funkcji wspólnych dla pliku oraz kodu bajtowego 

S - liczba selektorów funkcji występujących w kodzie źródłowym

B - liczba selektorów funkcji występujących w kodzie bajtowym

Mianownik oznacza moc sumy zbiorów.
\end{enumerate}

\subsection{Testowanie aplikacji pod kątem dopasowywania implementacji}


Zostały przeprowadzone testy trzech wspominanych sposobów. Jako grupę testową pobrałem 441 implementacji kontraktów ze strony etherscan.io skompilowanych dla wersji kompilatora od 0.4.22 do 0.4.25. Do kompilacji kontraktów wykorzystałem kompilator solc oraz bibliotekę py-solc, która ułatwia kompilacje z poziomu języka Python.

Każdy kod źródłowy skompilowałem wersją kompilatora sugerowaną przez etherscan.io dla danej implementacji. Po kompilacji kompilator zwraca listę kodów bajtowych dla każdego zadeklarowanego w kodzie źródłowym kontraktu. Dla każdego skompilowanego pliku został wybrany kod bajtowy kontraktu wskazanego na stronie etherscan.io.

Tabela \ref{tab:testydop} przedstawia wyniki testów przeprowadzonych na wszystkich trzech wspomnianych metodach wyznaczania współczynnika dopasowania. Wyniki testów przedstawiają następujące wartości:
\begin{enumerate}

\item \textbf{Liczba dopasowanych implementacji} oznacza sumę implementacji posiadających współczynnik dopasowania powyżej 80\% dla wszystkich identyfikowanych kodów bajtowych. Wysoka liczba dopasowanych implementacji oznacza zawyżone wyniki dopasowania.


\item \textbf{Liczba skutecznie dopasowanych implementacji} - skutecznie dopasowana implementacja to taka implementacja, z której rzeczywiście powstał identyfikowany kod bajtowy. Jeśli przesłana implementacja po dopasowaniu ma najwyższą wartość współczynnika dopasowania względem innych, oznacza to, że jest skutecznie dopasowana. Test ten pokazuje, czy podczas dopasowania, prawdziwa implementacja posiada największy współczynnik dopasowania względem innych.
\end{enumerate}

\begin{table}[]
%\begin{table}
\centering
\caption{Wyniki testów metod dopasowywania}\label{tab:testydop}
\begin{tabular}{| c | c | c | c | m{15pt}}\hline \rule[5mm]{0cm}{0mm}
Metoda dopasowywania & 1 & 2	& 3 \\ \hline\hline
\makecell{Liczba identyfikowanych kodów bajtowych} & \multicolumn{3}{c|}{441} \\ \hline
\makecell{Liczba dopasowanych implementacji} & 21975 & 21234 & 3728\\ \hline
\makecell{Liczba skutecznie dopasowanych \\implementacji} & 427 & 270  & 393\\ \hline
\end{tabular}
\end{table} 


Dla pierwszej metody uzyskano bardzo wysoką skuteczność dopasowania. Problemem w przypadku tej metody jest bardzo duża liczba dopasowanych implementacji, która świadczy o bardzo zawyżonych wynikach. Metoda ta sprawdzała, czy dla danego kodu bajtowego, zostały dopasowane w nim wszystkie selektory funkcji. W przypadku bardzo dużych implementacji ten wynik jest zawyżany, ponieważ jest szansa, że pliki z dużą ilością sygnatur funkcji będą miały często wysoki współczynnik dopasowania podczas identyfikacji małych kodów bajtowych. Mimo wysokiej skuteczności w testach jest bardzo dużo dopasowanych implementacji, co świadczy o niejednoznacznych wynikach dopasowania.

Drugie rozwiązanie mimo mniejszej liczby dopasowanych implementacji posiada najmniejszą liczbę skutecznie dopasowanych implementacji. Problemem są duże implementacje z wieloma kontraktami, które nie są dziedziczone przez główny kontrakt. Natomiast w kodzie bajtowym są wykrywane tylko te selektory funkcji, które są częścią kontraktu lub są dziedziczone po innym.

Okazuje się, że najlepszym sposobem na wyznaczanie współczynnika dopasowania jest metoda 3 (indeks Jaccarda), ze względu na wysoką liczbę poprawnie zidentyfikowanych implementacji (co świadczy wysokiej o skuteczności) oraz małą liczbę implementacji uznanych za dopasowane (co świadczy o mniejszej ilości zawyżonych wyników).




\subsection{Jak poprawić dopasowywanie implementacji?}


Pomimo wyznaczenia najlepszego sposobu na wyliczanie współczynnika dopasowania, są jeszcze pewne problemy, przez które dla pewnych kodów bajtowych nie da się uzyskać 100\% wartości dopasowania dla realnej implementacji kodu bajtowego, mimo tego, że implementacja ta znajduje się w bazie danych.

Na ten moment największym problemem jest poprawne parsowanie pliku Solidity. W celu polepszenia wyników dopasowywania można ulepszyć aktualny parser tak, aby podczas parsowania ignorował sygnatury funkcji, które nie są dziedziczone przez finalny kontrakt lub można skorzystać z innych gotowych rozwiązań do parsowania plików Solidity. Najprostszym sposobem będzie wykorzystanie kompilatora solc, który po kompilacji zwraca ABI dla danego kontraktu. 


Wykorzystując kompilator solc do uzyskania sygnatur funkcji, zamiast stworzonego przez mnie parsera, liczba skutecznie dopasowanych implementacji powinna wzrosnąć. Podczas przesyłania nowego kontraktu do aplikacji wystarczyłoby podać wersje kompilatora. Po przesłaniu aplikacja kompilowałaby implementacje, po udanej kompilacji zostanie zwrócone ABI, z którego można wyciągnąć wszystkie sygnatury funkcji. Zmniejszyłoby to nadmiarową ilość wyszukanych sygnatur funkcji w kodzie źródłowym.

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage 


\chapter*{Podsumowanie}					% bez numeru rozdziału
\addcontentsline{toc}{chapter}{Podsumowanie} 	% bez numeru w spisie treści


Celem powyższej pracy było utworzenie aplikacji umożliwiającej identyfikacje kodu bajtowego kontraktu. Dokładniejsza analiza tych założeń spowodowała, że zdecydowano się zrealizować stronę internetową, która pozwala na korzystanie z aplikacji bez konieczności instalacji.

Efektem pracy jest aplikacja internetowa o nazwie Ethereum Smart Contract Identifier. Aplikacja udostępnia przyjazny interfejs użytkownika oraz API dla programistów. 
Identyfikacja kontraktów polega na wyszukaniu odpowiedniej implementacji ze zgromadzonej bazy danych, jeśli użytkownik chce dodać nowy kontrakt do bazy danych, wtedy musi przejść proces autoryzacji.
Na podstawie powyższego opisu aplikacji, można stwierdzić, że cele pracy zostały w pełni zrealizowane. 

W przyszłości aplikacja możne zostać ulepszona o lepszy sposób wyszukiwania sygnatur funkcji w implementacjach oraz o dokładniejszy sposób wyszukiwania selektorów funkcji w kodzie bajtowym. Można ulepszyć parser do Solidity, tak aby wspierał wszystkie wersje języka lub zastąpić parser przez inne gotowe narzędzie.

Dalszym kierunkiem rozwoju może być utworzenie zautomatyzowanego systemu do gromadzenia implementacji kontraktów z całego internetu oraz połączenie takiego systemu z utworzoną aplikacją. Dzięki dużej ilości implementacji kontraktów można uzyskać bardzo dokładne wyniki podczas identyfikacji kontraktów.

\clearemptydoublepage	

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Bibliografia.
%____________________________________________________________________________________________
\phantomsection
\begin{thebibliography}{99}
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\addcontentsline{toc}{chapter}{Bibliografia}		% Dodanie do spisu treści.


\bibitem{whatisethereum} What is Ethereum \url{http://ethdocs.org/en/latest/introduction/what-is-ethereum.html}
\bibitem{vitalikethereumprehistory} Vitalik Buterin \emph{A Prehistory of the Ethereum Protocol} \url{https://vitalik.ca/2017-09-15-prehistory.html}.
\bibitem{ethersaleastatisticaloverview} Ethereum Blog \emph{Ether Sale: A Statistical Overview } \url{https://blog.ethereum.org/2014/08/08/ether-sale-a-statistical-overview/}.
\bibitem{devcon0} Ethereum \emph{DEVCON-8 recap} \url{https://blog.ethereum.org/2014/12/05/d%CE%BEvcon-0-recap/}
\bibitem{whyethereumusesecuretries} Seung Woo Kim \emph{Secure Tree: Why State Tries Key is 256 Bits} \url{https://medium.com/codechain/secure-tree-why-state-tries-key-is-256-bits-1276beb68485}.
\bibitem{ethereumyellowpaper} Dr. Gavin Wood \emph{Ethereum: A secure decentralised generalised transaction Ledger. Byzantium version 4e05aa0 - 2019-03-04}.
\bibitem{historyofethereum} Ethereum Homestead \emph{History of Ethereum } \url{https://ethereum-homestead.readthedocs.io/en/latest/introduction/history-of-ethereum.html}.
\bibitem{proceswydaniaethereum} Ethereum \emph{Ethereum Launch Process} \url{https://ethereum.github.io/blog/2015/03/03/ethereum-launch-process/}.


\bibitem{smartcontractswhatis} Ethos - \emph{What are smart contracts?} \url{https://www.ethos.io/smart-contracts}
\bibitem{soliditygrammar} Ethereum \emph{Solidity Grammar} \url{https://github.com/ethereum/solidity/blob/develop/docs/grammar.txt}.
\bibitem{deconstructingsmartcontract} Alejandro Santander \emph{Deconstructing a Solidity Contract} \url{https://blog.zeppelin.solutions/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737}. 
\bibitem{reversingethereumsmartcontract} Brandon Arvanaghi \emph{Reversing Ethereum Smart Contracts} \url{https://arvanaghi.com/blog/reversing-ethereum-smart-contracts/}.
\bibitem{soliditygetterfunction} Solidity Documentation \emph{Getter Functions} \url{https://solidity.readthedocs.io/en/v0.5.5/contracts.html}.
\bibitem{whatisabi} Solidity Documentation \emph {Contract ABI Specification} \url{https://solidity.readthedocs.io/en/develop/abi-spec.html}.
\bibitem{soliditytypes} Solidity Documentation \emph {Types} \url{https://solidity.readthedocs.io/en/v0.5.7/types.html}.


\bibitem{whatisapi} Elliot Bettilyon \emph{What Is an API and Why Should I Use One?} \url{https://medium.com/@TebbaVonMathenstien/what-is-an-api-and-why-should-i-use-one-863c3365726b}.
\bibitem{resthttpstatuscode} Internet Engineering Task Force (IETF) \emph{Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content} \url{https://tools.ietf.org/html/rfc7231}.
\bibitem{solidityarrayindex} Solidity Documentation \emph{Arrays} \url{https://solidity.readthedocs.io/en/v0.5.3/types.html#arrays}.
\bibitem{urlencodedform} Dinesh Balaji \emph{Understanding HTML Form Encoding: URL Encoded and Multipart Forms} \url{https://dev.to/sidthesloth92/understanding-html-form-encoding-url-encoded-and-multipart-forms-3lpa}.
\bibitem{rfc2616} Network Working Group \emph{Hypertext Transfer Protocol - HTTP/1.1} \url{https://www.ietf.org/rfc/rfc2616.txt}.
\bibitem{baeldungoptional}  Yannick Majoros \emph{Java 8 Optional - Avoid Null and NullPointerException Altogether - and Keep It Pretty} \url{https://dzone.com/articles/java-8-optional-avoid-null-and}.
\bibitem{springmvc} Baeldung \emph{Spring Web Annotations} \url{https://www.baeldung.com/spring-mvc-annotations}.
\bibitem{thymeleafguide} Rafał Borowiec \emph{Spring MVC and Thymeleaf: how to access data from templates} \url{https://www.thymeleaf.org/doc/articles/springmvcaccessdata.html}.
\bibitem{mongoguide} Spring \emph{Accessing Data with MongoDB} \url{https://spring.io/guides/gs/accessing-data-mongodb/}.
\end{thebibliography}

% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage					
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis tabel.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.	
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}		% Dodanie do spisu treści.
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________
%____________________________________________________________________________________________
% Spis rysunków.
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

%____________________________________________________________________________________________%____________________________________________________________________________________________
% Spis listingów. 
%____________________________________________________________________________________________
\phantomsection						% Służy do poprawnej nawigacji odnośnika w spisie treści.
\lstlistoflistings
\addcontentsline{toc}{chapter}{Spis listingów} 
% Wyczyszczenie strony z numeracji i paginy górnej, jeśli strona jest pusta. 
\clearemptydoublepage
% koniec

\end{document}
