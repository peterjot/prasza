\BOOKMARK [0][-]{chapter*.2}{Wstep}{}% 1
\BOOKMARK [0][-]{chapter.1}{Ethereum}{}% 2
\BOOKMARK [1][-]{section.1.1}{Historia}{chapter.1}% 3
\BOOKMARK [1][-]{section.1.2}{Czym sa Inteligentne kontrakty?}{chapter.1}% 4
\BOOKMARK [1][-]{section.1.3}{Ethereum Virtual Machine}{chapter.1}% 5
\BOOKMARK [2][-]{subsection.1.3.1}{Kody operacji}{section.1.3}% 6
\BOOKMARK [2][-]{subsection.1.3.2}{Kod bajtowy}{section.1.3}% 7
\BOOKMARK [2][-]{subsection.1.3.3}{Analiza kodu bajtowego}{section.1.3}% 8
\BOOKMARK [0][-]{chapter.2}{Solidity}{}% 9
\BOOKMARK [1][-]{section.2.1}{Sygnatura funkcji}{chapter.2}% 10
\BOOKMARK [1][-]{section.2.2}{Selektor funkcji}{chapter.2}% 11
\BOOKMARK [1][-]{section.2.3}{Generowanie akcesor\363w podczas kompilacji}{chapter.2}% 12
\BOOKMARK [0][-]{chapter.3}{Projekt Aplikacji}{}% 13
\BOOKMARK [1][-]{section.3.1}{Opis funkcjonalnosci}{chapter.3}% 14
\BOOKMARK [2][-]{subsection.3.1.1}{Identyfikacja inteligentnych kontrakt\363w}{section.3.1}% 15
\BOOKMARK [2][-]{subsection.3.1.2}{Dodanie kodu zr\363d\233owego kontraktu do aplikacji}{section.3.1}% 16
\BOOKMARK [2][-]{subsection.3.1.3}{Interfejs programistyczny aplikacji}{section.3.1}% 17
\BOOKMARK [1][-]{section.3.2}{Przedstawienie architektury}{chapter.3}% 18
\BOOKMARK [1][-]{section.3.3}{Po\233aczenie z baza danych}{chapter.3}% 19
\BOOKMARK [1][-]{section.3.4}{Identyfikacja sygnatur funkcji w kodzie zr\363d\233owym}{chapter.3}% 20
\BOOKMARK [2][-]{subsection.3.4.1}{Kontroler interfejsu programistycznego}{section.3.4}% 21
\BOOKMARK [2][-]{subsection.3.4.2}{Kontroler strony internetowej}{section.3.4}% 22
\BOOKMARK [2][-]{subsection.3.4.3}{Przetwarzanie kodu zr\363d\233owego}{section.3.4}% 23
\BOOKMARK [1][-]{section.3.5}{Wyszukiwanie selektor\363w funkcji w kodzie bajtowym}{chapter.3}% 24
\BOOKMARK [2][-]{subsection.3.5.1}{Reprezentacja operacji EVM wewnatrz aplikacji}{section.3.5}% 25
\BOOKMARK [2][-]{subsection.3.5.2}{Odczytywanie instrukcji z kodu bajtowego}{section.3.5}% 26
\BOOKMARK [2][-]{subsection.3.5.3}{Wyszukiwanie selektor\363w funkcji z listy instrukcji}{section.3.5}% 27
\BOOKMARK [1][-]{section.3.6}{Dopasowywanie implementacji na podstawie kodu bajtowego}{chapter.3}% 28
\BOOKMARK [2][-]{subsection.3.6.1}{Sposoby na wyznaczanie wsp\363\233czynnika dopasowania}{section.3.6}% 29
\BOOKMARK [2][-]{subsection.3.6.2}{Testowanie aplikacji pod katem dopasowywania implementacji}{section.3.6}% 30
\BOOKMARK [2][-]{subsection.3.6.3}{Jak poprawic dopasowywanie implementacji?}{section.3.6}% 31
\BOOKMARK [0][-]{section*.12}{Bibliografia}{}% 32
\BOOKMARK [0][-]{chapter*.14}{Spis tabel}{}% 33
\BOOKMARK [0][-]{chapter*.16}{Spis rysunk\363w}{}% 34
\BOOKMARK [0][-]{chapter*.18}{Spis listing\363w}{}% 35
