\BOOKMARK [0][-]{chapter*.2}{Wstep}{}% 1
\BOOKMARK [0][-]{chapter.1}{Ethereum}{}% 2
\BOOKMARK [1][-]{section.1.1}{Historia}{chapter.1}% 3
\BOOKMARK [1][-]{section.1.2}{Czym sa Inteligentne kontrakty?}{chapter.1}% 4
\BOOKMARK [1][-]{section.1.3}{Ethereum Virtual Machine}{chapter.1}% 5
\BOOKMARK [2][-]{subsection.1.3.1}{Kody operacji}{section.1.3}% 6
\BOOKMARK [2][-]{subsection.1.3.2}{Kod bajtowy}{section.1.3}% 7
\BOOKMARK [2][-]{subsection.1.3.3}{Analiza kodu bajtowego}{section.1.3}% 8
\BOOKMARK [0][-]{chapter.2}{Solidity}{}% 9
\BOOKMARK [1][-]{section.2.1}{Modyfikatory widocznosci funkcji oraz zmiennych}{chapter.2}% 10
\BOOKMARK [1][-]{section.2.2}{Generowanie akcesor\363w podczas kompilacji}{chapter.2}% 11
\BOOKMARK [1][-]{section.2.3}{Interakcja z inteligentnymi kontraktami}{chapter.2}% 12
\BOOKMARK [2][-]{subsection.2.3.1}{Czym jest ABI?}{section.2.3}% 13
\BOOKMARK [2][-]{subsection.2.3.2}{Przyk\233ad interakcji z innym kontraktem}{section.2.3}% 14
\BOOKMARK [0][-]{chapter.3}{Projekt Aplikacji}{}% 15
\BOOKMARK [1][-]{section.3.1}{Opis funkcjonalnosci}{chapter.3}% 16
\BOOKMARK [2][-]{subsection.3.1.1}{Identyfikacja inteligentnych kontrakt\363w}{section.3.1}% 17
\BOOKMARK [2][-]{subsection.3.1.2}{Dodanie kodu zr\363d\233owego kontraktu do aplikacji}{section.3.1}% 18
\BOOKMARK [2][-]{subsection.3.1.3}{Interfejs programistyczny aplikacji}{section.3.1}% 19
\BOOKMARK [1][-]{section.3.2}{Przedstawienie architektury}{chapter.3}% 20
\BOOKMARK [1][-]{section.3.3}{Po\233aczenie z baza danych}{chapter.3}% 21
\BOOKMARK [1][-]{section.3.4}{Identyfikacja sygnatur funkcji w kodzie zr\363d\233owym}{chapter.3}% 22
\BOOKMARK [2][-]{subsection.3.4.1}{Kontroler interfejsu programistycznego}{section.3.4}% 23
\BOOKMARK [2][-]{subsection.3.4.2}{Kontroler strony internetowej}{section.3.4}% 24
\BOOKMARK [2][-]{subsection.3.4.3}{Przetwarzanie kodu zr\363d\233owego}{section.3.4}% 25
\BOOKMARK [1][-]{section.3.5}{Wyszukiwanie selektor\363w funkcji w kodzie bajtowym}{chapter.3}% 26
\BOOKMARK [2][-]{subsection.3.5.1}{Reprezentacja operacji EVM wewnatrz aplikacji}{section.3.5}% 27
\BOOKMARK [2][-]{subsection.3.5.2}{Odczytywanie instrukcji z kodu bajtowego}{section.3.5}% 28
\BOOKMARK [2][-]{subsection.3.5.3}{Wyszukiwanie selektor\363w funkcji z listy instrukcji}{section.3.5}% 29
\BOOKMARK [1][-]{section.3.6}{Dopasowywanie implementacji na podstawie kodu bajtowego}{chapter.3}% 30
\BOOKMARK [2][-]{subsection.3.6.1}{Sposoby na wyznaczanie wsp\363\233czynnika dopasowania}{section.3.6}% 31
\BOOKMARK [2][-]{subsection.3.6.2}{Testowanie aplikacji pod katem dopasowywania implementacji}{section.3.6}% 32
\BOOKMARK [2][-]{subsection.3.6.3}{Jak poprawic dopasowywanie implementacji?}{section.3.6}% 33
\BOOKMARK [0][-]{chapter*.11}{Podsumowanie}{}% 34
\BOOKMARK [0][-]{section*.14}{Bibliografia}{}% 35
\BOOKMARK [0][-]{chapter*.16}{Spis tabel}{}% 36
\BOOKMARK [0][-]{chapter*.18}{Spis rysunk\363w}{}% 37
\BOOKMARK [0][-]{chapter*.20}{Spis listing\363w}{}% 38
